{"meta":{"title":"shinran","subtitle":"","description":"","author":"le","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-04-05T13:18:03.630Z","updated":"2020-02-26T07:13:19.000Z","comments":true,"path":"recent/index.html","permalink":"http://yoursite.com/recent/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-05T14:18:42.559Z","updated":"2020-04-05T14:18:42.559Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-04-05T13:56:05.511Z","updated":"2020-04-05T13:56:05.511Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-05T13:57:00.327Z","updated":"2020-04-05T13:57:00.327Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-04-05T13:56:16.427Z","updated":"2020-04-05T12:11:55.050Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-06T02:14:03.466Z","updated":"2020-04-06T02:14:03.463Z","comments":true,"path":"sites/index.html","permalink":"http://yoursite.com/sites/index.html","excerpt":"","text":"关于我一只懒猪+一个小白QQ:434299971Email:4342/Users/parallei/Desktop/theme-settings/index.md99971@qq.com写博客的目的呢,一方面帮助自己巩固知识点,提高自己,另一方面帮助他人"}],"posts":[{"title":"javascript","slug":"JavaScript","date":"2020-03-21T10:53:12.000Z","updated":"2020-04-06T11:07:53.537Z","comments":true,"path":"2020/03/21/JavaScript/","link":"","permalink":"http://yoursite.com/2020/03/21/JavaScript/","excerpt":"(～￣▽￣)～","text":"(～￣▽￣)～ JavaScript 历史及历程web 发展史Mosaic,是互上第一个获普遍使用和能够显示图片的网页浏览器。于 1993 年问世。 1994 年 4 月，马克.安德森和 Silicon Graphics（简称为 SGI，中译为“视算科技”或“硅图”）公司的创始人吉姆·克拉克（Jim Clark）在美国加州设立了“Mosaic CommunicationCorporation”。 Mosaic 公司成立后，由于伊利诺伊大学拥有 Mosaic 的商标权，且伊利诺伊大学已将技术转让给 Spy Glass 公司，开发团队必须彻底重新撰写浏览器程式码，且浏览器名称更改为 NetscapeNavigator，公司名字于 1994 年 11 月改名为“NetscapeCommunication Corporation”，此后沿用至今，中译为“网景”。 微软的 Internet Explorer 及 Mozilla Firefox 等，其早期版本皆以 Mosaic 为基础而开发。微软随后买下 Spy Glass 公司的技术开发出 Internet Explorer 浏览器，而 Mozilla Firefox则是网景通讯家开放源代码后所衍生出的版本。 JS 历史JavaScript 作为 Netscape Navigator 浏览器的一部分首次出现在 1996 年。它最初的设计目标是改善网页的用户体验。 作者：Brendan Eich 期初 JavaScript 被命名为 LiveScript，后因和 Sun 公司合作，因市场宣传需要改名,JavaScript。后来 Sun 公司被 Oracle 收购，JavaScript 版权归 Oracle 所有。 浏览器组成 shell 部分——用户能操作部分(壳) 内核部分——用户看不到的部分 1 ) 渲染引擎（语法规则和渲染） 2 ) JS 引擎 3 ) 其他模块（如异步) JS 引擎2001 年发布 ie6，首次实现对 JS 引擎的优化。 2008 年 Google 发布最新浏览器 Chrome，它是采用优化后的 javascript 引擎，引擎代号 V8，因能把 JS 代码直接转化为机械码来执行，进而以速度快而闻名。 后 Firefox 也推出了具备强大功能的 JS 引擎 Firefox3.5 TraceMonkey（对频繁执行的代码做了路径优化） Firefox4.0 JeagerMonkey JS 的逼格（特有特色）123456789编译型语言: 通篇翻译后，生成翻译完的文件，程序执行翻译后的文件代表语言 : C,C++优点 : 快(常用于系统，游戏)缺点 : 移植性不好（不跨平台，window 和 Linux 不能混用）解释性语言 看一行翻译一行，不生成特定文件代表语言 : JS,PHP，python 带尖角号优点 : 可以跨平台缺点 : 稍微慢点 123456789101112主流浏览器（必须有独立内核）市场份额大于 3%// 内核名称:IE ：tridentchrome ： webkit / blinkfirefox ： geckoopera ： presto / Blinksafari ： webkit 1、JS 是解释性语言：(不需要编译成文件）跨平台 java 先通过 javac，编译成.class 文件，通过 jvm（Java 虚拟机）进行解释执行.java→java→ 编译 →.class→jvm→ 解释执行（java 可以跨平台）（java 是 oak 语言） &lt;link rel = &quot;&quot;&gt; 是异步加载 2、单线程：同一时间只能做一件事——JS 引擎是单线程（同一时间做很多事叫多线程） ECMA（欧洲计算机制造联合会）标注：为了取得技术优势，微软推出了 JScript， CEnvi 推出 ScriptEase，与 JavaScript 同样可在浏览器上运行。为了统一规格 JavaScript 兼容于 ECMA 标准，因此也称为 ECMAScript。 开始学习 JSJS 三大部分 ECMAScript、DOM、BOM如何引入 JS1、页面内嵌&lt;script&gt;&lt;/script&gt;标签,写 head 里面也行,写 body 里面也行 123456例:&lt;body&gt; &lt;script type=\"text/javascript\"&gt; //告诉浏览器我们是 js &lt;/script&gt;&lt;/body&gt; 2、外部 JS 文件，引入&lt;script src=“location.js”&gt;&lt;/script&gt; 例如：以 lesson.js 保存文件，再引入到 html 中,为符合 web 标准（w3c 标准中的一项）结构（html）、行为（js）、样式（css）相分离，通常会采用外部引入。 一个文件中可以包括多个 css，js——不混用特殊写页面，大部分写在外部——不混用,如果同时写了内部的 js 和外部的 js，那么是外部的 js 文件显示出来 js 变量变量(variable)HTML，css 不是编程语言，是计算机语言，编程语言需要有变量和函数变量是存放东西，方便后续使用的框 1）变量声明1、 声明、赋值分解 123 var a; //这个叫变量声明。我们向系统中申请了 var 这个框，命名叫 a,给 a 赋值 100，写作 a =100，这里不是等号是赋值var a ；a =100；可以简化写成 var a=100； 2、 单一 var 声明法 123456789var a,b,c,d;————单一 var 模式// var a = 100; var a = 100;// var a = 200; var a,b,c,d,e; b = 100;// var a = 300; &gt; &gt; 标准写法: c = 100;// var a = 400; a = 100; d = 100;// var a = 500; e = 100;如写做：var a = 10；a=20;那么后面的 20 就会覆盖掉前面的 10 命名规则（用接近的英文单词）———— 起变量名一定要以英文语义化 变量名必须以英文字母、_、$ 开头 变量名可以包括英文字母、_、$、数字 不可以用系统的关键字、保留字作为变量名 关键字和保留字关键字（有特殊语法含义的字）123456break else new varcase finally return voidcatch for switch whiledefault if throw deletein try do instanceoftypeof 保留字（未来可能当做关键字的词）12345678abstract enum int shortBoolean export interface staticbyte extends long superchar final native synchronizeclass float package throwsconst goto private transientdebugger implements pritected volatiledouble import public 基本语法123456// 下面是变量 var a = 10; var b = 20; var c; c = a + b; 先运算等号右边的 a+b，运算完后，再赋值给左边 c先取值，再赋值 运算大于赋值的优先级 js 是动态语言，动态语言基本上都是解释性语言，解释性语言基本上都是脚本语言 js 是浮点型语言（带小数点） 值类型（数据类型）1、不可改变的原始值（栈数据）栈 stackNumber String Boolean undefined null已经放进去的值不可改变，只会改房间编号为 null(硬盘原理) 1234567891011121314// Number 数字类型var a = 123; String// 字符串类型,语言放双引号里例: var a=”语言”，““是空串// Boolean 布尔数字就两个值，false，true// undefined：是没有定义的，表示还没赋值,仅一个值 underfined// null代表空，占位用，用空值来覆盖 栈、堆array、Object、function、…date、RegExp 原始值存于 stack(栈) 里面的 引用值存于 heap(堆) 里面的; 12345678例: var a =10; var b = a; a = 20; document.write(b); 答案：10 原始值是我把一个值放到另一个值里面，改了第一个值，第二个值不变 2、引用值（堆数据）大致上放堆 heap 里面 array 数组, Object, function … data,RegExp 正则 var arr = [1,2,3,4,5,false,”abc”]; //这是数组 1234567891011例:var arr = [1];var arr1 = arr;arr.push(2);document.write(arr1);答案：arr 是 1,2。arr1 是 1,2引用值是把第一个值放到第二个值里面，改第一个值，第二个值也改变js 由值决定类型。原始值和引用值唯一的不同是赋值形式不同 1、 栈 stack 先进去的东西最后出来，有底没有顶。 在栈内存里面放东西，先放在底部 2、 堆 heap 怎么放怎么拿，散列结构 1234567891011121314var a = 10;var b = a；是 a 先取出 10，copy 一份放到 b 里面，改变 a 的值，b 的值是不变的，再把 a=20;时 b 的值还是 10，不发生改变var arr = [1,2];var arr1 =arr;arr.push(3);答案：这往[1,2]放 3，arr 和 arr1 都是[1,2,3]引用值是在栈内存里面放堆的地址，拷贝的也是地址，所以改变 arr，arr1 也改变了var arr = [1,2];var arr1 =arr;arr = [1,3];document.write(arr1);答案：arr = [1,3];是新建了一个新的房间。arr1 是 1,2,现在是插入新引入值”房间”, js 语句基本规则 语句后面要用分号结束“；”但 function test(){}，for(){}，if(){}后面都不用加分号 js 语法错误会引发后续代码终止，但不会影响其它 js 代码块 错误分为两种: 低级错误（语法解析错误），不能写中文 逻辑错误（标准错误，情有可原，错的那个执行不了） 书写格式要规范，“= + / -”两边都应该有空格 js 输出console.log();是把信息展示（输出）在控制台 document.write();是把信息（输出）展示到网页 js 运算符一、运算操作符“-”，“*”，“/“，“%”，”=“，“()” 运算符除了 + 号两边的是转换为字符串，其他的运算符全部是转换为 Number 数字类型的 +（加号） “+”作用：数学运算、字符串链接 任何数据类型加字符串都等于字符串 1234例 var a = “a”+ true + 1; //打印 atrue1例 var a = 1 + “a” + 1 + 1; //打印 1a11例 var a = 1 + 1 + “a” + 1 + 1; //打印 2a11，从左向右运算例 var a = 1 + 1 + “a” +( 1 + 2); //打印 2a3 - * /（减号、乘号、除号）123456例 var a = 0 – 1； //等于-1例 var a = 2 * 1； //等于 2例 var a = 0 / 0； //答案是 NaN，应该得出一个数字类型的数，但是没法表达，就用 NaN (NaN 是 Not a Number 非数，不是数，但是是数字类型例 var a = 1 / 0; //是 infinity例 var a = -1 / 0; //是-infinity(无穷) %，（摩尔，模，是取余数的意思）12345678例 var a =5%2 //5%2 是五除二的余数，商二余一例 var a =5%1 //是五除一的余数，结果是 0例 var num = 1 % 5; //意思是 1 除以 5 的余数。商 0 余 1例 var a =4%6 //是四除六的余数，结果是 4例 var a = 4;a % = 5;document.write(a); // 4例 var a = 0;a % = 5;document.write(a); //0例 var a = 10;a %= 2;document.write(a); //0例 var a = 3;a % = 4; //4 优先级”=“最弱【赋值符号优先级最低】，”()”优先级较高 “++”，“- -”，”+=“，“-=”，“/=“，“*=”，“%=”++（加加）123456789101112131415161718192021例 var a = 10; a = a + 1; //结果 11例 var a = 1;a = a + 1;写成 a ++是一种简化形式 “++”，是自身加一，再赋值给自身a ++ 是 a = a + 1 的简化形式例 var a =10；document.write(++a );document.write(a); //答案 11；11是先执行++，再执行本条语句 document.write(++a)例 var a =1；document.write(a ++);document.write(a); //答案 1；2。是先执行语句(document.write(a))，再++，所以第一次打印的还是 a，第二次打印 a++后的值例 var a =10；var b=++a -1+a++;document.write(b + “ ” + a) //答案 21 12先++a，这个时候 a=11，再-1，再加 a，b 就是 21，最后++，a 就是 12赋值的顺序自右向左，计算的顺序自左向右（按数学来）例 var a =1；var b = a ++ + 1；document.write(b)； //答案 2，先执行 var b =a+1，再 a++例 var a =1；var b = a ++ + 1；document.write(a)；document.write(b)； //答案 2，2例 var a =1；var b = ++a + 1；document.write(a)；document.write(b)； //答案 2，3例 var i = 1;var a = i++; //答案 a = 1; 此时 i 先将值 1 赋给 a,然后自己+1，i=2;var b = ++i; //答案 b = 3；此时 i 先自己+1 为 3.再给 b 赋值，b=3; –（减减）“--”，是自身减一，在赋值给自身 123456例 var a = 1;var b = a-- + -- a;document.write(b); //答案 0，先执行--a;此时 a 变成0，然后第一个 a 也变成 0，那么 b = 0-- + --a例 var a = 1;var b = --a + --a;document.write(b); //答案-1例 var a = 1;document.write(a++);document.write(a); //答案 1；2例 var a = 1;document.write(++a);document.write(a); //答案 2；2例 var a =1; var b = a ++ +1;document.write(b); //答案 2 a 写在后面就后运行，先计算 a+1=2 赋值给 b 后再++ 1例 var a = 1;var b = ++a + 1;document.write(a);document.write(b); //答案 2；3 += ， -=（加等于、减等于）1234例 var a =10;a ++;a ++;a ++;加十个 简化写法：a +=10;也是 a = a+10;例 var a =10;a += 10 + 1; //答案 21例 var a = 1;a = a + 10;等于 a+=10a++是 a +=1 的写法 /=（除等于）12例: var a = 10;a /= 2; //答案 5，是除二赋给自身的意思 *=（乘等于）1例 var a =10;a *=2; //答案：20，是乘二赋给自身的意思 %=（模等于）1234例 var a=10;a%=2; //答案：0， 10 能整除 2,余数是 0,取余，余数赋给自身。例 var a=3;a%=4; //答案：3，3 除以 4，余数为 3，余数赋给自身。例 var a=0;a%=4; //答案：0，0 除以 4，余数为 0，余数赋给自身。例 var a = 1;a% =10; //答案：1，1 除以 10，余数为 1，余数赋给自身。 作业： 1234567891011121314151、写出打印结果 var a =(10 * 3 – 4 / 2 + 1)%2,b=3;b %= a + 3; document.write(a++); document.wtite(“&lt;br&gt;”); document.write(--b);2、var a =123; var b =234;经过计算交换 a，b 的值作业答案1、 document.write(a++);是 1（先打出 1 再++） document.write(--b);是 2 b % =a + 3,的模等于 4，除不开再赋值给 b，b 还是 32、 方法一普通方法：var c = a; a = b; b = c;document.write(a ,b); 方法二 a = a + b; b = a – b; a = a – b; document.write(a ,b); 二、比较运算符 “&gt;”，”&lt;”，”==”，“&gt;=”，“&lt;=”，”!=”比较结果为 boolean 值 但凡是运算符，都是要有运算的 用到布尔值，true 或 false 字符串的比较，比的是 ASCII 码（七位二进制 0000000） &gt;， &lt;（大于、小于）123456789例 var a = \"a\"&gt;\"b\";document.write(a); //答案是 false例 var a = 1 &gt; 2;document.write(a); //答案是 false例 var a = 1 &lt; 2;document.write(a); //答案是 true例 var a = \"1\"&gt;\"8\";document.write(a); //答案是 false例 var a = \"10\"&gt;\"8\";document.write(a); //答案 false，不是十和八比，是字符串一零和八比，先用开头的一和八比，比不过就不看第二位了；一样的就拿零和八比例: var a = 123;document.write(a); //答案 false 运算结果为真实的值 ==，等于12345例 var a = 1 == 2; //答案是说 1 等不等于 2，因为 1 肯定不等于 2，所以值为 false例 var a = NaN == NaN; //答案是 false，NaN 不等于任何东西，包括他自己例 var a = undefined == underfined; //答案是 true例 var a = infinity == infinity; //答案是 true例 var a = NaN == NaN; //答案是 false。非数 NaN 是不等于自己的 NaN 得不出数，又是数字类型，就是 NaN &gt;=、&lt;=、!=（大于等于、小于等于、非等于）1比较结果为 boolean 值：true 和 false 三、逻辑运算符：“&amp;&amp;”，“||”，“!“运算结果为真实的值“&amp;&amp;”与运算符（与、并且） 两个表达式：先看第一个表达式转换成布尔值的结果是否为真，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，然后如果只有两个表达式的话，只看看第二个表达式，就可以返回该表达式的值了，如果第一位布尔值为 false，不看后面的，返回第一个表达式的值就可以了 运算符就是要求结果 12345678例 var a = 1 &amp;&amp; 2; //答案 2，如果第一位 1 为真，结果就为第二位的值 2例 var a = 1 &amp;&amp; 2 + 2; //答案 4，如果 1 为真，结果就为 4例 var a = 0 &amp;&amp; 2 + 2; //答案 0例 var a = 1 &amp;&amp; 1 &amp;&amp; 8; //答案 8，先看第一个是否为真，为真再看第二个，中途如果遇到 false，那就返回 false 的值例 var a =1 + 1 &amp;&amp; 1 – 1;document.write(a); //答案 0 如果是三个或多个表达式，会先看第一个表达式是否为真，如果为真，就看第二个表达式，如果第二个也为真，就看第三个表达式（如果为真就往后看，一旦遇到假就返回到假的值），如果第三个是最后一个表达式，那就直接返回第三个的结果 如果第一个是假，就返回第一个值，当是真的时候就往后走，一旦遇到假，就返回被认定为 false(假) 的值：转换为布尔值会被认定为 false 的值 undefined， null， NaN， “”（空串）， 0， false 1234567 2&gt;1 &amp;&amp; document.write(‘成哥很帅’) //意思是如果 2 大于 1，那么就打印成哥很帅，如果前面真才能执行后面的（相当于短路语句使用） &amp;&amp;与 运算符是有中断作用的，当短路语句使用(如果。。那么。。)var data = ...; //执行一个语句，会用到 data data&amp;&amp;执行一个语句全用到 datadata &amp;&amp; function(data); &amp;与运算 我们一般不用123例 var num = 1 &amp; 2;document.write(num); //答案 0例 var num = 1 &amp; 1;document.write(num); //答案 1例 var num = 1 &amp; 3;document.write(num); //答案 1 上下一与，不同为 0，相同为 1 在二进制中，是 1（为了对齐补的 0） 0 1 在二进制中，是 11 1 1 运算结果 0 1 “||”或运算符（或者）123例 var num = 1 || 3; //答案 1例 var num = 0 || 3; //答案 3例 var num = 0 || false; //答案是 false 看第一个表达式是否为真，如果为真，则返回第一个值，碰到真就返回 如果第一个表达式是假，就看第二个表达式，如果第二个是最后一个，就返回第二个的值 关注真假的说法：全假才为假，有一个真就为真 1234567891011例 var num = 0 || false || 1; document.write(num); //答案 1例: div .onclick = function(e)&#123; 非 IE 浏览器直接取 e 值 var event = e; IE 浏览器存在 window.event; &#125; 写成下面这样就解决了兼容性。在所有的浏览器中都好使 div .onclick = function(e)&#123;var event = e || window.event;&#125; “!“非运算符，否的意思先转成布尔值，再取反 1234例 var a = !123; document.write(a); //答案 false。123 的布尔值是 true，取反是 false例 var a = !\"\"; document.write(a); //答案 true。空串””布尔值是 false，取反是 true例 var a = !!\"\"; document.write(a); //答案 false，取反后，再反过来，结果不变例 var a = true; a =!a; document.write(a) //答案 false，自身取反，再赋值给自身 !=（非等于）是表达它们不等于 被认定为 false 的值：转换为布尔值会被认定为 false 的值 undefined， null， NaN，&quot;&quot;（空串）， 0， false , （逗号）操作符123456 var a = (1 - 1, 1 + 1); 答案：2；，逗号 是一个运算符，由于有 括号() 的加持，所以先执行 (，逗号运算符)逗号 操作符的意思是先看前面的表达式，如果前面的表达式需要‘计算’的话，可以先计算，然后在计算后面的表达式(如果后面的表达式用计算的话)，都计算完之后，把后面的表达式计算结果返回回去。 条件语句一、If 语句 if、if else if if &lt;—&gt; &amp;&amp; 转换if(条件判断){ 当条件成立时，执行里面的执行语句 } 当 if() 中的条件成立时，才能执行{}内的语句 当条件转化为布尔值，如果为 true 就执行；如果为 false 就不执行 || 放在 if 中是或者的意思，有一个是真就可以了12例 if(1 &lt; 2)&#123;document.write(“老邓很丑”);&#125;例 if ( 1 &gt; 0 &amp;&amp; 8 &gt; 9)&#123;&#125; &amp;&amp;放在 if 中的，全真才为真，&amp;&amp;是并且的意思1例 if ( 1 &gt; 0 || 8 &gt; 9)&#123;&#125; if 和&amp;&amp;的互相转化123456789101112131415161718192021222324252627282930``````html&lt;!-- 90一100 alibaba 80一90 tencent toutiao meituan 滴滴 70一80 baidu eleme xiecheng 58赶集 60一70 蘑菇街 60以下 你肯定不是我教的!!! --&gt;&lt;script type=\"text/javascript\"&gt; var score = parseInt(window.prompt(\"input\")); if (score &gt; 90 &amp;&amp; score &lt;= 100) &#123; document.write(\"alibaba\"); &#125; if (score &gt; 80 &amp;&amp; score &lt;= 90) &#123; document.write(\"tencent\"); &#125; if (score &gt; 70 &amp;&amp; score &lt;= 80) &#123; document.write(\"baidu\"); &#125; if (score &gt; 60 &amp;&amp; score &lt;= 70) &#123; document.write(\"mogujie\"); &#125; if (score &lt; 60) &#123; document.write(\"Oh my god!!! \"); &#125;&lt;/script&gt; 不能写 (90 &lt; score &lt; 100),这样写会先比 90 &lt; score,等于 true 以后再跟 100 比 else if 满足了第一条就不看第二条了，用 else if 要满足条件与条件之间互斥，不能有交叉点。除了上面所有以外的。else if 除了这个以外，满足第一个就不看了，不满足就看后面的 1234567891011121314151617181920&lt;!-- else if 除了这以外在看这个满不满足。满足条件后就不看了，上面的写法不够简洁 下面 是 上面这个条件的补集 --&gt;&lt;script type=\"text/javascript\"&gt; var score = parseInt(window.prompt(\"input\")); if (score &gt; 90 &amp;&amp; score &lt;= 100) &#123; document.write(\"alibaba\"); &#125; else if (score &gt; 80 &amp;&amp; score &lt;= 90) &#123; document.write(\"tencent\"); &#125; else if (score &gt; 70 &amp;&amp; score &lt;= 80) &#123; document.write(\"baidu\"); &#125; else if (score &gt; 60 &amp;&amp; score &lt;= 70) &#123; document.write(\"mogujie\"); &#125; else if (score &lt; 60) &#123; document.write(\"Oh my god!!! \"); &#125;&lt;/script&gt; &amp;&amp;和 || 比较常用在条件判断中12345if(1 &gt; 2)&#123; document.write('a');&#125;上面与右边效果完全一样 1 &gt; 2 &amp;&amp; document.write('a'); 二、for 循环(for 循环不固定，非常灵活) 格式 for (var i = 0; i &lt; 10; i++) { } for 是关键字，（）括号里面三个语句用两个分号隔开，{}里面是循环体 1234567891011121314// 打印十个 a，写成：for (var i = 0; i &lt; 10; i++) &#123; document.write(\"a\"); document.write(\"a\"); document.write(\"a\"); document.write(\"a\"); document.write(\"a\"); document.write(\"a\"); document.write(\"a\"); document.write(\"a\"); document.write(\"a\"); document.write(\"a\");&#125; 执行顺序如下 1234567891011121314151617181) var i = 0;2) if(i &lt; 10)&#123; document.write(‘a’)&#125;// 把条件判断放到 if 里面,条件判断成立，就执行&#123;&#125;中间的执行体3) i ++// 看 i++，此时 i 变成 1，i = 1；4) if(i &lt; 10)&#123; document.write(‘a’)&#125;// 把条件判断放到 if 里面,条件判断成立，就执行&#123;&#125;中间的执行体5) i ++// 看 i++，此时 i 变成 1，i=1；——————如此反复 1234先执行一遍(1)，判断(2)执行语句成不成立，条件成立就执行(3),判断(2)执行语句成不成立，条件成立就执行(3),......当有一次判断不成立，就停止 因为看的是执行顺序，写外面也可以，执行顺序是一样，打印十个 a，也可以写成： 12345var i = 0;for (; i &lt; 10; ) &#123; document.write(\"a\"); i++;&#125; 123456789101112131415161718192021// 打印十个 a 也可以写成:// 1.var i = 1;var cout = 0;for (; i; ) &#123; document.write(\"a\"); count++; if (count == 0) &#123; i = 0; &#125;&#125;// 2.var i = 1;for (; i; ) &#123; document.write(\"a\"); i++; if (i == 11) &#123; i = 0; &#125;&#125; 12345// 例:打印 0-9:for (var i = 0; i &lt; 10; i++) &#123; document.write(i);&#125; 1234567// 求 0-9 的和var count = 0;for (var i = 0; i &lt; 10; i++) &#123; count += i; document.write(count + \" \");&#125; 123456789// 打印 100 以内能被 3 整除，或者能被 5 整除，或者能被 7 整除的数：var i = 1;var count = 0;for (i = 0; i &lt; 10; i++) &#123; if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) &#123; document.write(\"i\" + \" \"); &#125;&#125; 123456// 用 for 循环打印一百个数var count = 0;for (var i = 0; i &lt; 100; i++) &#123; document.write(i + \" \");&#125; 1234567// for 循环中的三句只能写一句，打印 100 个数：var i = 1;for (; i &lt; 100; ) &#123; document.write(i + \" \"); i++;&#125; 123456// for 循环中的函数体里面只能写一句，打印 100 个数：var i = 100;for (; i--; ) &#123; document.write(i + \" \");&#125; 三、while, do whilewhile 循环while 循环是 for 循环的简化版 for( ； ； ){}，while 循环底层机制是 for 循环。 for ( ; 只在这一部分写，前后不写 ; ){} 123456789101112var i = 0;for (i = 0; i &lt; 10; i++) &#123; document.write(i + \" \");&#125;上下这两个完全相等;var i = 0;while (i &lt; 10) &#123; document.write(i + \" \"); i++;&#125; 123456// 死循环 never-ending loop 无限循环while (1) &#123; document.write(i); i++;&#125; 123456789// 例打印一百以内，7 的倍数就输出var i = 0;while (i &lt;= 100) &#123; if (i % 7 == 0) &#123; document.write(\"i\" + \" \"); &#125; i++;&#125; 123456789// 例打印一百以内，7 的倍数或逢 7 就输出var i = 0;while (i &lt;= 100) &#123; if (i % 7 == 0 || i % 7 == 0) &#123; document.write(i + \" \"); &#125; i++;&#125; do while 循环do while 是不管满不满足条件都会先执行一次，再判断成不成立，如果成立才会执行 第二次，不成立就停止, 一般没人用 1234do &#123; document.write(\"a\"); i++;&#125; while (i &lt; 10); 作业 （先找规律，再写出来） 提示：var n = parseIn(window.prompt(‘input’)); JS 可以进行浮点计算 计算 2 的 n 次幂，n 可输入，n 为自然数。 计算 n 的阶乘，n 可输入。即 5！=54321，最好写个 if 著名的斐波那契额数列(这个数列从第 3 项开始，每一项都等于前两项之和) 1 1 2 3 5 8 输出第 n 项 编写一程序，输入一个三位数的正整数，输出时反向输出。如：输入 456,输出 654 输入 a,b,c 三个数字，打印出最大的。 打印出 100 以内的质数（从 1 除到他本身，只能有两个因数） 作业答案1、原有结果 * 2,mul 是存上一个数的结果 12345678&lt;script type=\"text/javascript\"&gt; var n = parseInt(window.promt(\"input\")); var mul = 1; for(i = 0;i &lt; n;i ++)&#123; mul *= 2; &#125; document.write(\"mul\");&lt;/script&gt; 2、计算 n 的阶乘，n 可输入。即 5！=54321，最好写个 if 12345678&lt;script type=\"text/javascript\"&gt; var n = parseInt(window.promt(\"input\")); var mul = 1; for(i = 1;i &lt;= n; i ++)&#123; mul *= i; &#125; document.write(mul);&lt;/script&gt; 3、斐不那契数列 第六位是四次运算，第七位是五次运算（第三位=第一位+第二位） 第一次计算的完整过程是把第一位和第二位相加，等于第三位，并且把游标向后挪 一位。下面 for（里面的 i 是控制循环圈数的） 12345678910111213141516&lt;script type=\"text/javascript\"&gt; var n = parseInt(window.prompt(\"input\")); var first = 1; second = 1; third; if(n &gt; 2)&#123; for(var i = 0; i &lt; n - 2; i ++)&#123; third = first + second; forst = second; second = third; &#125; document.write(third); &#125;else&#123; document.write(1); &#125;&lt;/script&gt; 4、取模除减。先把 456 提出出来，再反过来。6 是取模除减%10 余 6。再用 456 减 6， 剩下 450；450%100 是 50，50 除以 10，取出 5，450-50 剩下 400；400%100，再反着乘一遍，十位乘以 10，百位乘以 100。（中间的位数其实可以不动） 5、输入 a,b,c 三个数字，打印出最大的。 1234567891011121314151617var a = parseInt(window.prompt(\"input\"));var b = parseInt(window.promot(\"input\"));var c = pars0eInt(window.prompt(\"input\"));if (a &gt; b) &#123; if (a &gt; c) &#123; document.write(a); &#125; else &#123; document.write(c); &#125;&#125; else &#123; if (b &gt; c) &#123; document.write(b); &#125; else &#123; document, write(c); &#125;&#125; 6、有一个判断质数的算法,看看每一个 i 是不是质数,从自身开始除一直除到 1，只能被自己和 1 整除，只能整除 2 次 12345678910111213var count = 0;for (var i = 1; i &lt; 100; i++) &#123; // 看一看每一个 i 是否是质数 for (j = 1; j &lt;= i; i++) &#123; if (i % j == 0) &#123; count++; &#125; &#125; if (count == 2) &#123; document.write(i + \" \"); &#125; count = 0;&#125; 以下是最简单的方法：从 1 到 10 能整除，除平方数以下的 12345678910111213var count = 0;for (var i = 1; i &lt; 100; i++) &#123; // 看一看每一个 i 是否是质数 for (j = 1; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; count++; &#125; &#125; if (count == 1) &#123; document.write(i + \" \"); &#125; count = 0;&#125; 条件语句补充一、switch case 条件判断语句1234567if(条件判断)switch(条件)&#123; case 写条件：里面判是否相符： 如果相符合就执行 case 后面的语句比如 console.log(‘a’)&#125; switch 不负责任，如果判断了 a 是符合条件的，也会把后面的连带打印出来 加个 break，就可以终止语句 123456789101112&lt;script type=\"text/javascript\"&gt; var n = 2; switch(n)&#123; case \"a\": console.log(\"a\"); case 2: condole.log(\"b\"); case true: condole.log(\"c\"); &#125;&lt;/script&gt; switch 找到满足要求的语句后，后面的语句虽然不判断了，但是也会执行出来 加个 break，就可以终止 swich case 语句 12345678910111213141516&lt;script type=\"text/javascript\"&gt; var n = 2; switch(n)&#123; case \"a\": console.log(\"a\"); break; case 2: condole.log(\"b\"); break; case true: condole.log(\"c\"); break; &#125;&lt;/script&gt; 例 if( score == 90){}else if ( score == 100){} 12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; var date = window.prompt(\"input\"); switch(date)&#123; case \"monday\": console.log(\"working\"); break; case \"tuesday\": console.log(\"working\"); break; case \"wednesday\": console.log(\"working\"); break; case \"thursday\": console.log(\"working\"); break; case \"friday\": console.log(\"working\"); break; case \"周六\": condole.log(\"relaxing\"); break; case \"周日\": condole.log(\"relaxing\"); break; &#125;&lt;/script&gt; 简化写法: 1234567891011121314151617&lt;script type=\"text/javascript\"&gt; var date = window.prompt(\"input\"); switch(date)&#123; case \"monday\": case \"tuesday\": case \"wednesday\": case \"thursday\": case \"friday\": console.log(\"working\"); break; case \"周六\": case \"周日\": condole.log(\"relaxing\"); break; &#125;&lt;/script&gt; 二、break 的标准定义是终止循环，break 必须要放在循环里面，switch, for,while 都是循环12345678910var i = 0;while(1)&#123; i ++; console.log(i); if(i &gt; 100)&#123; break; &#125;&#125; break 终止的是 while，对 if 没有影响 1234567891011从 0 开始加，加到 100 以上就停止var i = 0;var sum = 0;for(var i = 0; i &lt; 100; i++)&#123; sum += i; console.log(i); if(sum &gt; 100)&#123; break; &#125;&#125; 三、continue 继续、终止本次循环，来进行下一次循环终止本次循环，后面的都不执行了，来进行下一次的循环 js 里面是没有 goto 的，c 语言里面有 12345678例:当 i 是 7 的倍数，或尾数是 7 的时候，不打印for ( var i = 0; i &lt; 100; i++)&#123; if( i % 7 == 0 || i % 10 == 7)&#123; &#125;else&#123; console.log(i); &#125;&#125; 下面写法更好 123456例: for (var i = 0; i &lt; 100; i++) &#123; if (i % 7 == 0 || i % 10 == 7) &#123; continue; &#125; console.log(i);&#125; 初识引用值一、数组（下面方括号的），arr =也是数组123456例var arr = [1,2,3,4,5,6,7,”abc”,undefined];arr [0] 代表查数组的第一位，因为数字是从 0 开始的算的arr [0] = 3; 是指把数组的第一位改成 3，显示 3,2,3,4,5,6,7, ”abc”,undefinedarr.length;是数组的长度，有多少位就有多少console.log(arr.length); //答案是 8 位 1.利用 for 循环把数组中的每一位都拿出来——遍历 12345var arr = [1, 2, 3, 45, 5, 7, \"abc\", undefined];for (var i = 0; i &lt; arr.letter; i++) &#123; console.log(arr[i]);&#125; 2.把数组中的每一位都改成 1 12345var arr = [1, 2, 3, 45, 5, 7, \"abc\", undefined];for (var i = 0; i &lt; arr.length; i++) &#123; arr[i] = 1;&#125; 3.把数组中的每一位都加 1 12345var arr = [1, 2, 3, 4, , 5, 9, 10];for (var i = 0; i &lt; arr.length; i++) &#123; arr[i] += 1;&#125; 二、对象 object 面向对象的编程方法 1234var obj = &#123; 里面存属性和方法 key 属性名：value 属性值;&#125; 在{}面用。属性与属性之间用逗号隔开 属性值可以双引号或单引号；属性名是为了方便找到他，只是一个辅助 12345678910111213 var deng = &#123; lastName : \"Deng\", age : 40, sex : undefined, wife : \"xiaoliu\", father : \"dengdaye\", son : \"xiaodeng\", handsome :false &#125; console.log(deng.lastName); //取值方式 deng.lastName赋值 deng.lastName = “old deng”; console.log(deng.lastName); 编程形式的区别面向过程，如 c (第一步干嘛，第二步干嘛) 面向对象（对象 object） （现在 js 是一半面向过程，一半面向对象，前面学的都是面向过程）`` typeof 操作符 typeof 能返回的六种数据类型（区分数字类型） number、string、boolean、undefined、object、function 1例 var num = 123;console.log(typeof(num)); //返回 number 写成 console.log(typeof num );也可以,不过最好加括号 12345例 var num = &#123;&#125;; console.log(typeof(num)); //泛泛的引入值都返回 object例 var num = [];console.log(typeof(num)); //泛泛的引入值都返回 object例 var num = null;console.log(typeof(num)); //答案 null 返回 object，最早是代替空对象的例 var num = undefined;console.log(typeof(num)); //答案返回 undefined例 var num = fuction()&#123;&#125;;console.log(typeof(num)); // 答案返回 function 类型转换123456例 var num = 1 +“1”; //显示 11例 var num = 1 *“1”;console.log(typeof(num) + “:” + num); //显示 number:1例 var num = 1 -“1”;console.log(typeof(num) + “:” + num); //显示 number:0例 var num = “2” -“1”;console.log(typeof(num) + “:” + num); //显示 number:1例 var num = “2” *“1”;console.log(typeof(num) + “:” + num); //显示 number:2 以上例子说明 js 有类型转换 一、显示类型转换Number(mix) 是想把里面的东西转换成数字123456789101112131415161718192021222324252627282930313233343536373839404142434445例: var num = Number(‘123’); console.log(typeof(num) + “:” + num); 答案显示 Number:123，把字符串类型的 123 转换成了 number 类型例: var demo = “123”; var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:123，上面那一行的 Number 是为了把()里面转换成数字类型例: var demo = true; var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:1例: var demo = false; var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:0例: var demo = null; var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:0例: var demo = undefined; var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:NaN例: var demo = “abc”; var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:NaN例: var demo = “-123”; var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:-123例: var demo = “123abc”; var num = Number(demo); console.log(typeof(num) + “:” + num); 答案显示 Number:NaN parseInt(string,radix) parse 是转化，Int 是整型，整数，目的是把里面转换成整数 12345678910111213141516171819202122232425例: var demo =”123”; var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number:123例: var demo = true; var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: NaN例: var demo = false; var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: NaN例: var demo = 123.9; var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: 123，此处是直接去掉小数，不是四舍五入例: var demo = “10”; var num = parseInt(demo ,16); console.log(typeof(num) + “:” + num); 答案显示 number: 16 var num = parseInt(demo ,radix); //radix 是基底的意思 radix 写成 16，系统会认为是以 16 进制为基底， 10（一零）是 16 进制的一零，是以 16 进制为基底，把他转成为 10 进制的数字（就是 16），上面是以目标进制为基底，转换成十进制（radix 范围是 2-36） 1234567891011121314151617181920例 var demo = “3”; var num = parseInt(demo ,2); console.log(typeof(num) + “:” + num); 答案显示 number: NaN例 var demo = “b”; var num = parseInt(demo ,16); console.log(typeof(num) + “:” + num); 答案显示 number: 11例 var demo = “123abc”; var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: 123例 var demo = “100px”; var num = parseInt(demo); console.log(typeof(num) + “:” + num); 答案显示 number: 100 parseInt 从数字类开始看，看到非数字类为止，返回原来的数 parseFloat(string) parseFloat(string)转换成浮点数字，就是正常小数 123456789101112131415例: var demo = “100.2”; var num = parseFloat (demo); console.log(typeof(num) + “:” + num); 答案显示 number: 100.2例: var demo = “100.2.3”; var num = parseFloat (demo); console.log(typeof(num) + “:” + num); 答案显示 number: 100.2例: var demo = “100.2abc”; var num = parseFloat (demo); console.log(typeof(num) + “:” + num); 答案显示 number: 100.2 parseFloat 从数字类开始看，看到除了第一个点以外的非数字类为截止，返回前面的数 toString 把 谁 变成字符串类型 (以 10 为基底转换为目标进制)（undefined 和 null 不可以用 toString 方法）； 12345例 var demo = 123; var num = demo.toString(); console.log(typeof(num) + “:” + num); 答案显示 string: 123。相当于把 123 转换字符串。 想把谁转换成字符串，就写成谁.toString，上面是想把 demo 转换成 toString，写成 demo.toString 12345678910例: var demo = undefined; var num = demo.toString(); console.log(typeof(num) + “:” + num); 答案显示报错，undefined 和 null 不能用 toString例: var demo = 123; var num = demo.toString(8); console.log(typeof(num) + “:” + num); 答案 173，把 123 转成为八进制 这里的 radix 意思是以十进制为基底，转换成目标进制（即 8 进制） 123456789101112131415161718192021例: var demo = 10; var num = demo.toString(8); console.log(typeof(num) + “:” + num); 答案 12例: var demo = 20; var num = demo.toString(8); console.log(typeof(num) + “:” + num); 答案 24。以十进制为基底，把 20 转换成 8 进制，就是 24例: 给你一个二进制的数，转换成十六进制，是先从二进制到十进制再到十六进制 var num = 10101010; var test = parseInt(num, 2); console.log(test.toString(16)); 答案 aa例: var num = 10000; var test = parseInt(num, 2); console.log(test.toString(16)); 答案 10 String(mix) String(mix)转换成字符串，写什么都成了字符串 1234567891011例: var demo = 123.234; var num = String (demo); console.log(typeof(num) + “:” + num); 答案显示 string: 123.234例: var demo = undefined; var num = String (demo); console.log(typeof(num) + “:” + num); 答案显示 string: undefined Boolean() Boolean()转换成布尔值 false 和 true 12345例: var demo = “”; var num = String (demo); console.log(typeof(num) + “:” + num); 答案显示 boolean: false toFixed toFixed 就是保留小数点几位 12345var var num = 123.456789console.log(num.toFixed(3));效果：num = 123.457(四舍五入) 二、隐式类型转换 隐式类型转换是跟你转换了也不知道 隐式类型转换内部隐式调用的是显示的方法 隐式类型转换包括 isNaN () ，++，–， +/-（一元正负），+，*，% ，，&amp;&amp;，|| ，！，&lt;，&gt;，&lt;= ，&gt;= ，== ，!= isNaN (); isNaN ();当你把一个数放到()里，它能判断是不是 NaN，先比括号里面的放到 number 里面转换，然后返回来 123例 console.log(isNaN(NaN); //答案 true例 console.log(isNaN(“123”); //答案 false例 console.log(isNaN(“abc”); //答案 true。会调用 number，先把“abc” 放 number 里面转换，通过 number 的转换再和 NaN 比对，如果相等就是 true 12例 console.log(isNaN(null); //答案 false，在 number 里面放 null 是 0，不是 NaN例 console.log(isNaN(undefined); //答案 true ++/–（加加减减） +/-（一元正负） ++/–（加加减减） 12345678例: var a = “123”; a ++; 答案 124，++这个符号放到这里，还没运算之前，先把前面的 a 转换成 number 的 123例: var a = “abc”; a ++; 答案 NaN +/-（一元正负） +a;-a;正 a 和负 a 都会变换成数字 123例 var a =+”abc”;console.log(a + “:” + typeof(a));答案 NaN:number。 尽管转换不成数字，也会转换成数字类型，因为里面隐式的调用了一个 number + +隐式类型会转换成 string，当加号两侧有一个是字符串，就用调用 string，把两个都变成字符串 12例 var a = “a” +1console.log(a + “:” + typeof(a)); * , % *和% 乘和模都会转换成 number 123456例: var a = “1” *1; console.log(a + “:” + typeof(a)); 答案 1：number例: var a = “a” *1; console.log(a + “:” + typeof(a)); 答案 1：number，先是 number(“a”)的结果乘以 number(1)的结果，最后是 NaN*1，还是 NaN，但是数据类型是 number &amp;&amp; || ! 与或非，都是有类型转换的，不过是返回的是表达式的值，不是隐式类型转换的值，但是判断是一个类型转换的值 &lt; ， &gt; ， &lt;= ， &gt;=123456789例: var a =1 &gt; “2”; console.log(a + “:” + typeof(a)); 答案 false:boolean，有数字相比较的，就会隐士类型转换成数字类型例: var a =”3” &gt; “2”; console.log(a + “:” + typeof(a)); 答案这个没类型转换，这个比的是 ASCⅡ例: var a =”3” &gt; 2; console.log(a + “:” + typeof(a)); 答案 true：boolean 会转换成数字，因为数字优先 == ， ! ， =123456例: var a = 1 == “1”; console.log(a + “:” + typeof(a)); 答案 true:boolean，也有隐士类型转换例: var a = 1 == true; console.log(a + “:” + typeof(a)); 答案相等 ！= 也是这样特殊东西，在控制台操作 12345例: false &gt; true; //答案 false，会先转换成数字，0&gt;1 当然是错的例: 2 &gt; 1 &gt; 3; //答案 false例: 2 &gt; 3 &lt; 1; //答案 true例: 10 &gt; 100 &gt; 0; //答案 false例: 100 &gt; 10 &gt; 0; //答案 true 以上都是挨个算的，先看前面的是 true 还是 false，再和后面的比，不是顺着下来 12345678例: undefined &gt; 0; //答案 false例: undefined == 0; //答案 false例: undefined &lt; 0; //答案 false例: null &gt; 0; //答案 false例: null == 0; //答案 false例: null &lt; 0; //答案 false例: undefined == null; //答案 true例: NaN == NaN; //答案 false，NaN 是唯一一个连自己都不等于的 三、不发生类型转换===绝对等于（三个等号） !==绝对不等于1234567例 1 === 1 //答案 true例 1 === “1” //答案 false例 1 !== “1” //答案 true例 1 !== 1 //答案 false例 NaN =NaN //答案 false 特殊的例 console.log(a); //如果定量没定义就直接访问，就 a is not defined 报错； 有一种特殊情况，当且仅当把未定义的变量放到 console.log(typeof(a));里面就访问，不报错，返回 undefined 123例 console.log(typeof(a)); //答案 undefined，这个 undefined 是字符串例 console.log(typeof(typeof(a))); //答案 string。console.log(typeof(typeof(a))); 可以先解析成 console.log(typeof(“undefined”));再返回一次就是 string 字符串 上面考的是 typeof(a)返回的六种类型的值（number、string、boolean、undefined、object、function）都是 undefined 字符串 123456789101112131415161718192021作业例 alert(typeof(a)); //返回 string例 alert(typeof(undefined)); //返回 string，undefined例 alert(typeof(NaN)); //返回 number例 alert(typeof(null)); //返回 object例 var a = “123abc”; //返回 string例 alert(typeof(+a)); //返回 number，NaN例 alert(typeof(!!a)); //返回 boolean例 alert(typeof(a + “”)); //返回 string例 alert(1 == “1”); //显示 true例 alert(NaN == NaN); //显示 false例 alert(NaN == undefined); //显示 false例 alert( “11” + 11); //显示 1111例 alert( 1 === “1”); //显示 false例 alert(parseInt(“123abc”)); //显示 123【parseInt 是截断数字】例 typeof(typeof(a)); //返回 string例 var num = 123123.345789;alert(num.toFixed(3));答案 123123.346【toFixed(3)是保留三位小数的意思，四舍五入】提示：alert(‘a’);就是弹出框，相当于 console.log 函数 function function 随便起个名(){} 1234567891011121314151617181920212223242526例: if (1 &gt; 0) &#123; function test() &#123; document.write(\"a\"); document.write(\"a\"); document.write(\"b\"); document.write(\"b\"); document.write(\"c\"); document.write(\"c\"); &#125;&#125;if (2 &gt; 0) &#123; document.write(\"a\"); if (i &gt; 0) &#123; document.write(\"b\"); test(); document.write(\"c\"); &#125;&#125;if (2 &gt; 0) &#123; if (3 &gt; 0) &#123; test(); document.write(\"a\"); &#125; document.write(\"b\"); document.write(\"c\");&#125; 以上情况就是偶合，偶合度非常高，偶合代码就是低效代码 编程讲究高内聚，弱偶合 右上方是简便写法：可以用 test 调用执行，写几个 test 就调用执行几次 12345678910111213&lt;script type=\"text/javascript\"&gt; function test()&#123; var a = 123; var b = 234; var c = a + b; document.write(c); &#125; test()&lt;/script&gt;答案 357。写了一个 test（）；就执行了一遍函数语句，如果不写 test（）；就相当于有一个框来存东西，但是不执行 123456例: function test ()&#123; document.write(‘hello world’); &#125; test(); 函数 function 可以先定义功能，之后再去用 一、定义函数声明 定义一个函数可以先写一个 function,函数就是另一个类型的变量 我声明一个函数 test,test 是函数名。写成下面 123function test() &#123; 函数体;&#125; 函数名起名：开发规范要求，函数名和变量名如果由多个单词拼接，必须符合小驼峰原则（第一个单词首字母小写，后面的首字母大写） 1234例 function theFirstName()&#123;&#125;document.write(theFirstName);答案 function theFirstName()&#123;&#125;。打印出来的是函数体 这与 c 语言和 c++，他们打印指针，会输出指针的地址，而 js 这种弱数据语言（解释性语言）永远不输出地址，输出地址指向房间 函数表达式1234567例: var test = fuction test ()&#123; document.write(‘a’); &#125; test();答案 a。这种方式像定义一个变量 上面这种方式，可以演变成第三种，匿名表达式【不写 test 这种函数名】 命名函数表达式1234例 var demo = fuction abc()&#123;document.write(‘a’);&#125; 上面这个函数的函数名 name 是 abc 在控制台 console 直接输出 test 就会出现 → 在控制台 console 直接输出 abc 会报错，表达式就会忽略他的名字 abc。 在上面例子中，fuction abc(){document.write(‘a’);}这一部分叫表达式，是会忽略 abc 这个地方的名字，会变成匿名函数表达式，不如直接写成匿名函数 匿名函数表达式（常用，一般说的函数表达式就是匿名函数表达式）1function test() &#123;&#125; 二、组成形式函数名称function test(){}其中 function 是函数关键字，test 是函数名，必须有(){}，参数可有可没有，参数是写在()括号里面的。 如果写成 function test(a，b){}，相当于隐式的在函数里面 var a，var b 申明了两个变量，（）括号里面不能直接写 var 12345例 function test(a, b)&#123; document.write(a + b)&#125;test(1, 2)答案 3。 上面这个例子，1 就会到 a 里面去，2 就会到 b 里面去，这是传参的形式 参数(可有可没有，但是高级编程必有)形参（形式参数）：指的是 function sum（a，b）{}括号里面的 a 和 b 实参（实际参数）：指的是 sum（1，2）；里面的 1，2 天生不定参，形参可以比实参多，实参也可以比形参多 123456789 function sum(a,b)&#123; var c = a + b; document.write(c); &#125; sum(1,2); sum(3,4);答案 37，参数把函数抽象了，可以组成很多形式 12345678910111213141516171819202122232425262728293031323334例: 如果第一个实参的数大于 10，就减第二个数的运算结果；如果第一个实参的数小于 10，就加第二个数的运算结果 //function test()&#123;&#125; // 形式参数 ———— 形参 funtion sum(a,b)&#123; if(a &gt; 10)&#123; document.write(a - b); &#125;else if(a &lt; 10)&#123; document.write(a + b); &#125;else&#123; document.write(10); &#125; &#125; // 实际参数 ———— 实参 sum(1,2） 答案：3 上面改成sum(11,2) //答案 9 function sum(a,b)&#123; document.write(a); &#125; sum(11, 2, 3)答案 11 function test(a, b, c,d) &#123; document.write(a); document.write(d); &#125; sum(11, 2, 3)答案 11,undefined，上面这道题是形参多，实参少 js 参数不限制数量，天生不定参数 在每一个函数里面都有一个隐式的东西 arguments 这个是实参列表 12345678910111213141516例: function test(a) &#123; console.log(arguments); console.log(arguments.length); &#125; sum(11, 2, 3)答案[11, 2, 3]，3例: function test(a) &#123; for(var i = 0; i &lt; argument.length; i++)&#123; console.log(arguments[i]); &#125; &#125; sum(11, 2, 3)答案 11,2,3 1234567891011121314151617181920function sum(a,b,c,d)&#123; if(sum.length &gt;arguments.length)&#123; console.log(\"形参多了\") &#125;else if(sum.length &lt; arguments.length)&#123; console.log(\"实参多了\") &#125;else&#123; console.log(\"相等\") &#125;&#125;// 实际参数 ———— 实参sum(11,undefined.3,\"abc\") 形参长度求法 function sum(a, b, c, d) &#123; console.log(sum.length); &#125; sum(11, 2, 3) 答案 4 1234567891011121314例:任意个数求和(不定参才能求出来) funtion sum()&#123; // arguments [1,2,3,4,5,6,7]; var result = 0; for(var i = 0; i &lt; arguments.length;i ++)&#123; result += arguments[i]; &#125; console.log(result); &#125;sum(1,2,3,4,5,6,7,8,9); 形参永远有尽头，要实现任意的数求和，无法定义形参。 1234567891011121314151617181920 function sum(a,b)&#123; // arguments [1,2] // var a = 1; a = 2; console.log(arguments[0]); &#125;sum(1,2);答案是 2。a 变，arguments 跟着变化。有一个映射的关系。 function sum(a,b)&#123; // arguments [1,2] // var a = 1; a = 2; arguments[0] = 3; console.log(argument[0]); &#125; sum(1,2);答案 3。arguments 里面一个变，一个跟着变，但是[1,2]是两个独立的人，相当于映射关系。 123456789101112131415161718192021例:当形参两个，实参一个 function sum(a, b)&#123; //arguments[1]没值 b = 2; console.log(arguments[1]); &#125; sum(1);答案: undefined，实参列表出生时有几个，就有几个，在写 b=2，也不加在 arguments[1]里面了，此处的 b 就当变量用，他和实参不映射。形参实参完全对应上才相互映射例: function sum(a, b)&#123; //arguments[1]没值 a = 2; console.log(arguments[0]); &#125; sum(1);答案 2 返回值 return结束条件和返回值 return，return 有终止函数的功能 没写 return，实际上是加上了一个隐式的 return 123456789101112131415例: function sum(a, b)&#123; console.log(‘a’); console.log(‘b’); return; &#125; 答案 a，b例: function sum(a, b)&#123; console.log(‘a’); return; console.log(‘b’); &#125; 答案 a return 最常用的是返回值。本意是把一个值返回到函数以外 123456789101112131415161718自己定义的函数也能返回,return 空格 123例: function sum()&#123; return 123; console.log(‘a’); &#125; var num = sum(); 答案这里的 num 就是 123，而且 console.log(‘a’);无效，这里的 return 又终止函数，又返回变量例: 把 target 转成数字 function myNumber(target)&#123; return + target; //利用+隐式的转换成了数字类型 &#125; var num = myNumber(‘123’); console.log(typeof(num) + “” + num); 答案 number 123 一般函数处理完一个参数，是为了返回 typeof()也是返回值，也是函数 typeof(123)也可以写成 typeof 123【typeof 空格 123】，只是看起来不方便 练习 写一个函数，功能是告知你所选定的小动物的叫声。 写一个函数，实现加法计数器。 定义一组函数，输入数字，逆转并输出汉字形式。 写一个函数，实现 n 的阶乘。 写一个函数，实现斐波那契数列。 一、写一个函数，功能是告知你所选定的小动物的叫声。 12345678910111213function scream(animal) &#123; switch (animal) &#123; case \"dog\": document.write(\"wang\"); return; case \"cat\": document.write(\"miao!\"); return; case \"fish\": document.write(\"o~o~o~\"); return; &#125;&#125; 此处可以用 break , 也可以用 return 二、写一个函数，实现加法计数器。 12345678910111213任意个数求和(不定参才能求出来) funtion sum()&#123; // arguments [1,2,3,4,5,6,7]; var resule = 0; for(var i = 0; i &lt; arguments.length;i ++)&#123; result += arguments[i]; &#125; console.log(result); &#125; sum(1,2,3,4,5,6,7,8,9); 三、定义一组函数，输入数字，逆转并输出汉字形式。 1234567891011121314151617181920212223242526272829303132function reverse() &#123; var num = window.prompt(\"input\"); var str = \"\"; for (var i = num.length - 1; i &gt;= 0; i--) &#123; str += transfer(num[i]); &#125; document.write(str);&#125;reverse();function transfer(traget) &#123; switch (traget) &#123; case \"1\": return \"壹\"; case \"2\": return \"贰\"; case \"3\": return \"叁\"; case \"4\": return \"肆\"; case \"5\": return \"伍\"; case \"6\": return \"陆\"; case \"7\": return \"柒\"; case \"8\": return \"捌\"; case \"9\": return \"玖\"; &#125;&#125; 1234567891011属性补充：str.charAt(0)意思是字符串的第零位for(var i = num.length - 1; i &gt;= 0)这是倒着拿的意思一个字符串长度是 3，他的第三位字符串是 2可以把第二个 function 放第一个里面，但是一般单独写，因为 transfer 是转换str += transfer(num[i]);是先执行后面的 transfer(num[i])，再赋值给前面 递归写一个函数，实现 n 的阶乘。 12345678910111213方法一: function jc(n) &#123; //n 的阶乘 for (var i = 1; i &lt;= n; i++) &#123; num *= i; &#125;&#125;方法二: function mul(n) &#123; if (n == 1 || n == 0) &#123; return 1; &#125; return n * mul(n - 1);&#125; 方法二叫递归 1、找规律， 2、找出口（找停的点） 递归的优点是代码简洁，但是运行慢 12345导图: return 5 * mul(5 - 1);return (5 - 1) * mul(5 - 2);return 3 * mul(5 - 3);return (5 - 3) * mul(5 - 4);return 1; 5、拿递归写斐波那契数列 fb(n)==fb(n - 1) + fb(n - 2); 123456789101112function fb(n)&#123; if(n == 1 || n== 2)&#123; return 1; &#125; return fb(n - 1) + fb(n - 2);&#125;fb(5) == &gt; fb(4) + fb(3);fb(4) == &gt; fb(3) + fb(2);fb(3) == &gt; fb(2) + fb(1);fb(2) == &gt; fb(1) + fb(0);fb(1) == &gt; fb(1) + fb(0); 递归返回的顺序：先执行的最后被返回，最后执行完（等最底层的一层层返回） 立即执行函数 定义：此类函数没有声明，在一次执行过后即释放（被销毁）。适合做初始化工作。 123针对初始化功能的函数：只想让它执行一次的函数立即执行的函数也有参数，也有返回值，有预编译 123456789101112131415161718192021222324例: (function ()&#123; //写成(function abc()&#123;&#125;())也调用不到 var a = 123; var b = 234; console.log(a + b); &#125;())例: (function (a, b, c)&#123; console.log(a + b + c * 2); &#125;(1, 2, 3)) //这一行里面的(1,2,3)是实参例: var num = (function (a, b, c)&#123; var d = a + b + c * 2 – 2; return d; &#125;(1, 2, 3))答案 num = 7 立即执行函数的五种写法123标准写法:1. (function ()&#123;&#125;()); //在 W3C 建议使用这一种 123456789101112132. (function ()&#123;&#125;)();(function test()&#123;console.log(‘a’);&#125;)()这个被()包起来的 function 函数声明变表达式了，就能被外面的最后的()执行(function test()&#123; console.log(‘a’);&#125;())最外面的大括号是数学运算符号，是最先被执行，其余的括号都是有语法意义的，就把函数变表达式了()也是数学执行符，能打印 a，但是执行 test 就报错，所以干脆就不写 test 1234563. var num = function ()&#123;&#125;(); var num = function () &#123; console.log(\"a\"); &#125;(); 只有表达式才能被执行符号执行 能被执行符号执行的表达式，这个函数的名字就会被自动忽略（放弃名字） 能被执行符号执行的表达式基本上就是立即执行函数 函数声明和函数表达式是两个东西，虽然都能定义函数 函数声明：function test ( ){} 函数表达式：var test = function( ){} 其中 = function (){}把 function 赋到 num 里面去叫表达式，var num 是声明在执行时，会放弃这个函数储存到 test 里面的储存引用，让这个 test 恢复到被声明的状态 123456789101112134. +、-、！ function num()&#123;&#125;(); + function test()&#123; console.log('a'); &#125;() - function test()&#123; console.log('a'); &#125;() ! function test()&#123; console.log('a'); &#125;() 加了个”正”，在趋势上要把他转换成数字，就是表达式了，既然是表达式就能被执行，就会放弃名字，此时 console.log (test)，就会报错；这就是立即执行函数，同样放了正号，负号，！就会放弃函数名字，转换成表达式；但是*和/不行，&amp;&amp;||前面放东西也行 1234565. function test(a,b,c,d)&#123;console.log(a + b + c + d)&#125;(1,2,3,4);例: function test(a,b,c,d)&#123; console.log(a + b + c + d); &#125;(1, 2, 3, 4) 理论上坚决不能执行，如果括号里面没有数字的话,系统会认为这是一个执行符号，但是如果在里面写上数字，系统就不会给你当成执行符号，它会当成这样写： 12345例: function test(a,b,c,d)&#123; console.log(a + b + c + d); &#125; (1, 2, 3, 4); 这样就不会报错了，因为 逗号（,）也是一个运算符，它会后面的位返回。所以它也是一个正常语法。但是它也不会执行,也不会报错,test还是函数体。 要点:123456789101112131415161718192021222324例1.1:先定义一个 10 位数的数组，就是在 var arr = [function () &#123;console.log(i);&#125;有十个[]并且把数组返回function test ()&#123; //定义个函数 test var arr = []; //定义一个空数组 for (var i = 0; i &lt; 10; i ++)&#123; //丰满空数组，让空数组添加十条数组 // 每一条都是一个 function()&#123;&#125; arr[i] = function () &#123; //随着 for 循环 i 变， // 数组 i 也变，arr 每一次都等于一个全新的函数体 document.write(i + \" \"); &#125; &#125; return arr; //把 arr 返回到外部&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++)&#123; //分别执行十个函数体，函数体里面定义了 document.write myArr[j]();&#125;// 答案 10 10 10 10 10 10 10 10 10 10 第二个 for 是为了打印这个数组，麻烦写法 myArr0; myArr1; 。。。myArr9; 过程 for (var i = 0; i &lt; 10; i ++){}执行了十次，产生了十个彼此独立的函数。并且把这十个函数放在数组里面去，还把数组返回了，这十个函数和 test 一起产生了一个闭包。 既然是闭包，那么访问 test 里面的变量时，实际上访问的是同一套，而 test 产生了arr 和 i 变量（写在 for 循环里面的 i 变量），而这十个函数在外边要访问 i 变量，其实访问的是同一个 i。 什么时候访问的？在 test 执行完以后，在下面 for(j)访问的第一个 i=0，转到 9 的时候，i ++变 10 终止 for 循环，结束的时候 i=10，结束之后把return arr 返回，arr； 这十个函数都是为了打印 i 的，在外部访问 i 的时候 i=10，所以打印的是 10 123arr[i] = function () &#123; document.write( i + “ ”);&#125; 理解过程： 在这个函数体中，当arr[0]时document.write(i)的i是不变的，还是i，等函数保存到外部之后，等执行的时候，才会去找i的值。 这个赋值语句中arr[0] = 函数;把一个函数体或者说是一个函数引用赋给数组的当前位，数组的当前位需要马上被索取出来的（数组现在当前第几位，我们是知道的，因为这个是执行语句），当for(var i = 0)时，arr[i]会变成arr[0]但是这个 i 跟函数体里面的document.write(i + &quot; &quot;）里面的i是没有关系的，因为函数体 function(){}不是现在执行，不会在意函数里面写的是什么，不是现在执行那么里面的document.write不会变成现实的值，不是现在执行就是函数引用（函数引用就是被折叠起来的，系统不知道里面写的是什么） 在执行myArr[j]();的时候，系统才会读document.write(i + &quot;&quot;)里面的语句 在定义函数的时候是不看里面的，在执行的时候才看 要点2:123456789101112131415161718例1.2:我们让上面这个变成打印 0,1,2,3,4,5,6,7,8,9，用立即执行函数解决function test ()&#123; var arr = []; for (var i = 0; i &lt; 10; i ++)&#123; (function (j) &#123; arr[j] = function () &#123; document.write( j + “ ”); &#125; &#125;(i)); return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++)&#123; myArr[j]();&#125; 理解过程： 相当于在 for 循环里面有十个立即执行函数function(j){}在第一圈 i 是 0，j 也是 0，function(){document.write( j + “ ”)}拿着j=0进行循环的第二圈 i是 1，又有了一个新的 j 是 1，反复循环,形成了十个立即执行函数，有十个j对应 123456789101112例for(var i = 0; i &lt; 10; i ++)&#123; console.log(i);&#125;答案 0,1,2,3,4,5,6,7,8,9例for(var i = 0; i &lt; 10; i ++)&#123; (function()&#123;&#125;())&#125;中间 function 这个会执行 10 次 作用域初探 作用域定义：变量（变量作用于又称上下文）和函数生效（能被访问）的区域 全局、局部变量 作用域的访问顺序 作用域:函数里面的可以访问外面的全局变量 123456789101112131415var a = 123;// 全局变量function test()&#123; var b = 123; function demo()&#123; var c = 234; document.write(b); document.write(a); &#125; demo(); document.write(c);&#125;test(); 函数外面不能用函数里面的。里面的可以访问外面的，外面的不能访问里面的，彼此独立的区间不能相互访问 test{}和 demo{}不能互相访问，但是可以访问外面的全局变量 12345678910111213141516例:彼此独立的区间不能相互访问 全局变量都可以访问function test()&#123; var a = 123; function demo()&#123; var b = 234; document.write(a); &#125; demo(); document.write(b);上面的 document.write(b);不能访问 var b ;上面的 document.write(a);可以访问 a ;&#125; 外层函数不能访问里层的，里层的可以访问外层的，越往里权限越大 123456789作业:要求输入一串低于 10 位的数字，输入这串数字的中文大写。例如：input :10000 output:壹万 ;例如：input :1001010 output:壹佰万壹仟零壹拾 ;千分位如果是 0必须读零 ; js 运行三部曲(预编译) 语法分析 → 预编译 → 解释执行 预编译前奏1234567891011121314151617181920212223242526272829303132例:function test()&#123; console.log(‘a’);&#125;test();上面能执行例:test();function test()&#123; console.log(‘a’);&#125;也能执行，因为有预编译的存在例:var a = 123;console.log(a);答案 123例:console.log(a);var a = 123;答案 undefined例:只写 console.log(a);就会报错 函数声明整体提升：函数不管写到哪里，都会被提到逻辑的最前面。所以不管在哪里调用，本质上都是在后面调用变量 声明提升：把 var a 提升到最前面 var a = 123;这是变量声明再赋值。 变量声明提升是把他拆分成 var a; a = 123;然后把 var a 提升到最前面上面这两句话没办法解决下面例子(全部)的问题 123456例: function a(a) &#123; var a = 234; var a = function() &#123;&#125;; a();&#125;var a = 123; imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象(就是 window)所有。 全局对象是 window 例 window.a = 10; 例 a = 10; ===&gt; windows.a = 10; eg: var a = b = 123; 一切声明的全局变量，全是 window 的属性。 例 var a = 123; ===&gt; window.a = 123; window 就是全局的域 如果在全局变量在 var a = 123；那么就会返回到 window 例 var a = 123console.log(a) ===&gt; window.a 12345678910111213141516例var a = b = 234;是把 234 的值赋给 b，在把 b 的值赋给 a例 :function test()&#123; var a = b = 123; console.log(window.a); 答案：undefined; console.log(window.b); 答案：123；&#125;test()写 test()代表执行 test，赋值是自右向左的，上面先把 123 赋给 b 的时候，b 未经声明，然后再声明 a，再 b 的值赋给 a，导致 b 未经声明，所以 b 归 window 所有访问 window.a 是 undefined，访问 window.b 是 123 1234567891011121314151617181920212223242526例:function test()&#123; var b = 123;21&#125;test();console.log(window.b);答案 undefinedwindow 就是全局例:var a = 123;console.log(a); ==&gt; console.log(window.a);例:var a = 123;var b = 234;var c = 345;window&#123; a : 123, b : 234, c : 345&#125;如果 var a 对应会有 window.a,在window中也会有a = 123,b = 234,c = 345; 预编译（解决执行顺序问题）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172例 function fn(a)&#123; console.log(a); var a = 123; console.log(a); function a ()&#123;&#125; console.log(a); var b = function ()&#123;&#125; console.log(b); function d() &#123;&#125;&#125;fn(1);答案是 function a()&#123;&#125; 、123 、123 、function b()&#123;&#125;这个例子的形参是（a），变量声明也是 a上面的例子按四部曲变化如下:1.创建AO对象AO&#123;&#125;2. 找形参和变量声明，将变量和形参(a)名作为 AO 属性名，值为 undefinedAO&#123; a : undefined, b : undefined,&#125;3. 把实参值传到形参里AO&#123; a : 1, b : undefined,&#125;4. 在函数体里面找函数声明，值赋予函数体function a () &#123;&#125;和 function d () &#123;&#125;都是函数声明，但是 var b = function ()&#123;&#125;不是。AO&#123; a : function a () &#123;&#125;, b : undefined, d : function d () &#123;&#125;&#125;执行第一行 console.log(a);时，用的是AO&#123; a : function a () &#123;&#125;, b : undefined, d : function d () &#123;&#125;&#125;执行 var a =123;改变的是AO&#123; a : 123, b : undefined, d : function d () &#123;&#125;&#125;在 b = function ()&#123;&#125;时AO&#123; a : 123, b : function () &#123;&#125;, d : function d () &#123;&#125;&#125; 预编译发生在函数即将执行的前一刻 （函数）预编译的四部曲123456789101112131. 创建 AO 对象 Activation Object(执行期上下文，作用是函数解的作用域，函数产生的执行空间库)2. 找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefined,相当于AO&#123; a : undefined, b : undefined&#125;3. 将实参值和形参统一（把实参值传到形参里）4. 在函数体里面找函数声明，值赋予函数体（先看自己的 AO，再看全局的 GO） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162例:function test (a, b)&#123; console.log(a); c = 0; var c; a = 3; b = 2; console.log(b); function b ()&#123;&#125;; function d ()&#123;&#125;; console.log(b);&#125;test(1);答题过程：找形参和变量声明，将变量和形参名作为 AO 属性名，值为 undefinedAO&#123; a : 1, b : undefined, c : undefined&#125;函数声明 function b()&#123;&#125;和 function d()&#123;&#125;，AO&#123; a : 1, b : function b()&#123;&#125;, c : undefined, d : function d()&#123;&#125;&#125;执行 console.log(a);答案是 1执行 c = 0;变AO&#123; a : 1, b : function b()&#123;&#125;, c : 0, d : function d()&#123;&#125;&#125;var c 不用管，因为 c 已经在 AO 里面了执行 a = 3;改AO&#123; a : 3, b : function b()&#123;&#125;, c : 0, d : function d()&#123;&#125;&#125;执行 b = 2;改AO&#123; a : 3, b : 2, c : 0, d : function d()&#123;&#125;&#125;执行 console.log(b);答案是 2function b () &#123;&#125;和 function d()&#123;&#125;已经提过了，不用管执行 console.log(b);答案是 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970例:function test(a , b)&#123; console.log(a); // function a()&#123;&#125; console.log(b); // undefined var b = 234; console.log(b); // 234 a = 123; console.log(a); // 123 function a ()&#123;&#125; var a; b = 234; var b = function()&#123;&#125; console.log(a); // 123 console.log(b); // function b()&#123;&#125;&#125;test(1);答题过程：1. 将变量和形参名作为 AO 属性名AO&#123; a : undefined, b : undefined&#125;2. 将实参值和形参统一AO&#123; a : 1, b : undefined&#125;3. 找函数声明 function a ()&#123;&#125;AO&#123; a : function a ()&#123;&#125;, b : undefined&#125;执行 console.log(a);答案是 function a ()&#123;&#125;执行 console.log(b);答案是 undefined执行 var b = 234;变AO&#123; a : function a ()&#123;&#125;, b : 234&#125;执行 console.log(b);答案是 234执行 a = 123;变AO&#123; a : 123, b : 234&#125;执行 console.log(a);答案是 123然后 function a ()&#123;&#125;;var a ;都可以不看了执行 b = 234，b 值还是 234，不变执行 var b = function ()&#123;&#125;，变AO&#123; a : 123, b : function ()&#123;&#125;&#125;执行 console.log(a);答案是 123执行 console.log(b);答案是 function ()&#123;&#125; 一旦有重名的，一但有 a 变量又有 a 函数【如 function a (){}】，又在第一条访问的是 a，一定是函数答题过程： 将变 123456789101112下面开始讲全局的预编译例: console.log(a); var a = 123;答案 undefined;例: console.log(a); var a = 123; function a ()&#123;&#125;答案是打印 a 是 function a ()&#123;&#125; 全局的预编译三部曲 生成了一个 GO 的对象 Global Object（window 就是 GO） 找形参和变量声明，将变量和形参名作为 GO 属性名，值为 undefined 在函数体里面找函数声明，值赋予函数体 1234567891011121314151617181920例:console.log(a);var a = 123;console.log(a);function a ()&#123;&#125;答案过程:1. GO&#123; a : undefined&#125;2. 函数声明 GO&#123; a : function a ()&#123;&#125;&#125;3. 执行 var a = 123;变 GO&#123; a : 123&#125;执行 console.log(a);就是 123 GO === window， GO 和 window 是一个东西 console.log(a);和 console.log(window.a);和 console.log(go.a);是一样 任何全局变量都是 window 上的属性 , 没有声明变量就赋值了，归 window 所有，就是在 GO 里面预编译 123456789101112131415例:function test()&#123; var a = b =123; console.log(window.b);&#125;test();答案 window.a 是 undefined，window.b 是 123先生成 GO&#123; b : 123&#125;再有 AO&#123;a : undefined&#125; 先生成 GO 还是 AO 想执行全局，先生成 GO，在执行 test 的前一刻生成 AO 在几层嵌套关系，近的优先，从近的到远的，有 AO 就看 AO，AO 没有再看 GO 123456789101112131415161718192021222324252627282930313233343536373839例:console.log(test);function test(test)&#123; console.log(test); var test = 234; console.log(test); function test()&#123; &#125;&#125;test(1);var test = 123;答题过程:1. 想执行全局,先有 GO,GO&#123; test : undefined&#125;2. 发现有函数声明 GO&#123; test : function ()&#123;..... &#125;&#125;执行 console.log(test),1. 执行 test(1)之前生成AO&#123; test : function ()&#123;&#125; &#125;2. 执行 var test = 234;变成AO&#123; test : 234; &#125; AO 上面有就用 AO 的，没有就看 GO 的 12345678910111213141516171819202122232425262728例:var global = 100;function fn()&#123; console.log(global);&#125;fn();答题过程GO&#123; global : undefined, fn : function()&#123;.....&#125; &#125;执行 var global = 100;变GO&#123; global : 100, fn : function()&#123;.....&#125;&#125;不看 function fn()&#123;...&#125;里面的东西执行 fn()之前AO&#123; 访问 GO的 global&#125; 123456789101112131415161718192021222324252627282930313233global = 100;function fn()&#123; console.log(global); global = 200; console.log(global); var global = 300&#125;fn();var global;答题过程:GO&#123; global : undefined fn : undefined(没用可以不写)&#125;变:GO&#123; global : 100, fn : undefined &#125;执行 fn()之前，AO&#123; global : undefined&#125;执行结果是 undefined，200 123456789101112131415161718192021222324252627282930313233343536373839404142function test()&#123; console.log(b); //undefined if(a)&#123; var b = 100; &#125; console.log(b); //undefined c = 234; console.log(c); //234&#125;var a;test();a = 10;console.log(c); //234过程GO&#123; a : undefined, test:undefined&#125;AO&#123; b : undefined //不管 if(a)&#123;&#125;，可以提出 var b的&#125;执行到 c=234，GO&#123; a : undefined, c : 234, test:undefined&#125;执行到 a=10，GO&#123; a : 10 c : 234 test:function test()&#123;&#125;&#125; 123456789101112例:function bar()&#123; return foo; foo = 10; function foo()&#123;&#125; var foo = 11;&#125;console.log(bar());答案：function foo()&#123;&#125;如果在第一行 return foo，下面有 foo 这个函数，一定打印这个函数; 1234567891011121314例:console.log(bar());function bar()&#123; foo = 10; function foo()&#123;&#125; var foo = 11; return foo;&#125;答案 11例:console.log(b);var b = function ()&#123;&#125;答案是 undefined // 因为var b = undefined 是函数表示，不是函数声明; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788例:现在因为语法的改变 在 if 里面定义函数声明 function 是不允许的，但是过去可以，下面就是过去的旧题，可以按着来做一下a = 100;function demo(e)&#123; function e()&#123;&#125; arguments[0] = 2; document.write(e); if(a)&#123; var b = 123; function c()&#123; //...... &#125; &#125; var c; a = 10; var a; document.write(b); f = 123; document.write(c); document.write(a);&#125;var a;demo(1);document.write(a);document.write(f);GO&#123; a : undefined demo : function ()&#123;&#125;&#125;开始执行 a=100，GO&#123; a : 100， demo : function ()&#123;&#125;&#125;AO&#123; e : undefined, b : undefined, c : undefined, a : undefined&#125;形参实参相统一，AO&#123; e : 1, b : undefined, c : undefined, a : undefined&#125;赋值 AO&#123; e : function e ()&#123;&#125;, b : undefined, c : undefined, //------旧规则里面可以提出 function()&#123;&#125; a : undefined&#125;执行 arguments[0] = 2;实参列表和传参是否相映射，变AO&#123; e : 2, b : undefined, c : undefined, a : undefined&#125;执行 console.log(e);答案 2if(a)由于 a 在 AO 里面是 undefined，所以不运行执行 a = 10;变AO&#123; e : 2, b : undefined, c : undefined, a : 10&#125;执行 console.log(b)，答案 undefined执行 f = 123，变GO&#123; a : 100, demo : function ()&#123;&#125;, f : 123&#125;执行 console.log(c); 之前打印 function()&#123;&#125;，改语法后打印 undefined执行 console.log(a); 答案 10执行 console.log(a); 因为在外面是全局的，答案 100执行 console.log(f); 答案 123 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501. var str = false + 1; document.write(str);2. var demo = false == 1; document.write(demo);3. if(typeof(a) &amp;&amp; -true + (-undefined) + \"\")&#123; document.write('基础扎实') &#125;4. if(11 + \"11\" * 2 == 33)&#123; document.write(\"基础扎实\") &#125;5. ！！\" \" + !!\"\" - !!false || document.write(\"你觉得可以打印，你就是猪\")答题:1. false+1 因为有+，两边都不是字符串，就转换成数字,0 + 1 = 1// 12. false 是 0 ，false false == 1，false 肯定不等于 1，所以把 false 再赋给 demo// false3.(1) typeof(a) 是 \"undefined\" ;(2) -true 转换成数字是-1; +undefined 显示“NaN” -1 + NaN = NaN -1 + NaN + \"\" = \"NaN\"//\"undefined\" &amp;&amp; \"NaN\" 转换成 boolean，就都是 true//因为两边都是字符串，所以是true;4. “11”* 2 是*把两边转换成了数字，所以 11 +“11”* 2 =33，33 == 33// 两边相等5.(1) !! 非非 就是 正 \" \" 这不是空串，是空格字符串 !!\" \"转换成 Boolean 为 true(2) !!\"\"非非空串，转换为 Boolean 为 false(3) !!false 就是 false(4) true + false - false = 1 + 0 – 0 = 1(5) 1 || document.write(‘你觉得能打印？’)// || 运算符 遇到真就停，1 为真，所以返回 1 1234567891011121314151617例:(window.foo || (window.foo = ‘bar’));求 window.foo答案”bar”这道题要先看(window.foo = ‘bar’)这一边的，再看左边的 window.foo因为运算符的顺序问题，让这道题错误的读法（从左到右）也是 bar，所以怎样读，都是正确答案 : bar(window.foo || window.foo = ‘bar’);这么写就报错;// 因为 ||或 运算符优先级高于 =等号 运算符 , 而 ()括号 运算符 则大于一切运算符所以，必须要写成：(window.foo || (window.foo = \"bar\")); 作用域精解[[scope]]:每个 javascript 函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供 javascript 引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域,其中存储了运行期上下文的集合。 作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。 运行期上下文:当函数在执行的前一刻，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。 查找变量：在哪个函数里面查找变量，就从哪个函数作用域链的顶端依次向下查找。函数类对象，我们能访问 test.name test.[[scope]]隐式属性——作用域 1234567例:function test ()&#123; …………&#125;第一次执行 test(); → AO&#123;&#125; //AO 是用完就不要的第二次执行 test(); → AO&#123;&#125; //这是另外的 AO 12345678910111213function a ()&#123; function b ()&#123; var bb = 234; aa = 0; &#125; var aa = 123; b(); console.log(aa);&#125;var global = 100;a();270 是最顶端，1 是次顶端，查找顺序是从最顶端往下查 执行顺序： 123456789101112131415161. a 函数被定义时，发生了以下过程 | Global Object | / ——————————————————————————— a scope chain / | this | window |———————— —————————————/ ———————————————————————————[[scope]] 0 | | window | (object) | ——————————————————————————— | document | (object) | ——————————————————————————— | a | (function) | ——————————————————————————— | global | 100 | ——————————————————————————— | | | ——————————————————————————— 123456789101112131415161718192021222324252. a 函数被执行时，发生了以下过程 | Activation Object | / ——————————————————————————— a scope chain / | this | window |———————— —————————————/ ———————————————————————————[[scope]] 0 | | arguments | [] | ————————————— ——————————————————————————— 1 | | a | 123 | ————————————\\ ——————————————————————————— \\ | b | (function) | \\ ——————————————————————————— \\ \\ | Global Object | ——————————————————————————— | this | window | ——————————————————————————— | window | (object) | ——————————————————————————— | document | (object) | ——————————————————————————— | a | (function) | ——————————————————————————— | global | 100 | ——————————————————————————— 12345678910111213141516171819202122232425263. b 函数被创建的时候，发生了以下的过程 | Activation Object | / ——————————————————————————— b scope chain / | this | window |———————— —————————————/ ———————————————————————————[[scope]] 0 | | arguments | [] | ————————————— ——————————————————————————— 1 | | a | 123 | ————————————\\ ——————————————————————————— \\ | b | (function) | \\ ——————————————————————————— \\ \\ | Global Object | ——————————————————————————— | this | window | ——————————————————————————— | window | (object) | ——————————————————————————— | document | (object) | ——————————————————————————— | a | (function) | ——————————————————————————— | global | 100 | ——————————————————————————— 123456789101112131415161718192021222324252627282930313233343536374. b 函数被执行的时候，发生了以下的过程 | Activation Object | / ——————————————————————————— / | this | window | / ——————————————————————————— / | arguments | [] | / ——————————————————————————— b scope chain / | b | 234 |———————— —————————————/ ———————————————————————————[[scope]] 0 | | | | ————————————— ——————————————————————————— 1 | \\ ————————————— \\ 2 | \\ | Activation Object | / \\ ——————————————————————————— / \\ | this | window | / \\ ——————————————————————————— / \\ | arguments | [] | / \\——————————————————————————— / | a | 123 | / ——————————————————————————— / | b | (function) | / ——————————————————————————— / | Global Object | ——————————————————————————— | this | window | ——————————————————————————— | window | (object) | ——————————————————————————— | document | (object) | ——————————————————————————— | a | (function) | ——————————————————————————— | global | 100 | ——————————————————————————— 1234567891011121314 function a()&#123; function b()&#123; var bb = 234; aa = 0; &#125; var aa = 123; b(); console.log(a); &#125; var global = 100; a();答案：0; 理解过程：bb 的 AO 是拿到 aa 的 AO，就是同一个 AO，bb 只是引用了 aa 的 AO，GO 也都是同一个。function b(){}执行完，干掉的是 b 自己的 AO（销毁执行期上下文）（去掉连接线），下次 function b 被执行时，产生的是新的 b 的 AO。b 执行完只会销毁自己的 AO，不会销毁 a 的 AO。function a(){}执行完，会把 a 自己的 AO 销毁【会把 function b 也销毁】，只剩 GO（回归到 a 被定义的时候），等下次 function a再次被执行时，会产生一个全新的 AO，里面有一个新的 b 函数。。。。。。周而复始 123456789101112131415161718192021222324252627282930313233343536373839function a() &#123; function b() &#123; funcion c() &#123;&#125; c(); &#125; b();&#125;a();理解过程：a 被定义 a.[[scope]] → 0 : GO&#123;&#125;a 被执行 a.[[scope]] → 0 : a.AO&#123;&#125; 1 : GO&#123;&#125;b 被定义 b.[[scope]] → 0 : a.AO&#123;&#125; 1 : GO&#123;&#125;b 被执行 b.[[scope]] → 0 : b.AO&#123;&#125; 1 : aAO&#123;&#125; 2 : GO&#123;&#125;c 被定义 c.[[scope]] → 0 : b.AO&#123;&#125; 1 : aAO&#123;&#125; 2 : GO&#123;&#125;c 被执行 c.[[scope]] → 0 : c.AO&#123;&#125; 1 : b.AO&#123;&#125; 2 : a.AO&#123;&#125; 3 : GO&#123;&#125;当 c 执行完后，会干掉自己的 cAO，回到 c 被定义的状态，当 c 再被执行时，会生成一个新的 newcAO&#123;&#125;，其余都一样，因为基础都是 c 的被定义状态 c 被执行c.[[scope]] → 0 : newc.AO&#123;&#125; 1 : b.AO&#123;&#125; 2 : a.AO&#123;&#125; 3 : GO&#123;&#125; 如果function a不被执行，下面的function b和function c都是看不到的（也不会被执行，被折叠）。只有function a被执行，才能执行function a 里面的内容a(); 如果不执行，根本看不到function a (){}`里面的内容; 闭包 当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄露。 内存泄漏就是内存占用，内存被占用的越多，内存就变得越来越少了，就像内存被泄露了一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344 function a()&#123; function b()&#123; var bbb = 234; console.log(aaa); &#125; var aaa = 123; return b; &#125; var global = 100; demo = a(); demo();return b 以后，就返回出去，再销毁 fn a。答案：123;。因为没有 b();此时 b 还是被定义的状态，和 a 执行的状态是一样的。function a()&#123;&#125;是在 return b 之后才执行完，才销毁。return b 让 a 执行时的 AO 被保存到了外面。 a执行 | Activation Object | / ——————————————————————————— a scope chain / | this | window |———————— —————————————/ ———————————————————————————[[scope]] 0 | / | arguments | [] | ————————————— ——————————————————————————— 1 | | aaa | 123 | —————————\\——— / ——————————————————————————— \\ / | b | (function) | \\ / ——————————————————————————— \\/ /\\ / \\ | Global Object | / \\ /——————————————————————————— b被定义，并被保存出来. / \\ / | this | window | / \\/ ——————————————————————————— / /\\ | window | (object) | b scope chain / \\ ———————————————————————————————————— ————————————— / | document | (object) |[[scope]] 0 | / ——————————————————————————— ————————————— / | a | (function) | 1 | / ——————————————————————————— ————————————— | global | 100 | ——————————————————————————— | demo | (function) | ——————————————————————————— return b是把b（包括 a 的 AO保存到外部了（放在全局）当 a 执行完砍掉自己的AO时，b 依然可以访问到a的AO(因为 return b) 但凡是内部的函数被保存到外部，一定生成闭包 1234567891011121314151617181920212223例: function a()&#123; var = 100; function b()&#123; num ++; console.log(num); &#125; return b; &#125; var demo = a(); demo(); demo();答案 101,102理解过程: a 被执行 0 : a.AO: num = 100; 1 : GO: demo = a(); b 被执行 0 : b.AO : 1 : a.AO : num = 100; 2 : GO: demo = a(); 在第一次执行function b时，num ++就把aAO变成{num : 101}，当 function b执行完毕时，剪断的是bAO，而aAO不变，当执行function a的return b时就把aAO,GO都存在了外部，执行完a销毁scope时去掉 a的连接线，但是因为return b把aAO,GO存在了外部，所以依然还是可以访问值 在第二次执行function b时，aAO{num : 101}，在num ++就是102` 123456789101112131415161718192021222324252627 function a()&#123; var aa = 345; function b()&#123; var bb = 234; function c()&#123; cc = 123; &#125; c(); &#125; b(); &#125; a();执行过程：先执行 function a()&#123; var aa = 345;function b ()&#123;&#125;b();&#125;想要执行完上面的 b();就需要执行完 function b()&#123;var bb = 234; function c()&#123;&#125;c();&#125;，想要执行 c();就要先执行完 function c()&#123;var cc =123;&#125;,b();是一个复合语句，执行完 b 里面的每一句话，才能执行 b();销毁顺序：哪个先被执行完，哪个先被销毁当 c 执行完，先销毁 c 自己的执行期的上下文，当 c();执行完，那么 b 也执行完了，就销毁 b 的执行期上下文；当 b();执行完，那么 a 也执行完了，就销毁 a 的执行期上下文 闭包的作用一、实现公有变量123456789101112131415161718函数累加器： function add()&#123; var count = 0; function demo()&#123; count ++; console.log(count); &#125; return demo; &#125; var counter = add(); counter(); counter(); counter(); counter(); counter();每回调用 counter 就会在原有基础上加一次 二、可以做缓存（存储结构） eg:eater。缓存是外部不可见的，但是确实有存储结构 12345678910111213141516171819202122232425262728293031323334例1： fnction test()&#123; var num = 100; function a()&#123; num ++; console.log(num); &#125; function ()&#123; num --; console.log(num); &#125; return [a,b]; &#125; myArr = test(); myArr[0](); myArr[1]();答案 101 和 100，思考过程：说明两个用的是一个 AOtest doing test[[scope]] 0 : test.AO 1 : GOa defined a.[[scope]] 0 : test.AO 1 : GOb defined b.[[scope]] 0 : test.AO 1 : GO当执行 myArr[1]();时:b doing b.[[scope]] 0 : b.AO 1 : *a 运行后的 test.AO* 2 : GOa 运行后的 test.AO， 与 a doing 里面的 test.AO 一模一样a 和 b 连线的都是 test 环境，对应的一个闭包 function a和function b是并列的，不过因为function a在前，所以先执行num ++，在执行num -- myArr[0]是数组第一位的意思，即a，myArr[0]();就是执行函数a的意思; myArr[1]是数组第二位的意思，即b，myArr[1](); 就是执行函数b的意思; 1234567891011121314151617181920例2: function eater()&#123; var food = \"\"; var obj = &#123; eat : function()&#123; console.log('I am eating' + food); food = \"\"; &#125;, push : function(myFood)&#123; food = myFood; &#125; &#125; return obj; &#125; var eater1 = eater(); eater1.push('banner'); eater1.eat();答案: I am eating banana，eat 和 push 操作的是同一个 food; 在function eater(){里面的 food}就相当于一个隐式存储的机构obj对象里面是可以有function方法的,也可以有属性，方法就是函数的表现形式 三、可以实现封装，属性私有化例为什么在外部执行的 divorce 能用内部的变量？能换成 xiaozhang 因为 this.divorce 在对象上，由于对象被返回了，这个方法也被返回了。 因为闭包。这个函数被储存到了外部，所以储存了这个函数的执行期上下文。 所以可以用这个闭包。所以 var prepareWife 被下面的 this=fn 三个函数共用，这三个函数分别与 fn Deng 形成了闭包，共同用 Deng 的 AO,所以可以在外部随意存取。 1234567891011121314151617181920212223242526272829303132333435例: function Deng(name,wife)&#123; var prepareWife = 'xiaozhang'; this.name = name; this.wife = wife; this.divorce = function ()&#123; this.wife = prepareWife; &#125; this.changePrepareWife = funtion(target)&#123; prepareWife = target; &#125; this.sayPrapreWife = function()&#123; console.log(prepareWife); &#125; &#125; var deng = new Deng('Deng','xiaoliu'); // 从控制器输出: // &gt; deng // &lt;· Deng // &gt; changePrepareWife(target) // &gt; divorce:() // name : \"deng\" // &gt; sayPrapreWife:() // wife : 'xiaoliu' // &gt; __proto__ : Object // &gt; deng.divorce() // &lt;· undefined // &gt; deng.wife // &lt;· 'xiaozhang' // &gt; deng.prepareWife // &lt;· undefined deng.prepareWife 是 undefined 的，表面上看起来不是自己的，但是实际上只有对象自己通过对象自己设置的方法可以去操作他，外部用户通过对象，prepareWife 是看不到的，只有自己能看到，就是闭包的私有化运用。 12345678910111213141516例: var inherit = (function() &#123; var F = function() &#123;&#125;; return function(Target, Origin) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype; &#125;;&#125;)();// 执行完是这个样子var inherit = function(Target, Origin) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype;&#125;; 上面的 var F 这个 F 形成了闭包，成为了这个函数的私有化变量，而且变成私有化变量就更好 四、模块化开发，防止污染全局变量闭包的防范 闭包会导致多个执行函数共用一个公有变量，如果不是特殊需要，应尽量防止这种情况发生。 对象，包装类对象1.用已学的知识点，描述一下你心目中的对象1234567891011121314151617181920212223242526272829303132333435363738394041424344例: var mrDeng = &#123; name : 'MrDeng', age : 40, sex : 'male', health : 100, smoke : function ()&#123; console.log('I am smoking ! cool !!! '); mrDeng.health --; &#125; dring : function ()&#123; console.log('I am drink'); mrDeng.health ++; &#125; &#125; // 在控制台返回 // &gt; mrDeng.health // &lt;· 100 // &gt; mrDeng.drink() // I am drink // &lt;· undefined // &gt; mrDeng.drink() // I am dring // &lt;· undefined // &gt; mrDeng.health // &lt;· 102 // &gt; mrDeng.smoke() // I am smiking ! cool !!! // &lt;· undefined // &gt; mrDeng.health // &lt;· 99 // &gt; mrDeng.dring() // I am dring // &lt;· undefined 灰色的 undefined 是返回值，因为没有设置返回值，所以就是灰色的 undefined 代表函数引用 改 mrDeng.health 为 this.health，此处 this 指代的是自己，是第一人称，指的就是 mrDeng。因为 this 是在一个方法里面，所以指的这个方法。 12345smoke : function ()&#123; console.log(‘I am good’) this.health --;&#125;, 2.属性的增、删、改、查123456789例在上面的基础上 mrDeng.wife = 'xiaoliu'也可以在控制台操作=''等号后面的引号里面需要有值才可以删除必须借助 delete mrDeng.sex 增加一个属性给一个对象增加属性和方法，就直接给一个对象添加，如下: （对象.属性名 = 属性值） 如 ： mrDeng.wife = ‘xiaoliu’ 例 ：mrDeng.wife = &quot;xiaoliu&quot; 查看一个属性 对象名.属性名 修改一个属性 直接在对象名外面或控制器里面写 （对象名.属性名 = “属性值”） 12345例: var mrDeng = &#123; sex: \"male\"&#125;;mrDeng.sex = \"female\"; 删除一个属性删除一个属性，需要添加一个属性‘delete’, delete 对象名.属性名 这样就会删除对应的属性 123456789例: var mrDeng = &#123; sex: \"male\", health: 100, fring: function() &#123; console.log(\"I am dring\"); &#125;&#125;;delete mrDeng.sex; 3.对象的创建方法1. var obj = {} 对象字面量 / 对象直接量 plainObject2. 构造函数 系统自带的构造函数 Object() new Object(); Array(); Number(); Boolean(); Date();一、系统自带的构造函数 Object()可以批量生成对象，每一个对象都一样，但是彼此相互独立。 123在 Object()前面加个 new，变成 new Object()的执行，就会真正的返回一个对象，通过 return 返回，拿变量接受。var obj = new Object();var obj = new Object();和 var obj = &#123;&#125;;这样写区别不大 1234例: var obj = new Object(); obj.name = ‘abc’; obj.sex = “male”; 双引号和单引号都是表示的字符串，写双引号也可以写单引号，但是为了跟后端 php 配合最好写单引号。如果要打印一个单个的引号，用正则表达式转义字符/* \\&#39; */注意 等号 和 冒号 的用法 obj.say = function(){} var obj = { name : &#39;abc&#39;} 二、自定义 Object.create(原型)方法 123456789例: function Person()&#123;&#125; Person 是可以随便写的，也是构造函数 构造函数跟函数结构上没有任何区别例: var person1 = new person(); 必须用 new 这个操作符，才能构造出对象 构造函数必须要按照大驼峰式命名规则，但凡是构造函数就要大写，例如 TheFirNa 12345678910111213141516171819202122232425function Car()&#123; this.name = 'BMW'; this.height = '1400'; this.lang = '4900'; this.weight = 1000; this.health = 100; this.run = function ()&#123; this.health --; &#125;&#125;var car = new Car();var car1 = new Car();car.name = 'Maserati';car1.name = 'Merz';// 在控制台输出时。显示// &gt; car// &lt;· Car &#123;name : 'Maserati',height : '1400',lang : '4900',weight : 1000&#125;// &gt; car1// &lt;· Car &#123;name : 'Merz',height : '1400',lang : '4900',weight : 1000&#125; car1 和 car 是长得一样，但是是不同的两个 car。方法名和对象名尽量不一样 a 和 A 变量是两个变量，var car = new Car 里面 car 和 Car 是两个变量 12345678910111213141516例: function Car(color) &#123; this.color = color; this.name = \"BMW\"; this.height = \"1400\"; this.lang = \"4900\"; this.weight = 1000; this.health = 100; this.run = function() &#123; this.health--; &#125;;&#125;var car = new Car(\"red\");var car1 = new Car(\"green\");// 第一行的 color 可以和上面的参数重复，通过参数，使参数发生变化，变成自定义 12345678例: function Student(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; this.grade = 2017;&#125;var student = new Student(\"zhangsan\", 18, \"male\"); 构造函数内部原理 前提必须要加 new，以下三步都是隐式的： 在函数体最前面隐式的加上 var this = {} 空对象 执行 this.xxx = xxx; 隐式的返回 return this 1234567891011121314例: function Student(name, age, sex) &#123; // var this&#123; // name : \"\"; // age : \"\"; // &#125;; this.name = name; this.age = age; this.sex = sex; this.grade = 2017; //return this;&#125;var student = new Student(\"zhangsan\", 18, \"male\"); 123456789101112例: function Person(name, height)&#123; //隐式的 var this = &#123;&#125;，下面正常执行 this this.name = name; this.height = height; this.say = funtion ()&#123; console.log(this.say); //此处的 this 和外面的 this 不同 &#125; // 隐式的 return this; &#125; console.log(new Person(‘xiaowang’, 180).name); 12345678例;// 也可以这样显式的写出来function Person(name, height) &#123; var that = &#123;&#125;; //显式写出来 that.name = name; that.height = height; return that; //显式写出来&#125; 123456789101112131415161718192021222324例: function Person(name, height) &#123; // var this = &#123;&#125; this.name = name; this.height = height; this.say = function() &#123; console.log(this.say); &#125;; return 123; // return this;&#125;var person = new Person(\"xiaowang\", 180);var person1 = new Person(\"xiaozhang\", 175);// 在控制台输出时。显示// &gt; person// &lt;· Person&#123;name : 'xiaowang',height : 180&#125;// &gt; person1// &lt;· Person&#123;name : 'xiaozhang',height : 175&#125;// 答案现在的 peson 和 person1 都是 Object&#123;&#125;// 如果 return 写成 return 123，会使 return 失效，如上 有 new 了以后就不能返回原始值，例如 123 包装类new String(); new Boolean(); new Number(); 123var num =123; → 原始值数字只有原始值数字是原始值，原始值不能有属性和方法 属性和方法只有对象有，包括对象自己，数组，function 12345678910111213141516171819202122232425例: var num = new Number(123); // 在控制台输出。显示 // &gt; num // &lt;· Number&#123;[[PrimitiveValue]]:123&#125; // &gt; num.abc = 'a' // &lt;· 'a' // &gt; num.abc // &lt;· 'a' // &gt; num // &lt;· Number&#123;abc:'a',[[primitiveValue]]:123&#125; var num = new Number(123); ——&gt; 构造函数。是对象123，不是原始数字 // &gt; num // &lt;· Number&#123;[[PrimitiveValue]]:123&#125; // &gt; num * 2 // &lt;· 246 数字的对象如果参与运算，就会变回原始值，但如果不参与运算，加属性和方法，又可以当对象用，字符串 和Boolean类型完全一致。 字符串类型的对象 var num = new Nunber(123); 数字类型对象 var str = new String(‘abcd’); 字符串类型对象 var bol = new Boolean(‘true’); 布尔类型对象 12345678// &gt; num// &lt;· Number&#123;[[PrimitiveValue]]:123&#125;// &gt; str// &lt;· String&#123;[[PrimitiveValue]]:abcd&#125;// &gt; Boolean// &lt;· Boolean&#123;[[PrimitiveValue]]:true&#125; undefined 和 null 不可以有属性 不能写成 undefined.abc = 123;会报错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546例: 原始值不可能有属性和方法，但经过了包装类(加隐式)可以调用一些属性与方法 var num = 4； num.len = 3; //系统隐式的加上 new Number(4).len = 3; 然后 delete console.log(num.len); //系统隐式的加上 new Number(4).len; 但是这个 new Number 和上面的 new Number不是同一个，所以返回 undefined 而上面这些隐式的过程就是包装类例: var str = 'abcd'; str.length = 2; //隐式的加上 new string(‘abcd’).length = 2; 然后delete console.log(str); console.log(str.length); 答案是 abcd，4例: var str = 'abc'; str += 1; var test = typeof(str); if(test.length == 6)&#123; test.sign = 'typeof的返回结果可能是 Strings'; &#125; console.log(test.sign);理解过程: str += 1; //abc1 var test = typeof(str); //test == “string”，返回 string，string 长度是 6 if(test.length == 6)&#123; test.sign = “typeof 的返回结果可能为 String”; //这是原始值,原始值要赋属性值需要调用包装类，赋了跟没赋值是一样的，new String(test).sign=’xxx’; &#125; conlogo.log(test.sign); //new String(test).sign 答案 undefined 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181例题1: // 分析一下javasript代码段 function emproyee(name,code)&#123; this.name = 'wangli'; this.code = 'Aoo1'; &#125; var newemp = new emproyee('zhangming',A002); document.write('雇员姓名' + newemp.name + '&lt;br&gt;'); document.write('雇员代号' + newemmp.code + '&lt;br&gt;'); // 输出结果是（） // A. 雇员姓名：wangli 雇员代号 A001 // B. 雇员姓名：zhangming 雇员代号 A002 // C. 雇员姓名：null 雇员代号 null // D. 输出错误，无输出结果 答案 A，里面并没有用参数，被写死了，传参不成功例题2: function Person(name,age,sex)&#123; var a = 0; this.name = name; this.age = age; this.sex = sex; function sss()&#123; a ++; document.write(a); &#125; this.say = sss; &#125; var oPerson = new Person(); oPerson.say(); oPerson.say(); var oPerson1 = new Person(); oPerson1.say(); // 答案 ：1，2，1例题3: var x = 1,y = z = 0; function add(n)&#123; return n = n + 1; &#125; y = add(x); function add(n)&#123; return n = n + 3; &#125; z = add(x); // x y z // 答案: 1, 4, 4例题4: // 下面代码中 console.log 的结果是[1,2,3,4,5]的选项是 // A. function foo(x)&#123; console.log(arguments); return x; &#125; foo(1,2,3,4,5) // B. function foo(x)&#123; console.log(aruments); return x; &#125;(1,2,3,4,5) // C (function foo(x)&#123; console.log(arguments); return x; &#125;)(1,2,3,4,5); // D function foo()&#123;bar.apply(null,arguments)&#125; function bar(x)&#123;console.log(arguments)&#125; foo(1,2,3,4,5) // 答案: ACD例题5: // 请问一下表达式的结果是什么？ parseInt(3,8); parseInt(3,2); parseInt(3,0); 答案:3,NaN，3(有的浏览器遇到 0进制 是报 ssNaN)例题6: // 一下那些是 javascript 语言 typeof 可能返回的结果 A.string B. array C.object D.null 答案: A、C例题7: // 看看下面 alert 的结果是什么？ function b (x, y, a) &#123; arguments[2] = 10; alert( a ); &#125; b(1, 2, 3); // 如果函数体改成下面，结果又会是什么？ a = 10； alert(arguments[ 2 ]); 答案 10，10例题8: 写一个方法，求一个字符串的字节长度。(提示：字符串有一个方法 charCodeAt(); 一个中文占两个字节，一个英文占一个字节。) 定义和用法: charCodeAt(); 方法可返回指定位置的字符的 Uncode 编码，这个返回值是0 - 65535 之间的整数。(当返回值是 &lt;=255时为英文，当返回值 &gt;255时为中文) 语法: stringObject.charCodeAt(index) eg: &lt;script type = 'javascrip/text'&gt; var str = \"Hello word\" document.write(str.charCodeAt(1)) //输出101 var str = 'hello world 邓哥身体好'; str.charCoeAt(0); // 输出 104 var str = 'hello world 邓哥身体好'; for(var i = 0;i &lt; str.length; i ++)&#123; console.log(str.charCodeAt(i)); &#125; &lt;/script&gt; 解题 方式1: var str = '1111111111111'; function bytesLength(str)&#123; var count = 0; for(var i = 0;i &lt; str.length; i++)&#123; if(str.charCodeAt(i) &gt; 255)&#123; count += 2; &#125;else&#123; count ++; &#125; &#125; return count; // 闭包 &#125; var Str = bytesLength(str); //Str 接受闭包 方式2: var str = \"222222222222\"; function bytesLength(str)&#123; var count = str.length; for(var i = 0; i &lt; str.length; i++)&#123; if(str.charCodeAt(i) &gt; 255)&#123; count ++; &#125; &#125; return count; // 闭包 &#125; var Str = bytesLength(str); //Str 接受闭包小于等于 255 是一个字节，大于是两个字节返回值大于 255 是中文上面 是两种方法 → Unicode 编码涵盖 asc 码 原型 定义：原型是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 利用原型特点和概念，可以提取共有属性。 对象属性的增删和原型上属性增删改查。 对象如何查看原型 ==&gt; 隐式属性 proto。 对象如何查看对象的构造函数 ==&gt; constructor。 prototype 原型，一种继承关系，出生（一开始）就被定义好了 123456789101112131415161718192021222324例:person.prototype //原型（描述一种继承关系），出生时就被定义好了person.prototype = &#123;&#125; //是祖先// Person.prototype ————&gt; 原型// Person.prototype ————&gt; 祖先（原型）Person.prototyp.name = 'hehe';function Person()&#123;&#125;var person = new Person();var person1 = new Person();// 在控制台输出:// &gt; person// &lt;· Person&#123;&#125;// &gt; person.name// &lt;· 'hehe'右上的 person 和 person1 都有一个共有的祖先 Person.prototype 12345678910111213141516 // Person.prototype ————&gt; 原型例1: // Person.prototype ————&gt; 祖先（原型）Person.prototype.LastName = \"Deng\";Person.prototype.say = function() &#123; console.log(\"hehe\");&#125;;function Person() &#123; this.LastName = \"Ji\";&#125;var person = new Person();var person1 = new Person();// 在控制台输出:// &gt; person.LastName// &lt;· 'Ji' 1234567891011121314151617181920212223 // person.prototype ————&gt; 原型例2: // Person.prototype ————&gt; 祖先（原型）Person.prototype.LastName = \"Deng\";Person.prototype.say = function() &#123; console.log(\"hehe\");&#125;;function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;var person = new Person(\"xuming\", 35, \"male\");// 在控制台输出:// &gt; person// &lt;· Person&#123;name:'xuming',age:35,sex:'male'&#125;// &gt; person.name// &lt;· 'xuming'// &gt; person.LastName// &lt;· 'Deng' 自己身上有需要的属性，原型上也有属性，取近的，用自己的 123456789101112131415161718192021222324252627282930例: 1) // person.prototype ————&gt; 原型 // Person.prototype ————&gt; 祖先（原型） function Car(color,owner)&#123; this.owner = owner; this.carName = 'BMW'; this.height = 1400; this.lang = 4900; this.color = color; &#125; var car = new Car('red','prof.ji');// 将 1) 上面代码提取出来放在原型里面就如 2) 2) // person.prototype ————&gt; 原型 // Person.prototype ————&gt; 祖先（原型） Car.prototype.height = 1400; Car.prototype.lang = 4900; Car.prototype.carName = 'BMW'; function Car(color,owner)&#123; this.owner = owner; this.color = color; &#125; var car = new Car('red','prof.ji'); var car = new Car('green','laodeng'); 123456789101112131415161718// person.prototype ————&gt; 原型例: // Person.prototype ————&gt; 祖先（原型）Person.prototype.lastName = \"Deng\";function Person(name) &#123; this.name = name;&#125;var person = new Person(\"xuming\");// 在控制台打印:// &gt; person.lastName = 'James';// &lt;· 'James'// &gt; person// &lt;· Person&#123;name : 'xuming',lastName : 'James'&#125;// &gt; person.lastName// &lt;· 'James' 上面通过对象（后代）改原型（祖先）是不行的，在对象里面修改，只是作用给自己的，给自己加了一个属性。改原型都不行，增加肯定也不行。对象可以删除属性 123456789101112131415161718192021222324252627例: 1) // person.prototype ————&gt; 原型 // Person.prototype ————&gt; 祖先（原型） Person.prototype.height = 1400; Person.prototype.lang = 4900; Person.prototype.carName = 'BMW'; function Car()&#123; &#125; var pereson = new Person('xuming');// 1) 的简化写法见 2): 2) // person.prototype ————&gt; 原型 // person.prototype ————&gt; 祖先（原型） Car.prototype = &#123; height : 1400, lang : 4900, carName : BMW &#125; function Car()&#123; &#125; var car = new Car(); construnctorconstructor 是构造的意思 原型内部自带 constructor，指的是 Car。通过 constructor 能找的谁构造的自己 1234567891011121314151617181920212223242526272829303132333435363738例1: function Car()&#123; &#125; var car = new Car(); // 在控制台中输出: // &gt; car.constructor // &lt;· function Car()&#123;&#125; // &gt; Car.prototype // &lt;· Object&#123; // constructor:Car() ————&gt; 粉色字体 // __proto__:Object ————&gt; 粉色字体 // &#125;construnctor 是构造的意思(隐式是浅粉色)例2: //Person.prototype ————&gt; 原型 //Person.prototype ————&gt; 祖先（原型） Car.prototype.abc = '123'; function Car()&#123; &#125; var car = new Car(); // 在控制台中输出: // &gt; Car.prototype // &lt;· Object&#123; // abc : '123' ————&gt; 紫色字体 // constructor:Car() ————&gt; 粉色字体 // __proto__:Object ————&gt; 粉色字体 // &#125;粉红色是系统帮你设置的，深紫色是自己设置的 在原型内部自带 constructor，指的是 Car。通过 constructor 能找的谁构造的自己，也可以通过 constructor 来改变自己的构造对象 12345678910111213141516171819202122例: // Person.prototype ————&gt; 原型 // Person.prototype=&#123;&#125; ————&gt; 祖先(原型) function Person()&#123; &#125; Car.prototype = &#123; constructor : Person &#125; function Car()&#123;&#125; var car = new Car(); // 在控制台输出: // &gt; car.constructor // &lt;· function Person()&#123; // &#125;// car的构造对象本来是 function Car()&#123;&#125; 但是经过 constructor属性 的更改，car的构造对象变成了 function Person()&#123;&#125;, constructor属性也可以，找构造函数所对应的构造对象。constructor 可以被人工手动更改 protot1234567891011121314151617181920212223242526例: Person.prototype.name = \"abc\";function Person() &#123; //var this = &#123; // __proto__: Person.prototype // &#125;&#125;var person = new Person();// 在控制台输出:// &gt; person// &lt;· Person&#123;// __proto__ : Object&#123;// constructor:Person()// __protot__:Object// &#125;// &#125;// &gt; person.__proto__// &lt;· Object&#123;// constructor : Person() ————&gt; 粉色字体// name : 'abc' ————&gt; 紫色字体// __proto__ : Object ————&gt; 粉色字体// &#125;// &#125; 1234567浅粉色的__proto__是系统的隐式的属性,前面两个_后面两个_，可以修改，尽量不改。在开发的时候，如果很私人可以写成_private，告诉同事别动。上面的__proto__放的是原型。__proto__存的对象的原型上面的 var this =&#123;__proto__:person.prototype&#125;;这个对象并不是空的，这个 proto，当你访问这个对象的属性时，如果对象没有这个属性，那么就会访问 proto 索引，看看有没有。有一个连接的关系，原型和自己连接到一起 12345678910111213141516171819202122例: Person.prototype.name = \"abc\";function Person() &#123; //var this = &#123; // __proto__ : Person.prototype //&#125;&#125;var obj = &#123; name: \"sunny\"&#125;;var person = new Person();person.__proto__ = obj;// 在控制台输出:// &gt; person.__proto__// &lt;· Object&#123;name : 'abc'&#125;// &gt; person.__proto__ = obj// &lt;· Object&#123;name : 'sunny'&#125;// &gt; person.name// &lt;· 'sunny' Person 的原型是可以被修改的 补充123456789例: Person.prototype.name = \"sunny\";function Person() &#123;&#125;var person = new Person();Person.prototype.name = \"cherry\";// 从控制器输出:// &gt; person.name//&lt;· 'cherry' 123456789例: Person.prototype.name = \"sunny\";function Person() &#123;&#125;Person.prototype.name = \"cherry\";var person = new Person();// 从控制器输出:// &gt; person.name//&lt;· 'cherry' 12345678910111213例: Person.prototype.name = \"sunny\";function Person() &#123; //var this = &#123;__proto : Person.prototype&#125;&#125;var person = new Person();Person.prototype = &#123; name: \"cherry\"&#125;;// 从控制器输出:// &gt; person.name//&lt;· 'sunny' 123456789Person.prototype.name 这种.的写法是在原有的基础上把值改了。改的是属性，也就是房间里面的东西。而 Person.prototype=&#123;name:'cherry'&#125;是把原型改了，换了新的对象。改了个房间。上面在 new 的时候 var this = &#123;__proto__:Person.prototype&#125;里面的指向 Person，此时Person.prototype 与__proto__指向的是一个空间，把他返回给 var person。先 new 再 Person.prototype=&#123;name:'cherry'&#125;已经晚了在 Person.prototype=&#123;name:'cherry'&#125;时，Person.prototype 空间改了，但是__proto指向的空间不变。 12345上面的步骤实际（简化）上是→ Person.prototype = &#123;name : 'a'&#125;; __proto__ = Person.prototype; Person.prototype = &#123;name : 'b'&#125;; 1234567891011例: var obj = &#123; name: \"a\" &#125;;var obj1 = obj;obj = &#123; name: \"b\" &#125;;// 从控制台输出:// &gt; obj1// &lt;· Object&#123;name:'a'&#125;// &gt; obj// &lt;· Object&#123;name:'b'&#125; 123456789101112131415161718例: Person.prototype.name = 'sunny'; function Person()&#123; //var this = &#123;__proto : Person.prototype&#125; &#125; Person.prototype = &#123; name : 'cherry' &#125; var person = new Person(); 上面这种思考过程：程序执行顺序1.先把 function Person()&#123;&#125;在预编译的过程中提到最上面2.再执行 Person.prototype.name = 'sunny'这一样行3.再执行 Person.prototype = &#123;name:'cherry'&#125;4.最后执行 var person = new Person();执行到 new 的时候，才会发生 //var this=&#123;__proto__:Person.prototype&#125;5.下面的把上面的覆盖了6.答案是 cherry 铺垫原型链 12345678910例: function Person() &#123;&#125;// 从控制台输出:// &gt; Person.prototype// &lt;· Object// &gt; constructor : Person()// &gt; __proto__ : Object// 这说明原型里面有原型 1234567891011121314151617181920212223242526272829303132333435363738394041例: 原型链;Grand.prototype.lastName = \"Deng\";function Grand() &#123;&#125;var grand = new Grand();Father.prototype = grand;function Father() &#123; this.name = \"xuming\";&#125;var father = new Father();Son.prototype = father;function Son() &#123; this.hobbit = \"smoke\";&#125;var son = new Son();// 从控制台输出时:// &gt; son.hobbit// &lt;· 'smoke'// &gt; son.name// &lt;· 'xuming'// &gt; son.lastName// &lt;· 'Deng'// &gt; Grand.prototype// &lt;· Object// ·&gt; constructor : Gran()// lastName : 'Deng'// ·&gt; __proto__ : Object// ·&gt; __defineGetter__;// ·&gt; __defineSetter__;// ·&gt; __lookupGetter__;// &gt; Object.prototype// &lt;· Object&#123;&#125;// &gt; Object.prototype.__proto__// &lt;· null 123执行 son.toString //返回 function toString( )&#123; [native code] &#125;，这里返回的是原型链终端的 toStringGrand.prototype.__proto__ = Object.prototype // Object.prototype 是原型链的终端 原型链12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561、如何构成原型链?(如下)原型链 Grand.prototype.lastName = 'Deng'; function Grand()&#123; &#125; var grand = new Grand(); Father.prototype = grand; function Father()&#123; this.name = 'xuming'; &#125; var father = new Father(); Son.prototype = father; function Son()&#123; this.hobbit = 'smoke'; &#125; var son = new Son(); // 从控制台输出时: // &gt; son.hobbit // &lt;· 'smoke' // &gt; son.name // &lt;· 'xuming' // &gt; son.lastName // &lt;· 'Deng' // &gt; Grand.prototype // &lt;· Object // ·&gt; constructor : Gran() // lastName : 'Deng' // ·&gt; __proto__ : Object // ·&gt; __defineGetter__; // ·&gt; __defineSetter__; // ·&gt; __lookupGetter__; // &gt; Object.prototype // &lt;· Object&#123;&#125; // &gt; Object.prototype.__proto__ // &lt;· null2、原型链上属性的增删改查，原型链上的增删改查和原型基本上是一致的。只有本人有的权限，子孙是没有的。3、谁调用的方法内部 this 就是谁-原型案例4、绝大多数对象的最终都会继承自 Object.prototype5、Object.create(原型);6、原型方法上的重写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647例: Grand.prototype.lastName = 'Deng'; function Grand()&#123; &#125; var grand = new Grand(); Father.prototype = grand; function Father()&#123; this.name = 'xuming' this.fortune = &#123; card1 : 'visa' &#125; &#125; var father = new Father(); Son.prototype = father; function Son()&#123; this.hobbit = 'smoke'; &#125; var son = new Son(); // 从控制台输出: // &gt; son.fortune // &lt;· Object&#123;card1 : 'visa'&#125; // &gt; son.fortune = 200; // &lt;· 200 // &gt; son // &lt;· Son&#123;hobbit : 'smoke',fortune : 200&#125; // &gt; father.fortune // &lt;· Object&#123;card1 : 'visa'&#125; // &gt; son.fortune.card2 = 'master' // &lt;· 'master' // &gt; son // &lt;· Son&#123;hobbit : 'smoke'&#125; // &gt; father // &lt;· Grand&#123;name : 'xuming',fortune : Object&#125; // ·&gt; fortune : Object // card1 : 'visa' // card2 : 'master' // __proto__ : Object // name : 'xuming' // ·&gt; __proto__ : Grandson.fortune.card2='master'这种改，这是引用值自己的修改。属于 fortune.name 给自己修改，这是一种调用方法的修改 123456789101112131415161718192021222324252627282930313233343536例: Grand.prototype.lastName = 'Deng'; function Grand()&#123; &#125; var grand = new Grand(); function Fahter()&#123; this.name = 'xuming'; this.fortune = &#123; card1 : 'visa' &#125;; this.num = 100; &#125; var father = new Father(); Son.prototype = father; function Son()&#123; this.hobbit = 'smoke' &#125; var son = new Son(); // 从控制台输出 // &gt; son.num++ // &lt;· 100 // &gt; father.num // &lt;· 100 // &gt; son.num // &lt;· 101son.num++ 是 son.num = son.num+1，是先把父级的取过来再赋值+1，所以父级的没变 12345678910111213141516例: Person.prototype = &#123; name: \"a\", sayName: function() &#123; console.log(this.name); &#125;&#125;;function Person() &#123;&#125;var person = new Pereson();// 从控制台输出:// &gt; person.sayName()// a// &lt;· undefinedconsole.log(this.name); //如果写成 name 就会错，没有这个变量 12345678910111213141516171819202122232425例: Person.prototype = &#123; name : 'a'; sayName : function()&#123; console.log(this.name); &#125; &#125; function Pereson()&#123; this.name = 'b'; &#125; var person = new Person(); // 从控制台输出 // &gt; person.sayName() // b // &lt;· undefined // &gt; person.prototype.sayName() // a // &lt;· undefineda.sayName() 方法调用，就是say.Name 里面的 this 指向，是谁调用的这个方法，this 就指向谁 123456789101112131415161718192021222324252627282930313233343536373839404142434445例: 1) Person.prototype = &#123; height : 100 &#125; function Person()&#123; this.eat = function()&#123; this.height ++; &#125; &#125; var person = new Person(); // 控制台输出: // &gt; person.eat() // &lt;· undefined // &gt; person // &lt;· Person&#123;height : 101&#125; // &gt; person.__proto__ // &lt;· Object&#123;height : 100&#125;this.height ++; //这后面默认有一个 return undefined 2) Person.prototype = &#123; height : 100 &#125; function Person()&#123; this.eat = function()&#123; this.height ++; return 123; &#125; &#125; var person = new Person(); // 控制器输出: // &gt; person.eat() // &lt;· 123 12345678910111213例: var obj = &#123;&#125;；也是有原型的 var obj = &#123;&#125;; 与 var obj1 = new Object(); 的效果是一样的 写 var obj = &#123;&#125;; 系统会在内部来一个 new Object(); obj1.__proto__ ————&gt; Object.prototype; 但是在构造对象的时候，能用对象自变量 var obj = &#123;&#125;; 就不要用 var obj1 = new Object(); 1) Person.prototype = &#123;&#125; ————&gt; Object.prototype funtion Person()&#123; &#125; 对象自变量的原型就是 Object.prototype; Object.create 原型var obj = Object.create(原型) Object.create 也能创建对象。var obj = Object.create(这里必须要有原型) 1234567891011//var obj = Object.create(原型)例: var obj = &#123; name: \"sunny\", age: 123 &#125;;var obj1 = Object.create(obj);// 从控制台输出:// &gt; obj1// &lt;· Object &#123;&#125;// &gt; obj1.name// &lt;· 'sunny' 12345678910111213141516171819202122232425262728293031323334353637383940例: //var obj = Object.create(原型) Person.prototype.name = 'sunny'; function Person()&#123; &#125; var person = Object.create(Person.prototype);绝大多数对象的最终都会继承自 Object.prototype// 如: 控制台输出// html 里面没有添加任何东西，这样就会报错// &gt; Object.create()// &lt;· 报错// html里面没有添加任何东西，只在控制台加上null// &gt; Object.create(null)// &lt;· Object// No Properties// var obj = Object.create(null);// &gt; obj.name = 123;// &lt;· 123// &gt; obj// &lt;· Object// name : 123// &gt; obj.__proto__ = &#123;name : 'sunny'&#125;// &lt;· Object&#123;name : 'sunny'&#125;// &gt; obj// &lt;· Object&#123;&#125;// &gt; obj.name// &lt;· undefined// &gt; obj.toString()// &lt;· 报错 原型是隐式的内部属性，你加是没有用的 1234567891011121314例: //var obj = Object.create(原型) var obj = Object.create(123); // 在控制台中会报错Object.create() 在括号里面只能放 null 或者 Object,其余会报错undefined 和 null 没有原型，也就不可能有 toString 方法,如下: // 控制器输出 // &gt; undefined.toString() // &lt;· 报错 // &gt; null.toString() // &lt;· 报错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051例1:下面 123.toString 首先会识别成浮点型，所以在后面直接加.toString 是不行的 // &gt; true.toString() // &lt;· 'true' // &gt; 123.toString() // &lt;· 报错 // &gt; var num = 123; // &lt;· undefined // &gt; num.toString() // &lt;· '123' // &gt; var obj = &#123;&#125; // &lt;· undefined // &gt; obj.toString() // &lt;· '[object Object]'数字想用 toString 方法，要经过包装类包装 new Number(num) 然后.toString例2:加深上面的理解 var num = 123; //num.toString(); ————&gt; new Number(num).toString(); Number.prototype.toString = function()&#123; &#125; //Number.prototype.__proto__ = Object.prototype而 new Number(num). toString 的原型是 Nunber.prototype，而 Nunber.prototype 上面有一个.toString 方法，Nunber.prototype 也有原型 Nunber.prototype.__proto__，原型是Object.prototype假如 new Number 上面的 prototype 上面有这个 toString，那么就不用Object.prototype的 toString。而这个 number 上面有这个 toString。然后 number 上面的 toString 调用的是自己重写的 toString。原型上有这个方法，我自己又写了一个和原型上同一名字，但不同功能的方法，叫做重写（同一名字的函数，不同重写方式）通过返回值，形参列表不同传参同样的名实现不同功能的，就是重写 var num = 123; // num.toString(); ————&gt; new Number(num).toString(); Number.prototype.toString = function()&#123; &#125; // Number.prototype.__proto__ = Object.prototype //Object.prototype.toString = function()&#123; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061例: 1) // var obj = Object.create(原型) // Object.prototype.toString = function()&#123; // &#125; Person.prototype = &#123; &#125; function Person()&#123; &#125; var person = new Person(); // 控制台输出: // &gt; person.toString() // &lt;· '[object Object]'和原型链上终端方法名字一样，但实现不同的功能，叫做方法的重写。也就是覆盖 2) // var obj = Object.create(原型); //Object.prototype.toString = function()&#123; // &#125; Person.prototype = &#123; toString : function()&#123; return 'hehe'; &#125; &#125; function Person()&#123; &#125; var pereson = new Person(); // 控制台输出: &gt; person.toString() &lt;· 'hehe'下面这个也是重写: 3) // var obj = Object.create(原型); object.prototype.toString = function()&#123; return 'haha'; &#125; Person.prototype = &#123; &#125; function Person()&#123; &#125; var person = new Person(); // 控制器输出: &gt; person.toString() &lt;· 'haha' 123456789101112131415161718192021222324让上面的 1)、2)、3) 中的 object 上面的 toString 重写了。所以num.toString()调用的是 number.prototype.toString。 Object.prototype.toString Number.prototype.toString Array.prototype.toString Boolean.prototype.toString String.prototype.toString // 控制器输出: // &gt; var num = 123; // &lt;· undefined // &gt; num.toString() // &lt;· '123'如果调用的是 object. prototype.toString 结果会不一样。 // &gt; Object.prototype.toString.call(123) // &lt;· '[object Number]' // &gt; Object.prototype.toStrin.call(true) // &lt;· '[object Boolean]' 1234567891011121314151617181920212223242526272829303132333435363738394041例: 1) Number.prototype.toString = function()&#123; return '老大身体好'; &#125; // 控制台输出: // &gt; var num = 123; // &lt;· undefined // &gt; num.toString() // &lt;· '老邓身体好' 2) var obj = 123; document.write(obj);// 答案:123 3) var obj = &#123;&#125;; document.write(obj);// 答案:[object Object] 4) var obj = Object.create(null); document.write(obj);// 答案:报错// 解析: document.write 会隐式的调用 toString 方法，其实打印的是 toString的结果 var obj = Object.create(null); document.write(obj.toString());// 没有原型就不能 toString 5) var obj = Object.create(null); obj.toString = function ()&#123; return '老大身体好'； &#125; document.write(obj);// 答案: 老邓身体好 上面这个例子表示：我要打印的是 obj，实际上打印出来的是 toString 方法，也证明了 document.write 调用的是 toString 方法 call / apply 作用，改变 this 指向。 区别，后面传的参数不一样 123456789101112131415161718192021222324252627toFixed 是保留两位有效数字例:有一个 bug,在控制台 0.14 * 100// 答案 : 1400000000000002,是js开发精度不精准例:向上取整 Math.ceil(123.234)// 答案 124例:向下取整 Math.floor(123.999)// 答案 123例: Math.random()是产生一个 0 到 1 区间的开区间 随机数例: for(var i = 0; i &lt; 10;i ++)&#123; var num = Math.random().toFixed(2) * 100; console.log(num);&#125;//所以一般在这种情况下，我们不用 toFixed，因为精度不准确例:用这种方法取整更好，就不会精度不准确 for(var i = 0;i &lt; 10; i++)&#123; var num = Math.floor(Math.random() * 100); console.log(num); &#125;注意：之前 js 在小数点后面最多能容纳 15-17 位，但是升级后能用科学计数法表示如 2e-17（是 2 乘以 10 的负 17 次方）而小数点前面只能容纳 16 位的运算， 可正常计算的范围是小数点前后 16 位 123456789101112// 任何一个方法都可以 .call ,.call 才是一个方法执行的真实面目例: function Persom(name, age) &#123; // this == obj this.name = name; this.age = age;&#125;var person = new Person(\"deng\", 100);var obj = &#123;&#125;;Person.call(obj, \"Yu\", 300);// test() ————&gt; test.call() 123456789直接执行 Person.call ( )和 Person ( )没有区别Person.call( );括号里面可以传东西如果 Person.call( obj );里面的 call 让 person 所有的 this 都变成 obj不 new 的话，this 默认指向 window。call 的使用必须要 newcall 的第一位参数用于改变 this 指向，第二位实参（对应第一个形参）及以后的参数都当做正常的实参，传到形参里面去借用别人的方法，实现自己的功能。 例写 test（）和写 test.call（）是一样的 12345678910111213141516171819202122232425262728293031323334353637例: function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex; &#125; function Student(name,age,sex,tel,grade)&#123; this.name = name; this.age = age; this.sex = sex; this.tel = tel; this.grae = grade; &#125; var student = new Student('sunny',123,'male',139,2019);call 改变 this 指向，借用别人的函数，实现自己的功能。只能在你的需求完全涵盖别人的时候才能使用如果不想要 age 这个，就不能使用这种方法：如下 function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex; &#125; function Student(name,age,sex,tel,grade)&#123; //var this = &#123;name : '',age : '',sex : ''&#125;; Person.call(this,name,age,sex); this.tel = tel; this.grade = grade; &#125; var student = new Studnet('sunny',123,'male',139,2019);Person.call(this, name, age, sex);里面的 this 现在是 new 了以后的 var this=&#123;&#125;利用 Person 方法，实现了 Student 自己的封装 123456789101112131415161718192021function Wheel(wheelSize,style)&#123; this.style = style; this.wheelSize = wheelSize;&#125;function Sit(c,sitColor)&#123; this.c = c; this.sitColor = sitColor;&#125;function Model(height,widht,len)&#123; this.height = height; this.widht = widht; this.len = len;&#125;function Car(wheelSize,style,c,sitColor,height,widht,len)&#123; Wheel.call(this.wheelSize,style); Sit.call(this,c,sitColor); Model.call(this,height,widht,len);&#125;var car = new Car(100,'花里胡哨','真皮','red',1800,1900,4900); apply 也是改变 this 指向的，只是传参列表不同，第一位也是改变 this 指向的人，第二位，apply 只能传一个实参，而且必须传数组 argunments call 需要把实参按照形参的个数传进去 new以后才有意义 1234567891011121314151617181920function Wheel(wheelSize,style)&#123; this.style = style; this.wheelSize = wheelSize; &#125; function Sit(c,sitColor)&#123; this.c = c; this.sitColor = sitColor; &#125; function Model(height,widht,len)&#123; this.height = height; this.widht = widht; this.len = len; &#125; function Car(wheelSize,style,c,sitColor,height,widht,len)&#123; Wheel.apply(this.[wheelSize,style]); Sit.apply(this,[c,sitColor]); Model.apply(this,[height,widht,len]); &#125; var car = new Car(100,'花里胡哨','真皮','red',1800,1900,4900); 继承发展史一、 传统形式 ==&gt; 原型链1234567891011121314例: Grand.prototype.lastName = \"Ji\";function Grand() &#123;&#125;var grand = new Grand();Father.prototype = grand;function Father() &#123; this.name = \"hehe\";&#125;var father = new Father();Son.prototype = father;function Son() &#123;&#125;var son = new Son(); 二、借用构造函数 ==&gt; 利用 call、apply所以不算标准的集成模式 1）不能继承借用构造函数的原型 2）每次构造函数都要多走一个函数 ==&gt; 浪费效率 this 放进去的前提，这个函数必须是 new 来的 12345678910例: function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;function Student(name, age, sex, grade) &#123; Person.call(this, name, age, sex); this.grade = grade;&#125;var student = new Student(); 三、共享原型（比较好的继承方法，不能随便改动自己的原型）1234567891011121314例: Father.prototype.lastName = \"Deng\";function Father() &#123;&#125;function Son() &#123;&#125;Son.prototype = Father.prototype;var son = new Son();var father = new Father();// 从控制台输出:// &gt; son.lastName// &lt;· 'Deng'// &gt; father.lastName// &lt;· 'Deng' 例:可以用上面的方式封装函数，实现一个继承 extend 和 inherit 都是继承的意思 inherit 是 css 的一个值，也是继承的意思。 文字类属性都有要给传递的特性:子元素没有设置文字类属性，子元素默认继承父元素的属性。 font-size:inherit(我没有继承父亲的) 在 inherit（Target，Origin）里面传进去的值是构造函数，需要大驼峰式书写，origin是（原始）的意思，让 target（目标）继承 origin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960例: Father.prototype.lastName = 'Deng'; function Father()&#123; &#125; function Son()&#123; &#125; function inherit(Target,Origin)&#123; Target.prototype = Orign.prototype &#125; inherit(Son,Father); var son = new Son(); var father = new Father(); // 从控制台输出: // &gt; son.lastName // &lt;· 'Deng'// 上面这种方式，让 son 里面有了 father 原型的属性// 应该是inherit继承，后使用// 下面这种情况就是先继承了，后改变原型已经晚了，因为他继承的还是原来的空间 Father.prototype.lastName = 'Deng'; function Father()&#123; &#125; function Son()&#123; &#125; function inherit(Target,Origin)&#123; Target.prototype = Origin.prototype; &#125; var father = new Father(); var son = new Son(); inherit(Son,Father);// 下面这种写法，son.prototype 和 father.prototype 指向的是一个房间，改 son 就改了father。我们希望 son 用的 father 的原型，但是改变 son 自己的属性不影响 father Father.prototype.lastName = 'Deng'; function Father()&#123; &#125; function Son()&#123; &#125; function inherit(Target,Origin)&#123; Target.prototype = Origin.prototype; &#125; inherit(Son,Father); var son = new Son(); var father = new Fahter(); // 从控制台输出: // &gt; son.sex // &lt;· 'male' // &gt; father.sex // &lt;· 'male' 四、圣杯模式圣杯模式是在方法三的共有原型的基础上有所改变 共享原型是：son.prototype = father.prototype 圣杯模式是：另外加个构造函数 function F(){} 当作中间层，然后让 F 和 father 共有一个原型 F.prototype = father.prototype,然后 son.prototype = new F();使用原型链形成了继承关系，现在改 son.prototype 就不会影响 father.prototype 123456// Father.prototypefunction F()&#123;&#125;F.prototype = Father.prototype;Son.prototype = new F(); 12345678910111213141516171819202122232425262728例: function inherit(Target, Origin) &#123; function F() &#123;&#125; F.prototype = Origin.prototype; Target.prototype = new F(); &#125; Father.prototype.lastName = \"Deng\"; function Father() &#123;&#125; function Son() &#123;&#125; inherit(Son, Father); var son = new Son(); var father = new Father();// 从控制台输出：// &gt; father.lastName// &lt;· 'Deng'// &gt; son.lastName// &lt;· 'Deng'// &gt; Son.prototype.sex = 'male';// &lt;· 'male'// &gt; son.sex// &lt;· 'male'// &gt; father.sexx// &lt;· undefined// &gt; Father.prototype// &lt;· Object&#123;lastName:'Deng'&#125; son.__proto__ --&gt; new F().__proto__ --&gt; Father.prototype 123456789101112131415161718192021222324例: 原型上默认有个 constructor，constructor 默认值指向他的构造函数，son.constructor 应该指向 Son // &gt; son.constructor // &lt;· function Father()&#123;&#125; 所以指向了 father 就是混乱了，所以指一下，如下:例: function inherit(Target,Origin)&#123; function F()&#123;&#125;; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; //----&gt; 让它的 constructor 可以指向自己 Target.prototype.uber = Origin.prototype; //----&gt; 让它可以知道自己继承自谁 &#125; Father.prototype.lastName = 'Deng'; function Father()&#123;&#125; function Son()&#123;&#125; inherit(Son,Father); var father = new Fahter(); var son = new Son();// Target.prototype.uber = Origin.prototype; 我们希望我们构造出的对象，能找到自己的超类，超级父级（究竟继承自谁）应该起名为super 但这个是保留字，我们就以 uber 命名。 123456789101112131415161718// 左下这种方法就不好使了，相当于右下。还是原型指向有问题，new 的时候用的是原来的原型，再 F.prototype =father.prototype 没用，son.prototype 没发生改变例: function inherit(Target, Origin) &#123; function F() &#123;&#125; F.prototype = Origin.prototype(); Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype;&#125;Father.prototype.lastName = \"Deng\";function Father() &#123;&#125;function Son() &#123;&#125;inherit(Son, Father);var son = new Son();var father = new Father(); 12345678910111213141516171819202122232425262728293031323334// 例，在雅虎时代，封装了 YUI3 库来解决方法三的不足，与圣杯模式相似。现在不用// YUI3 库，现在用 jquery// 正常：function inherit(Target,Origin)&#123; function F()&#123;&#125;; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype;&#125;// 雅虎：var inherit = (function ()&#123; var F = function ()'&#123;&#125;; return function (Target,Origin)&#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype; &#125;&#125;())// 上面的 var inherit 与右边的 var inherit 是一样的意思,建议写上面的这种var inherit = (function()&#123; var F = function ()&#123;&#125;; function demo(Target,Origin)&#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototypu.uber = Origin.prototype; &#125; return demo;&#125;()) 闭包、属性私有化、封装123456例为什么在外部执行的 divorce 能用内部的变量？能换成 xiaozhang？因为 this.divorce 在对象上，由于对象被返回了，这个方法也被返回了。因为闭包。这个函数被储存到了外部，所以储存了这个函数的执行期上下文。所以可以用这个闭包。所以 var prepareWife 被下面的 this=fn 三个函数共用，这三个函数分别与 fn Deng 形成了闭包，共同用 Deng 的 AO,所以可以在外部随意存取。 1234567891011121314151617181920212223242526272829303132333435例: function Deng(name,wife)&#123; var prepareWife = 'xiaozhang'; this.name = name; this.wife = wife; this.divorce = function ()&#123; this.wife = prepareWife; &#125; this.changePrepareWife = funtion(target)&#123; prepareWife = target; &#125; this.sayPrapreWife = function()&#123; console.log(prepareWife); &#125; &#125; var deng = new Deng('Deng','xiaoliu'); // 从控制器输出: // &gt; deng // &lt;· Deng // &gt; changePrepareWife(target) // &gt; divorce:() // name : \"deng\" // &gt; sayPrapreWife:() // wife : 'xiaoliu' // &gt; __proto__ : Object // &gt; deng.divorce() // &lt;· undefined // &gt; deng.wife // &lt;· 'xiaozhang' // &gt; deng.prepareWife // &lt;· undefined deng.prepareWife 是 undefined 的，表面上看起来不是自己的，但是实际上只有对象自己通过对象自己设置的方法可以去操作他，外部用户通过对象，prepareWife 是看不到的，只有自己能看到，就是闭包的私有化运用。 12345678910111213141516例: var inherit = (function() &#123; var F = function() &#123;&#125;; return function(Target, Origin) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype; &#125;;&#125;)();// 执行完是这个样子var inherit = function(Target, Origin) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype;&#125;; 上面的 var F 这个 F 形成了闭包，成为了这个函数的私有化变量，而且变成私有化变量就更好 命名空间（对象模块化开发,其实就是对象） 管理变量，防止污染全局，适用于模块化开发 多人开发，对象命名容易重复，就要解决命名空间的问题 12345678910111213141516171819202122232425以前的命名空间老旧的解决方法，如下： var org = &#123; department1 : &#123; jicheng : &#123; name : 'abc', age : 123 &#125;, xuming : &#123; &#125; &#125;， departmeng2 : &#123; zhangsan : &#123; &#125;, lisi : &#123; &#125; &#125; &#125;// 这是用的写法 var jicheng = org.department1.jicheng; jicheng.name 下面是现在公司最常见的方法：用闭包来解决（也可用 webpack），返回方法的调用。init 是初始化，入口函数，入口名字。init 调用了这个函数的功能 12345678910111213141516171819202122232425262728293031323334353637var name = 'bcd';var init = (function()&#123; var name = 'abc'; function callName()&#123; console.log(name); &#125; return function()&#123; callName(); &#125;&#125;())var initDeng = (function()&#123; var name = 123; function callName()&#123; console.log(name); &#125; return function ()&#123; callName(); &#125;&#125;)init();initDeng();// 从控制台输出:// &gt; init()// abc// &lt;· undefined// &gt; initDeng()// &lt;· 报错// &gt; initDeng()// 123// &lt;· undefined 思考问题（连续调用） 如何实现调用模式（模仿 jquery） obj.eat().smoke().drink().eat().sleep; 123456789101112&lt;div&gt;&lt;/div&gt;&lt;script&gt; $(\"div\") .css(\"background-color\", \"red\") .width(100) .height(100) .html(123) .css(\"postion\", \"absolute\") .css(\"left\", \"100px\") .css(\"top\", \"100px\");&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738例: var deng = &#123; smoke : function()&#123; console.log('Smoke,…… xuan cool!!!'); &#125;, drink : function()&#123; console.log('drinking……,ye cool!'); &#125;, perm : function()&#123; console.log('preming……，cool'); &#125; &#125; deng.smoke(); deng.drink(); deng.prem();// 不能连续调用 deng.smoke().drink();上面改成下面的写法:用return this，就可以连续调用和执行了。deng.smoke().drink() var deng = &#123; smoke : function()&#123; console.log('Smoke,... xuan cool!!!'); return this; &#125;, drink : function()&#123; console.log('drinking...,ye cool!'); return this; &#125;, prem : function()&#123; console.log('preming..., cool!'); return this; &#125; &#125; deng.smoke().drink().perm().smoke().drink();// 上面使用 return this 连续的调用 属性的表示方法（查看属性）obj.prop 查看就用 .prop obj[&quot;prop&quot;] 中括号也是访问属性的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849想要传出去序号几，就会调用几// 下面的是老旧办法 var deng = &#123; wife1 : &#123;name : 'xioaliu'&#125;, wife2 : &#123;name : 'xiaozhang'&#125;, wife3 : &#123;name : 'xiaomeng'&#125;, wife4 : &#123;name : 'xiaowang'&#125;, sayWife : function(num)&#123; switch(num)&#123; case 1: return this.wife1; case 2: return this.wife1; case 3: return this.wife1; case 4: return this.wife1; &#125; &#125; &#125; deng.switch(1);// 上面用 switch 的方法不是很好，下面的方法比较完善一些// var obj = &#123;name : 'abc'&#125;// 用方括号来访问属性也是一样的（里面必须是字符串）// 这两种基本上完全相同 obj.name ---&gt; obj['name']// 想要实现属性名的拼接，只能用方括号的形式 // &gt; obj.name // &lt;· 'abc' // &gt; obj['name'] // &lt;· 'abc' var deng = &#123; wife1 : &#123;name : 'xiaoliu'&#125;, wife2 : &#123;name : 'xiaozhang'&#125;, wife3 : &#123;name : 'xiaomeng'&#125;, wife4 : &#123;name : 'xiaownag'&#125;, sayWife : function(num)&#123; return this['wife' + num]; &#125; &#125; 对象的枚举（enumeration）for in 循环（简化版 for 循环），目的是遍历对象，通过对象属性的个数来控制循环圈数，这个对象有多少属性循环多少圈，而且在每一圈的时候，都把对象的属性名放到 Prop 里面，在枚举面前，一定要写成 obj[prop]不能加字符串 1. hasOwnProperty 2. in 3. instanceof 枚举也就是遍历，挨个知道信息的过程就叫这个数据组的遍历 for(变量 in 对象)12345678910111213141516171819202122例1: var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];// 遍历 枚举 enumerationfor (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125;//for( in ) 循环例2: var obj = &#123; name: \"13\", age: 123, sex: \"male\", height: 180, weight: 75&#125;;for (var prop in obj) &#123; console.log(prop + \" \" + typeof prop);&#125;// name string// age string// sex string// height string// weight string 上面就是 for in 循环，就是遍历用的。通过对象的属性个数来控制循环圈数，有多少个属性就会循环多少圈。 for（var prop in obj）在循环每一圈的时候，他会把对象的属性名放在 prop 里面。 想遍历谁就 in 谁，prop 可以写别的，obj 就是我们想要遍历的对象。 for(XX in XX) 的格式是固定的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// var 也可以写在外面，写成 var key; for(key in obj1) 效果是一样的var obj1 = &#123; a : 123, b : 234, c : 345&#125;var key;for(key in obj1)&#123; obj.key ++;&#125;写成下面会出错 var obj = &#123; var obj = &#123; name : '13', name : '13', age : 123, age : 123, sex : 'male', sex : 'male', height : 180, height : 180, weight : 75 weight : 75 prop : 123 &#125; for(var prop in obj)&#123; for(var prop in obj)&#123; console.log(obj.prop); console.log(obj.prop); &#125; &#125; // 答案：undefined * 5 答案：123*6// 上面的 console.log(obj.prop); 系统以为我们写的是 console.log(obj['prop']);，系统会以为我们是在让他访问 prop 这个属性，不会把 prop 当成一个变量来使用。写成 obj[prop]就可以成功访问了。 var obj = &#123; name : '13', age : 123, sex : 'male', height : 180, weight : 75 &#125; for(var prop in obj)&#123; // console.log(obj.prop ----&gt; obj['prop']); console.log(obj[prop]); &#125;// 写对象时用方括号的形式不容易犯错 var obj = &#123; name : '13', age : 123, sex : 'male', height : 180, weight : 75, __proto__ : &#123; lastName : 'Deng' &#125; &#125; for(var prop in obj)&#123; console.log(obj[prop]) &#125; // 答案：13、123、male、180、75、deng hasOwnProperty如果在遍历的时候，我们不想把原型上面的属性拿出来，可以用 hasOwnProperty,一般与 for in 循环成套出现 hasOwnProperty 是一个方法，来判断这个对象是你自己的还是原型的，任何要给对象里面都有 hasOwnProperty，里面是需要传参的，把属性传进去（如 prop），下面达到了如果不是自己的属性，是原型上的属性，就不会返回 12345678910111213141516171819202122232425262728293031323334353637383940414243例: var obj = &#123; name : '13', age : 123, sex : 'male', height : 180, weight : 75, __proto__ : &#123; lastName : 'deng' &#125; &#125; for(var prop in obj)&#123; if(obj.hasOwnProperty(prop))&#123; console.log(obj[prop]); &#125; &#125;// 答案: 13、123、male、180、75// 注明：for in 循环理论上可以返回原型和原型链上的东西，一旦这个原型链延展到了的 object.prototype 上，不会打印系统的，只会打印自带的。var obj = &#123; __proto__:&#123; lastName : 'deng', __proto__ : Object.prototype // 不会打印这个 object.prototype &#125;&#125;加 Object.prototype.abc = '123'; 加个 ！变成只有不是它的才打印 var obj = &#123; name : '13', age : 123, sex : 'male', height : 180, weight : 75, __proto__ : &#123; lastName : 'deng' &#125; &#125; for(var prop in obj)&#123; if(!obj.hasOwnProperty(prop))&#123; console.log(obj[prop]); &#125; &#125; inin 操作符：很少用 in 操作符，你的也是你的，你父亲的也是你的，只能判断这个对象能不能访问到这个属性，包括原型上，不是判断属性属不属于这个对象的 1234567891011121314151617181920212223242526 var obj = &#123; name : '13', age : 123, sex : 'male', height : 180, weight : 75, __proto__ : &#123; lastName : 'deng' &#125; &#125; for(var prop in obj)&#123; if(!obj.hasOwnProperty(prop))&#123; console.log(obj[prop]); &#125; &#125; // 从控制台输出： &gt; height in obj &lt;· 报错 &gt; 'height' in obj &lt;· true &gt; 'lastName' in obj &lt;· true// 判断一个属性属不属于这个对象的只能用 hasOwnProperty instanceof instanceof 操作符类似于 in，但是完全不同 A instanceof B 的意思是 A 的对象是不是 B 构造函数构造函数构造出来的，记住是：看 Ａ 对象的原型链上有没有 B 的原型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 解决了例1： function Person()&#123; &#125; var person = new Person(); // 从控制器输出 : // &gt; pereson instanceof Object // &lt;· true // &gt; [] instanceof Array // &lt;· true // &gt; [] instanceof Object // &lt;· true例2： function Person()&#123; &#125; var person = new Person(); var obj = &#123;&#125;; // 从控制台输出： // &gt; obj instanceof Person // &lt;· false // &gt; typeof([]) // &lt;· 'object' // &gt; typeof(&#123;&#125;) // &lt;· 'object'例:区别传的变量是数组还是对象的方法：一是 constructor，二是 instanceof var arr = &#123;&#125;;//[] // 从控制台输出: // &gt; obj.constructor // &lt;· function Object()&#123;[native code]&#125; // &gt; [] instanceof Array // &lt;· true // &gt; var obj = &#123;&#125;; // &lt;· undefined // &gt; obj instanceof Array // &lt;· false例:第三种区分数组还是对象的方法：想让数组调用他的 toString 方法 Object.prototype.toString.call([]); //[] 会替换this Object.prototype.toString = function()&#123; // 识别this(谁调的它，这个 this 就是谁）就返回相应的及如果) &#125; obj.toString(); // 从控制台输出: &gt; Object.prototype.toString.call([]); &lt;· '[object Array]' &gt; Object.prototype.toString.call(123); &lt;· '[object Number]' &gt; Object.prototype.toString.call(&#123;&#125;); &lt;· '[object Object]' this,笔试真题,进制进制十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f 十六进制的中 10 是十进制的 16， 1f = 16 + 15 二进制中的 10是十进制的 2，11 是十进制的3 123456789101112| 在十进制中： | 在二进制中： |————————————————————————————————————————| 1 = 1 | 1 = 1 |————————————————————————————————————————| 10 = 10 | 10 = 2 |————————————————————————————————————————| 100 = 10 ^ 2 | 100 = 2 ^ 2 |————————————————————————————————————————| 1000 = 10 ^ 3 | 1000 = 2 ^ 3 |————————————————————————————————————————| 10000 = 10 ^ 4 | 10000 = 2 ^ 4 |———————————————————————————————————————— this函数预编译过程 this ---&gt; 指向 window 12345678910111213141516171819202122232425262728293031 function test(c)&#123; // var this = Object.creat(test.prototype); //&#123; // __proto__ : test.prototype // &#125; var a = 123; function b()&#123;&#125; &#125; // AO&#123; // arguments : [1], // this : window, // c : 1, // a : undefined, // b : function()&#123;&#125; // &#125; test(1); new test(); // 前面的 var this = Object.creat(test.prototype);是最标准的写法 // new test();就会让 var this = Object.creat(test.prototype);如果不 new this 就会指向 window例: function test()&#123; console.log(this); &#125; test(); // &gt; window // &lt;· Window&#123; // ......... // &#125; 全局作用域里 this ---&gt; 指向 window 123&gt; this&lt;· Window&#123;......&#125; call / apply 可以改变函数运行时的 this 指向 obj.func(); func()里面的 this 就指向谁 总结 1234567891011121314151617181920212223242526272829303132例: var name : '222'; var a = &#123; name : '111', say : function()&#123; console.log(this.name); &#125; &#125; var fun = a.say; fun() // 222 a.say() // 111 var b = &#123; name : '333', say : function(fun)&#123; fun(); &#125; &#125; b.say(a.say); // 222 b.say = a.say; b.say(); // 333 // 分析： // a.say 是 function 函数体 function(fun)&#123; // this --&gt; b // console.log(this) --&gt; b fun(); &#125; // fun()空执行，走预编译 // 在 b.say(a.say)中 // a.say 当作参数传进来了 12345678var obj = &#123; a : function()&#123; console.log(this.name); &#125;, name : 'abc'&#125;obj.a(); 笔试真题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263例1：下面这段代码执行完毕后，x,y,z的值分别是多少？ var x = 1, y = z = 0; function add(n)&#123; return n = n + 1; &#125; y = add(x); function add(n)&#123; return n = n + 3; &#125; z = add(x);// 答案：1，4，4; 同一个函数，后面的肯定会覆盖前面的，因为预编译会覆盖例2：下面代码中 console.log 的结果是[1,2,3,4,5]的选项是： A. function foo(x)&#123; console.log(arguments); return x; &#125; foo(1,2,3,4,5); B. function foo(x)&#123; console.log(arguments); return x &#125;(1,2,3,4,5) C. (function foo(x)&#123; console.log(arguments); return x; &#125;)(1,2,3,4,5) D. function foo()&#123; bar.apply(null,arguments); &#125; function bar(x)&#123; console.log(arguments); &#125; foo(1,2,3,4,5)// 答案：A、C、D 其中b执行不了，但是不报错，bar里面传了一下参数。bar.apply(null,arguments); 写成 bar(arguments);例3：一行文本，水平垂直居中 // 答案：height = line height; text-align:center例4：请问以下表达式的结果是什么？ parseInt(3,8) parseInt(3,2) parseInt(3,0) A.3,3,3 B.3,3,NaN C.3,NaN,NaN D.other // 答案:C 或 D（有的浏览器 0 进制报错，有的不报错）例5：以下那些是 javascript 语言 typeof 可能返回的结果 A. string B.array C.object D.null //答案：A、C (typeof 只能返回 number、string、undefined、boolean、object、function)例6：javascript 的 call 和 apply 方法是做什么的？两者有什么区别 Wheel.apply(this,[wheelSize,style]); Wheel.call(this,wheelSize,style); //答案：call 和 apply 的作用都是改变 this 指向的，不过两个的传参列表不同，apply 只能传一个实参，而且必须传数组 arguments例7：看看下面 alert 的结果是什么？ function b(x,y,a)&#123; arguments[2] = 10; alert(a); &#125; b(1,2,3); // 如果函数体改成下面，结果会是怎么样 a = 10; alert(arguments[2]); //答案：10，10例8：逗号操作符，这种情况，会先看一眼1，再看一眼2，然后返回2，就是2 var f = ( function f()&#123; return '1'; &#125;, function g()&#123; return 2; &#125; )(); typeof f; // 在控制器中输出： // &gt; 1,2 // &lt;· 2 // &gt; var num = (1,2); // &lt;· 2例9： var x = 1; if(function f()&#123; x += typeof f; &#125;) console.log(x); // 分析：用括号把 function f()&#123;&#125; 转换成一个表达式，就会被立即执行了，就找不到了，因为 function f() &#123;&#125; 肯定是 true，所以会执行 &#123;&#125;，但是 typeof 中的 f 已经找不到了 // 答案：1undefined例10：以下哪些表达式的结果为true的 A.undefined == null B.undefined === null C.isNaN('100') D.parseInt('1a') == 1 // 答案：A、C、D isNaN('100')意思是这个数经过 number 转换后是不是NaN C。function myIsNaN(num)&#123; var ret = Number(num); ret += ''; if(ret == 'NaN')&#123; return true; &#125;else&#123; return false; &#125; &#125; // 从控制台输出： // &gt; myIsNaN('123') // &lt;· false // &gt; myIsNaN('NaN') // &lt;· true例10：引用值比的是地址 &gt; &#123;&#125; == &#123;&#125; &lt;· false &gt; var obj = &#123;&#125; &lt;· undefined &gt; var obj1 = obj &lt;· undefined &gt; obj1 == obj &lt;· true &gt; obj1 == obj &lt;· true例11： var foo = '123'; function print()&#123; var foo = '456'; this.foo = '789'; console.log(foo); &#125; print(); // 456 // 把上面的题变形 var foo = 123; function print()&#123; this.foo = 234; console.log(foo); &#125; print(); // 答案打印 234，要 console.log(foo);是全局的 foo，但是这里 this.foo 的 this是指向全局 window 的，相当于就把外面的 123 改成了 234 // 在变形一下 var foo = 123; function print()&#123; // var this = Object.creat(print.prototype) this.foo = 234; console.logf(foo); &#125; new print(); // 答案:123 //，new 了以后，隐式 var this = Object.create(print.prototype)这时候 this.foo 不 再指向 window，转而指向 var this，所以打印的时候找不到 234，就到全局找到 123例12：运行 test() 和 new test() 的结果分别是什么？ var a = 5; function test()&#123; a = 0; alert(a); alert(this.a); var a; alert(a); &#125; test(); // 答案：0，5，0 // new test() 之后是 0，undefined，0 // 分析: 【之前其中 this.a 指代的是 window，所以是 0，5，0】 // 【之后，因为 this 上没有 a ,所以打印 undefined】例13： function print()&#123; console.log(foo); var foo = 2; console.log(foo); console.log(hello); &#125; print(); // 答案：undefiend,2,hello is no defined(报错，因为hello 没有被定义，所以报错)例14： function print()&#123; var test; test(); function test()&#123; console.log(1); &#125; &#125; print(); // 答案 1例15： function print()&#123; var x= 1; if(x == '1')&#123; console.log('One!') &#125; if(x === '1')&#123; console.log('Two!') &#125; &#125; // 答案：One例16： function print()&#123; var marty = &#123; name : 'marty', printName : function()&#123; console.log(this.name); &#125;, &#125; var test1 = &#123;name : \"test1\"&#125;; var test2 = &#123;name : 'test2'&#125;; var test3 = &#123;name : 'test3'&#125;; test3.printName = marty.printName; var printName2 = marty.printName.bind(&#123;name:123&#125;);//做不了 marty.printName.call(test1); marty.printName.apply(test2); marty.printName(); printName2(); test3.printName(); &#125; print(); // 答案：test1，test2，marty，做不了有bind，test3例17： var bar = &#123;a : '002'&#125;; function print()&#123; bar.a = 'a'; Object.prototype.b = 'b'; return function inner()&#123; console.log(bar.a); console.log(bar.b); &#125; &#125; print()(); // 答案：a,b // print()() 第一个括号返回的是一个函数，第二个再来函数执行 arguments.callee、function.callerarguments.callee 指向函数的引用(函数自己) function.caller 返回执行程序的坏境名称 一、callee1234567891011121314151617181920212223242526272829303132例1： function test()&#123; console.log(arguments.callee); &#125; test(); // 答案：test例2： function test()&#123; console.log(arguments.callee == test); &#125; test(); // 答案:true例3：我们要初始化数据，是100以内的阶乘，用立即执行函数找自己的引用来解决 var num = (function(n)&#123; if(n == 1)&#123; return 1; &#125; return n * arguemtns.callee(n - 1); &#125;)(100)例4： function test()&#123; console.log(arguments.callee); function demo()&#123; console.log(arguemtns.callee); &#125; demo(); // demo &#125; test(); // test // 在那个函数里面的 argument.callee 就指代了哪个函数 二、callercaller 是他在哪个环境执行，就返回哪个环境的名字，不能再arguments里面 1234567891011function test()&#123; demo();&#125;function demo()&#123; console.log(demo.caller);&#125;test();// demo 被调用的环境是 test// 所以这个 caller 指代的 test 克隆浅层克隆 深层克隆 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586例1：这个是做的浅层克隆 var obj = &#123; name : 'abc', age : 123, sex : 'female' &#125; var obj1 = &#123;&#125; function clone(origin,target)&#123; for(var prop in origin)&#123; target[prop] == origin[prop]; &#125; &#125; clone(obj,obj1); // 在控制台输出： // &gt; obj // &lt;· Object&#123;name : 'abc',age : 123,sex : 'female'&#125; // &gt; obj1 // &lt;· Object&#123;name : 'abc',age : 123,sex : 'female'&#125;把上面的改一下，写一个兼容性的写法，为了防止用户不传 target（容错），给了参数就直接用，不给就当空对象，见下方： var obj = &#123; name : 'abc', age : 123, sex : 'female' &#125; var obj1 = &#123;&#125; function clone(origin,target)&#123; var target = target || &#123;&#125;; for(var prop in origin)&#123; target[prop] == origin[prop]; &#125; return target; &#125; clone(obj,obj1); // 在控制台输出： // &gt; obj // &lt;· Object&#123;name : 'abc',age : 123,sex : 'female'&#125; // &gt; obj1 // &lt;· Object&#123;name : 'abc',age : 123,sex : 'female'&#125; // &gt; obj.name = 'bcd'; // &lt;· 'bcd' // &gt; obj1.name // &lt;· 'abc'例2： var obj = &#123; name : 'abc', age : 123, sex : 'female', card : ['visa','unionpay'] &#125; var obj1 = &#123;&#125; function clone(origin,target)&#123; var target = target || &#123;&#125;; for(var prop in origin)&#123; target[prop] == origin[prop]; &#125; return target; &#125; clone(obj,obj1); // 在控制台输出： // &gt; obj1 // &lt;· Object&#123;name : 'abc',age : 123,sex : 'female'&#125; // card : Array[2] // &gt; obj1.card.push('master') // &lt;· 3 // &gt; obj1.crad // &lt;· &#123;'visa','unionpay','master'sss&#125; // &gt; obj // &lt;· Object&#123;name : 'abc',age : 123,sex : 'female',card : Array[3]&#125; // &gt; obj.card // &lt;· ['visa','unionpay','master']现在我们想实现深度克隆（只考虑数组和对象），copy过去后，我改，但是你不会改， 引用值不能直接拷贝 思考上一道题做深度克隆，分析它是什么，建立是什么，收尾需要要给递归，提示： 1234567例: obj = &#123; card: [\"visa\", \"unionpay\", [1, 2]]&#125;;var obj1 = &#123; card: [obj.card[0], obj.card[1], []]&#125;; 作业：做一个深度克隆（copy后，各自独立，互不影响） 思路：需要一个分析环节，分析是什么，是原始值就按原来的方法拷贝过来，是引 用值就分析是数组还是对象。如果是数组，就新建一个数组；如果是对象，就新建一个对象。再一层层看，里面有一个递归。引用值不能直接拷贝，引用值拷贝的是 地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var obj = &#123; name : 'abc', age : 123, card : ['visa','master'], wife : &#123; name : 'bcd', son : &#123; name : 'aaa' &#125; &#125;&#125;var obj1 = &#123;&#125;function deepClone(origin, target) &#123; var target = target || &#123;&#125;, // 有就用你的，没有就用后面的 toStr = Object.prototype.toString, // 引用，目的是简化 arrStr = '[Object Array]'; // 引用，目的是简化比对 for (var prop in origin) &#123; // 从原始 origin 拷贝到 target if (origin.hasOwnProperty(prop)) &#123; // 先判断是不是原型上的属性，如果是 false 就是原型上的 if (typeof (origin[prop]) !== 'null' &amp;&amp; typeof (origin[prop]) == 'object') &#123; if ((toStr.call(origin[prop])) == arrStr) &#123; target[prop] = []; &#125; else &#123; target[prop] = &#123;&#125;; &#125; deepClone(origin[prop], target[prop]); &#125; else &#123; // else 后面是原始值 target[prop] = origin[prop]; &#125; &#125; &#125; return target;&#125;// 分析：var obj = &#123; name : 'abc', agfe : 123, card : ['visa','master'] //原始对象 wife : &#123; name : 'bcd', son : &#123; name : 'aaa' &#125; &#125;&#125;var obj1 = &#123; name : 'abc', age : 123, card : [obj.card[0],obj.card[1]], // 要拷贝的对象，进行 obj 里面的数组，对这个数组的拷贝再一次拷贝 wife : &#123; name : 'bcd', son : &#123; name : 'aaa' &#125; &#125;&#125; 12345678910111213141516深度克隆的步骤： 1. 先把所有的值都遍历一遍（看是引用值和原始值） 用for(var prop in obj),对象和数组都可以使用 2. 判断是原始值，还是引用值？用typeof判断是不是object 1) 如果是原始值就直接拷贝 2) 如果是引用值，判断是数组还是对象 3. 判断是数组还是对象？（方法 intanceof 【看 a 的原型链上有没有 b 的原型链】、toString、constructor,建议用 toString，另外两个有个小 bug ———— 跨父子域不行） 1）如果是数组，就新建一个空数组 2）如果是对象，就新建一个空对象 4. 建立了数组以后，如果是挨个看原始对象里面是什么，都是原始值就可以直接拷过来了；或者，建立了对象以后，挨个判断对象里面的每一个值，看是原始值还是引用值 5. 递归 三目运算符形式：?（问号）前面是一个条件判断，判断true就执行:（冒号）前面的；false就执行:（冒号）后面的，并且返回值 条件判断 ? 是 : 否 并且会返回值 三木运算符是 简化 版的if（条件判断）{是在这里}else{否在这里} 12345678910111213141516var num = 1 &gt; 0 ? 2 + 2 : 1 + 1;// 答案：4var num = 1 &lt; 0 ? 2 + 2 : 1 + 1;// 答案：2var num = 1 &gt; 0 ? ('10' &gt; 9 ? 1 : 0) : 2;// 答案：2var num = 1 &gt; 0 ? ('10' &gt; '9' ? 1 : 0) : 2;// 答案：0// 分析：因为 '10' &gt; '9' 比的是 ASCII 码，一位位比，10（一零）小于 9 ，先用 1 和 9 比，在 ASCII 码里面 1 小于 9；// 当“10” &gt; 9 字符串和数字比，会先转换成数字再比较 123456789101112131415161718192021222324252627282930313233343536// 可利用三木运算符简化克隆代码var obj = &#123; name : 'yu', age : 18, card : ['visa','master'], wife : &#123; name : 'Long', age : 18, son : &#123; lastName : 'YU' &#125; &#125;&#125;var obj1 = &#123;&#125;function deepClone(origin,target)&#123; var target = target || &#123;&#125;, toStr = Object.prototype.toString, arrStr = '[Object Array]' for(var prop in origin)&#123; if(origin.hasOwnProperty(prop))&#123; if(origin[prop] !== 'null' &amp;&amp; typeof(origin[prop]) == 'object')&#123; target[prop] = (toStr.call(origin[prop]) == arrStr) ? [] : &#123;&#125;; deepClone(target[prop],origin[prop]); &#125;else&#123; target[prop] = origin[prop]; &#125; &#125; &#125; return target;&#125;deepClone(obj,obj1); (数组)预习定义对象方式：自变量，构造函数，自定义的构造函数，Object.create 123456789定义数组的方式： 1. var arr = []; 数组自变量（自定义）； 2. var arr = new Array(); 系统提供 两者区别就只一位数的情况 数组能用的方法来源于 Array.prototype 12345678910111213var arr = [];如果写出 var arr = [1,,1],出来就是 1,undefined*1,1数组不是每一位都有值，稀疏数组var arr = [1,2,3,4,5];var arr = new Array(1,2,3,4,5);和自定义数组显示效果一样// 系统提供的数组和自定义的数组有一点不同，如下var arr = new Array(10);长度为10的稀疏数组，括号里面只有一位数，就代表着长度，并且里面每一位都没有值，console 里面会是 undefined * 10。并且里面不能写小数，会报错。 数组的读和写，基本上没有报错的情况，除非是引用了没有的方法 js数组是基于对象的，数组是一种特殊的对象 12345678&gt; arr[10] = 'abc'&lt; 'abc'&gt; arr&lt; [undefined * 10,'abc']&gt; arr.length&lt; 11 数组一、数组的定义（来源于 Array.prototype）1）系统提供 new Array(length / content) var arr = new Array(1,2,3,4,5) 2）自变量 var arr = [1,2,3,4,5]; 二、数组的 ‘读’ 和 ‘写’arr[num] // 不可以溢出读，结果 undefiend arr[num] = XXX; // 不可以溢出读 arr[num] = xxx; // 可以溢出读 12345678910es3.0 最标准最基础es5.0 es6.0，最新的 es7.0还没有普及，今天讲的都是 es3.0对象的定义方式1 自变量2 构造函数3 自定义构造函数4 object.create 数组是一种特殊的对象，在本质上两者没有太大的区别 1234567891011121314151617181920212223242526可以写 var arr = [,] // 稀松数组，相当于定义了两个位置，console(控制台 结果是 undefiend)var arr = [1,2,,,,3,4]; // 答案[1, 2, undefiend * 3, 3, 4] // arr.length = 7var arr = []; 和 var arr = new Array(); 唯一的区别实在 var arr = new Array(); 只传了一个参数的情况下，会被当成长度，并且成为一个稀松数组 var arr = new Array(10); // [undefined * 10] var arr = [10]; // [10] 如果传进去一个小数，就非法：var arr = new Array(10.2); // 报错 var arr = []; // &gt; arr[10] // &lt;· undefined // &gt; arr[10] = 'abc' // &lt;· 'abc' // &gt; arr // &lt;· [undefined * 10, 'abc'] // &gt; arr.length // &lt;· 11 数组的常用方法一、改变原数组（在原来数组基础上去改变）1）reverse，sort，push，pop，unshift，shift 2）splice push12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061`push``push 在数组的最后一位添加数据，可以添加一个，也可以添加很多个`例1： var arr = []; // 在控制台操作： // &gt; arr.push(10) // &lt;· 1 // &gt; arr // &lt;· [10] // &gt; arr.push(11) // &lt;· 2 // &gt; arr // &lt;· [10,11] // &gt; arr.push(9) // &lt;· 3 // &gt; arr // &lt;· [10,11,9] // &gt; arr.push(1,2,3,4,5,6,7) // &lt;· 7 // &gt; arr // &lt;· [1,2,3,4,5,6,7]例2： // 说明能重写 var arr = []; Array.prototype.push = function()&#123; return 'haha'; &#125; // 在控制台操作： // &gt; arr.push() // &lt;· 'haha'例3：数组有三位，想在数组的最后一位添加东西 var arr = [1,2,3]; 如果在第四位加东西写成 arr = [3] // length - 1 位添加东西 var arr = [1,2,3]; Array.prototype.push = function()&#123; for(var i = 0;i &lt; arguments.length; i ++)&#123; this[this.length] = arguments[i]; &#125; return this.length; &#125; // 在控制台操作： // &gt; arr.push(4,5,6) // &lt;· 6 // &gt; arr // &lt;· [1,2,3,4,5,6]`Array.prototype.push = function()&#123;&#125; 不能写形参` pop123456789101112131415161718192021222324252627282930313233`pop``pop 是剪切方法（把最后一位数剪切出去）。在 pop() 括号里面不能传参，写了会忽略`例1： var arr = [1,2,3]; // 在控制台操作： // &gt; arr.pop() // &lt;· 3 // &gt; arr // &lt;· [1,2] // &gt; arr.pop() // &lt;· 2 // &gt; arr // &lt;· [1] // 在控制台操作： // &gt; var num = arr.pop() // &lt;· undefined // &gt; num // &lt;· 3 // 在控制台操作： // &gt; arr.pop(2) // &lt;· 3 // &gt; arr // &lt;· [1,2] unshift12345678910111213141516171819`unshift``unshift 是从第一位加东西` var arr = [1,2,3]; // 从 console 操作： // &gt; arr.unshift(0) // &lt;· 4 // &gt; arr // &lt;· [0,1,2,3] // &gt; arr.unshift(-1,0) // &lt;· 5 // &gt; arr // &lt;· [-1,0,1,2,3] shift12345678910111213141516171819202122`shift``shift 是从第一位减东西`例1： var arr = [1,2,3]; // 从 console 操作： // &gt; arr.shife() // &lt;· 1 // &gt; arr // &lt;· [2,3]例2：数组不能从 -1 位插入东西 // 从 console 操作： // &gt; arr[-1] = 0 // &lt;· 0 // &gt; arr // &lt;· [1,2,3] // 可以用两个数组拼接成一个数组的方式添加东西 reverse12345678910111213141516`reverse``reverse 逆反` var arr = [1,2,3]; // 从 consolel 操作 // &gt; arr.reverse() // &lt;· [3,2,1] // &gt; arr.reverse() // &lt;· [1,2,3] // &gt; arr // &lt;· [1,2,3] splice123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263`splice``splice 一种剪切，切片``arr.splice(从第几位开始，截取多少长度，传参在切口处添加新的数据)`例1： var arr = [1,1,2,2,3,3]; arr.splice(1,2) //从第 1 位开始截取 2 位，传参可以不填 // 截取的是[1,2] // 从 consolel 操作 // &gt; arr.splice(1,2) // &lt;· [1,2] // &gt; arr // &lt;· [1,2,3,4] // &gt; arr.splice(0,3) // &lt;· [1,1,2] // &gt; arr // &lt;· [2,3,3] // &gt; arr.splice(1,1,0,0,0) // &lt;· [1] // 从 consolel 操作 // &gt; arr.splice(0.3) // &lt;· [1,0,0,0,2,2,3,3]例2： arr.splice(1,1,0,0,0); //意思是从第 1 位起截取 1 位，然后加上0，0，0这三个数例3： var arr = [1,2,3,5]; //1是第0位，2是第1位, 3是第2位，5是第3位 arr.splice(3,0,4); // 答案：[1,2,3,4,5];例4： var arr = [1,2,3,4]; arr.splice(-1,1); // 这里的 -1 是倒数第一位，数组一般的方法都可以带负数 // 答案：[1,2,3];例5：下面是系统内部解决附属问题的兼容 var arr = [1,2,3,4]; splice = function (pos)&#123; pos += pos &gt; 0 ? 0 : this.length; &#125; // -1 + 4 = 3例6： function(i)&#123; var len = this.length, j = +i + (i &lt; 0 ? len : 0); return this.pushStack(j &gt;= &amp;&amp; j &lt; len ? [this [j] ]d : []) &#125; // splice = function (pos)&#123; // pos += pos &gt; 0 ? 0 : this.length; pos &gt;= 0 || pos &lt; // &#125; sort123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170`sort``sort 给数组排序，（按照从小到大），改变原数组`例1： var = [1,3,4,0,-1,9]; // 从 consolel 操作 // &gt; arr.sotr() // &lt;· [-1,0,1,3,4,9] // 在sort后面加 reversve 就是降序 // &gt; arr.sotr().reverse() // &lt;· [9,4,3,1,0,-1]例2：下面这个按照 ASCII 码排序的 var arr = [1,3,5,4,10]; // 从 consolel 操作 // &gt; arr.sotr() // &lt;· [-1,10,3,4,5]`所以给我们留了一个接口，如下1 必须写两形参2 看返回值 return 1）当返回值为负数时，那么前面的数放在前面， 2）当返回值为正数时，那么后面的数在前， 3）为0，不动`例1： var arr = [1,3,5,4,10]; arr.sort(function(a,b)&#123; if(a &gt; b)&#123; return 1; &#125;else&#123; return -1; &#125; &#125;); return 1; //此处的 1代表返回正的 return -1; return -1 //此处的-1 代表返回负的`思维方式:上面就控制了升序这个函数第一次调动时，会把数组的第一位和第二位传进来，也就是 a=1，b=3，然 后通过规则比较，当你把返回值返回为正，为负，为 0。传参的顺序（但是这个顺序是位置的顺序，不是按数字比），第一次是1,3，第二次 1,5,第三次1,4,第四次 1,10，第五次 3,5,第六次3,4,第七次 3,10，第八次 5,4，第九次 5,10，第十次 4,10；依次传参（符合冒号排序的算法）是以换位置的方式改变顺序`例2：var arr = [2,13,19,4]; // 到 13 这一位的时候，换位置变成了[2,4,19,13]例3：下面变成了降序 var arr = [2,10,20,13,4,8,9]; arr.sort(function(a,b)&#123; if(a &lt; b)&#123; return 1; &#125;else&#123; return -1; &#125; &#125;)例4： `升序简化版` var arr = [20,2,10,13,4,8,9]; arr.sort(function(a,b)&#123; if(a - b &gt; 0)&#123; return a - b; &#125;else&#123; return a - b; &#125; &#125;) `再简化版` var arr = [20,2,10,13,4,8,9]; arr.sort(function(a,b)&#123; return a - b; &#125;)`升序 return a - b``降序 return b - a`例5：直接调用 arr.sort() 比的是 ASCII 码，要在里面填函数才可以 var arr = [20,2,10,13,4,,8,9]; arr.sort(function(a,b)&#123; // return a - b; 升序 // return b - a; 降序 return b - a; &#125;) // 从 consolel 操作 // &gt; arr // &lt;· [20,13,10,9,8,4,2]; // &gt; arr.sort(function()&#123;&#125;)例6：给一个有序的数组，让它乱序，当我们没规律可以遵循的时候，返回时是随机的 var arr= [1,2,3,4,5,6,7]; arr.sort(function()&#123; return Math.random() - 0.5; &#125;); // Math.random() 回生成一个 0 到 1 （包括 0，但是不包括 1）的随机数例7：给以下按照年龄排序 var cheng = &#123; name : 'cheng', age : 18, sex : 'male', face : 'handsome' &#125; var deng = &#123; name : 'deng', age : 40, sex : undefined, face : 'amazing' &#125; var zhang = &#123; name : 'zhang', age : 20, sex : 'male', &#125; var arr = [cheng,deng,zhang]; arr.sort(function(a,b)&#123; if(a.age &gt; b.age)&#123; return 1; &#125;else&#123; return -1; &#125; &#125;) // 简化 var arr = [cheng,deng,zhang]; arr.sort(function(a,b)&#123; return a.age - b.age; &#125;)例7：按照字符串长度排序 var arr = ['ab','abcde','abcd','abcdefg',,'abcdef''abc']; arr.sort(function(a,b)&#123; return a.length - b.length; &#125;)例8：按照字节长度排序 function retBytes(str)&#123; var num = str.length; for(var i = 0; i &lt; str.length; i ++)&#123; if(str.chatCode(i) &gt; 255)&#123; num ++; &#125; &#125; return num; &#125; var arr = ['ac','alkdjf于lkajsd','aksd泽jfk','iuwe龙oiru','dddd','aaa']; arr.sort(function(a,b)&#123; return retBytes(a) - retBytes(b); &#125;) 二、不改变原数组1）forEach，filter，map，reduce，reduceRight 2）slice，concat，join ————&gt; split，toString concat1234567891011121314`concat``concat 连接，把后面的数组拼接到前面，并成立一个新的数组，不影响之前的两个数组，不能改变原数组`;例: var arr = [1, 2, 3, 4, 5, 6];var arr1 = [7, 8, 9];// 从 console 操作：// &gt; arr.concat(arr1)// &lt;· [1,2,3,4,5,6,7,8,9]// &gt; arr// &lt;· [1,2,3,4,5,6]// &gt; arr1// &lt;· [7,8,9] `toString12345678910`toString``toString 是把数组当作字符串展示出来` var arr = [1,2,3,4,5,6] // 从 console 操作： // &gt; arr.toString() // &lt;· '1,2,3,4,5,6' 123456789101112131415161718192021222324252627282930313233343536373839`slice``slice 从该位开始截取，截取到该位，并不改变原数组，这里也可以写负数` var arr = [1,2,3,4,5,6]; // slice(从改位开始截取，截取到该位) // 从 console 操作： // &gt; arr.slice(1,2) // &lt;· [2] // &gt; arr // &lt;· [1,2,3,4,5,6] `slice 并不改变原数组，slice完了以后需要有东西接受，不然没有意义` var arr = [1,2,3,4,5,6]; // slice(从改位开始截取，截取到该位) var newArr = arr.slice(1,3); // 从 console 操作： // &gt; newArr // &lt;· [2,3]// 从 console 操作： // &gt; newArr // &lt;· [2,3]`slice 里面可以填 0 个参数，也可以填 1 个参数，也可以填两个参数1. 如果填两个参数，slice（从该位开始截取，截取到该位） 如：arr.slice(1,2)，从第一位开始截取，截取到第二位2. 如果填一个参数，从第几位开始截取，一直截取到最后。 如：arr.slice(1)，从第 1 位开始截取，截取到最后一位3. 不写参数就是整个截取数组（把类数组转换成数组的时候经常用）` join12345678910111213141516`join``join 括号里面需要用字符串形式（标准语法规定），就会用加的东西连接起来数组` var arr = [1,2,3,4,5,6]; // 从 console 操作： // &gt; arr.join('-') // &lt;· [1-2-3-4-5-6] // &gt; arr.join('!') // &lt;· [1!2!3!4!5!6] // &gt; arr.join('~') // &lt;· [1~2~3~4~5~6] split1234567891011121314151617181920212223242526272829303132333435363738394041424344`split``split() 是string字符串方法 是 join() 方法的可逆方法，join方法是输入什么连接什么，split是输入什么拆分什么` var arr = [1,2,3,4,5,6]; var str = arr.join('-'); // 从 console 操作： // &gt; str.split('4') // &lt;· ['1-2-3-' , '-5-6'] // &gt; str // &lt;· '1-2-3-4-5-6' // &gt; str.split('-') // &lt;· ['1','2','3','4','5','6']`split 按照什么拆分为数组。用什么拆，什么就没了，按 - 拆就去掉了，按 4 拆就去掉了4.split 可以返回数组，数组可以返回字符串`把下面啊字符串拼到一起 var str = 'alibaba'; var str1 = 'baidu'; var str2 = 'tencent'; var str3 = 'toutiao'; var str4 = 'wangyi'; var str5 = 'xiaowang'; var str6 = 'nv';// 下面这种写法不好，字符串是在栈内存里面的，先进后出 var str Final = ''; var arr = [str,str1,str2.str3,str4]; for(var i = 0;i &lt; arr.length; i ++)&#123; strFinal += arr[i]; &#125;// 用下面这种方式更好，join 里面不传参默认用逗号连接，传空串如下图 // 散列 var arr = [str,str1,str2,str3,str4,str5,str6]; console.log(arr.join('')); forEach() – 循环遍历数组forEach(function(ele,index,array){}) -- 循环遍历数组 参数： ele : 循环遍历的每一个当前元素对象 （第 1 个参数，什么变量都可以） index : 相当于for循环的那个 i，当前在表中操作的当前项的索引。，遍历第一遍：0，第二遍：1 （第 2 个参数，什么变量都可以） array : 当前元素所属的数组对象。相当于this，就是调用的是那个数组，一般用不到 （第 3 个参数，什么变量都可以） 1234567891011121314var personArr = [ &#123;name: '王港', src:'./img/3.png',des:'颈椎不好',sex:'m'&#125;, &#123;name: '刘莹', src:'./img/5.png',des:'我是谁',sex:'f'&#125;, &#123;name: '王秀莹', src:'./img/4.png',des:'我很好看',sex:'f'&#125;, &#123;name: '刘金雷', src:'./img/1.png',des:'陌生的脸',sex:'m'&#125;, &#123;name: '刘飞翔', src:'./img/2.png',des:'六六六',sex:'m'&#125;,]personArr.forEach(function(ele,index,array)&#123;// ele : 循环遍历的每一个元素对象// index : 相当于for循环的那个 i，代表索引，遍历第一遍：0，第二遍：1// array : 相当于this，就是调用的是那个数组，一般用不到 console.log(ele); // 打印出循环遍历的每一位&#125;) 12345678910forEach的源码剖析：Array.prototype.myForEach(func)&#123; for(var i = 0;i &lt; this.length;i ++)&#123; func(this[i],i); &#125;&#125;// break不能使用，因为break在源码中不是写到for循环里面，而是写到了func函数里面// return不能使用，因为return的话，就只是在return的那个遍历的对象不执行了，直接跳到下一个遍历对象执行 filter – 筛选元素fliter 筛选，和 forEach 一样会遍历循环，也有三个参数，不过筛选出来的值由 return 来决定 filter 循环遍历筛选，返回判断是 true 的值，然后return出来，false，丢掉 filter(function(ele,index,array){}) -- 循环遍历筛选数组 参数： ele : 循环遍历的每一个当前元素对象 （第 1 个参数，什么变量都可以） index : 相当于for循环的那个 i，当前在表中操作的当前项的索引。，遍历第一遍：0，第二遍：1 （第 2 个参数，什么变量都可以） array : 当前元素所属的数组对象。相当于this，就是调用的是那个数组，一般用不到 （第 3 个参数，什么变量都可以） 意思是现在循环遍历的数组，如果循环遍历的返回值是true的话，就留下,如果说 返回如果循环遍历的返回值是false的话，就不要了。并且把所有返回true的数组（元素）放到到一个新的数组里面，所以说 filter 会有返回一个结果，这个结果就是 filter 筛选出来的元素组合成的一个新的数组。 12345678910111213141516171819var personArr = [ &#123;name: '王港', src:'./img/3.png',des:'颈椎不好',sex:'m'&#125;, &#123;name: '刘莹', src:'./img/5.png',des:'我是谁',sex:'f'&#125;, &#123;name: '王秀莹', src:'./img/4.png',des:'我很好看',sex:'f'&#125;, &#123;name: '刘金雷', src:'./img/1.png',des:'陌生的脸',sex:'m'&#125;, &#123;name: '刘飞翔', src:'./img/2.png',des:'六六六',sex:'m'&#125;,]var newArr = personArr.filter(function(ele,index)&#123;// ele : 循环遍历的每一个元素对象// index : 相当于for循环的那个 i，代表索引，遍历第一遍：0，第二遍：1// array : 相当于this，就是调用的是那个数组，一般用不到 return true;// 这个返回的可以是任何东西，只要转换完成之后不是 空 就可以。 // 意思是现在循环遍历的数组，如果循环遍历的返回值是true的话，就留下 // 如果说 返回如果循环遍历的返回值是false的话，就不要了。 // 并且把所有返回true的数组（元素）放到到一个新的数组里面&#125;)console.log(newArr);// 打印筛选的元素组成的新数组 123456789101112131415161718判断false和true:var personArr = [ &#123;name: '王港', src:'./img/3.png',des:'颈椎不好',sex:'m'&#125;, &#123;name: '刘莹', src:'./img/5.png',des:'我是谁',sex:'f'&#125;, &#123;name: '王秀莹', src:'./img/4.png',des:'我很好看',sex:'f'&#125;, &#123;name: '刘金雷', src:'./img/1.png',des:'陌生的脸',sex:'m'&#125;, &#123;name: '刘飞翔', src:'./img/2.png',des:'六六六',sex:'m'&#125;,]var newArr = personArr.filter(function(ele,index,array)&#123; if(ele.sex == 'f')&#123; // 可以来判断true和false return true; &#125;else&#123; return false; &#125;&#125;)console.log(newArr); // [&#123;…&#125;, &#123;…&#125;]，两个女生 12345678910filter源码剖析：Array.prototype.myfilter = function(func)&#123; var arr = []; for(var i = 0;i &lt; this.length;i ++)&#123; if(func(this[i],i))&#123; arr.push(this[i]); &#125; &#125; return arr;&#125; map – 循环遍历数组，返回 true 的结果map 直接由 return 返回出来的值来返回，把当前 return 返回的值放到新的数组当中 map 返回结果，和 forEach和filter 一样会遍历循环，也有三个参数，功能也一样，不过筛选出来的值由 return 返回出来的结果来决定，就是 return 每一次返回的值是什么，就返回什么每一次的结果 map(function(ele,index,array){}) -- 循环遍历筛选数组 参数： ele : 循环遍历的每一个当前元素对象 （第 1 个参数，什么变量都可以） index : 相当于for循环的那个 i，当前在表中操作的当前项的索引。，遍历第一遍：0，第二遍：1 （第 2 个参数，什么变量都可以） array : 当前元素所属的数组对象。相当于this，就是调用的是那个数组，一般用不到 （第 3 个参数，什么变量都可以） 12345678910111213141516171819var personArr = [ &#123;name: '王港', src:'./img/3.png',des:'颈椎不好',sex:'m'&#125;, &#123;name: '刘莹', src:'./img/5.png',des:'我是谁',sex:'f'&#125;, &#123;name: '王秀莹', src:'./img/4.png',des:'我很好看',sex:'f'&#125;, &#123;name: '刘金雷', src:'./img/1.png',des:'陌生的脸',sex:'m'&#125;, &#123;name: '刘飞翔', src:'./img/2.png',des:'六六六',sex:'m'&#125;,]// 给男生加上一个 girF = true，给女生加一个boyF = true;var newArr = personArr.map(function(ele,index)&#123; if(ele.sex == 'm')&#123; ele.girlF = 'true'; return ele; &#125;else&#123; ele.boyF = 'true'; return ele; &#125;&#125;)console.log(newArr); //(5) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;]，五个对象// newArr 和 personArr 的对象来自通过一个地址，你改我也改 12345678`map的源码剖析，浅拷贝`：Array.prototype.myMap = function(func)&#123; var arr = []; for(var i = 0;i &lt; this.length;i ++)&#123; arr.push(func(this[i],i)); &#125; return arr;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849`map的源码剖析，深度拷贝（配合深度克隆来解决）`：Array.prototype.myMap = function (func) &#123; var arr = []; for (var i = 0; i &lt; this.length; i++) &#123; if(this[i] &amp;&amp; typeof this[i] == 'object')&#123; var newObj = &#123;&#125;; deepClone(ownObj,this[i]); arr.push(func(newObj,i)); &#125;else&#123; arr.push(func(this[i], i)); &#125; &#125; return arr;&#125;`深度拷贝（深度克隆）`：function deepClone(target, origin) &#123; var prop, src, copy; if (target !== null) &#123; for (prop in origin) &#123; src = target[prop]; copy = origin[prop]; if (copy &amp;&amp; typeof copy == 'object') &#123; if (Object.prototype.toString.call(copy) == '[object Array]') &#123; src = []; &#125; else &#123; src = &#123;&#125;; &#125; target[prop] = deepClone(src, copy); &#125; else &#123; target[prop] = copy; &#125; &#125; &#125; return target;&#125;var obj1 = &#123;&#125;;var obj2 = &#123; name: 'aimee', hobby: &#123; sing: 'good', dance: 'well' &#125;&#125;deepClone(obj1, obj2);// 这是一个深拷贝的过程，谁改变自己里面的东西，都和另一个对象没有关系 reduce – 累加器（从左向右执行）reduce 从左向右循环遍历数组，累加器（就是把之前遍历的数组），取出来的值只有一个。效率及其高 该方法应用一个函数是&quot;累加器&quot;，并处理列表的每个值（从左到右），以便将其减少到单个值。 reduce 返回结果，一样会遍历循环，有四个参数，它是会等全部循环遍历完成之后，然后在取那个 return 的值，意思就是取最后return出来的那个结果 参数： preValue : 代表上一次回调函数调用返回的值 （第 1 个参数） ele : 循环遍历的每一个当前元素对象 （第 2 个参数，什么变量都可以） index : 相当于for循环的那个 i，当前在表中操作的当前项的索引。，遍历第一遍：0，第二遍：1 （第 3 个参数，什么变量都可以） array : 当前元素所属的数组对象。相当于this，就是调用的是那个数组，一般用不到 （第 4 个参数，什么变量都可以） 12345var arr = [1,2,3,4,5];arr.reduce(function(preValue,ele,index,array)&#123; console.log(preValue); return ele;&#125;,10) // 实参，如果这里不给preValue值的话，preValue就会直接取数组的第一位，ele就取的第二位 1234567累加器:// 为什么说要用 reduce 做累加器呢，因为效率比for循环高var arr = [1,2,3,4,5];var value = arr.reduce(function(preValue,ele,index)&#123; return preValue + ele;&#125;) // 实参，如果这里不给preValue值的话，preValue就会直接取数组的第一位，ele就取的第二位console.log(value); 1234567891011121314reduce 源码剖析：Array.prototype.myReduce = function (func, init) &#123; var previous = init, k = 0; if (init == undefined) &#123; previous = this[0]; k = 1; &#125; for (k; k &lt; this.length; k++) &#123; previous = func(previous, this[k], k); &#125; return previous;&#125; reduceRight 累加器（从右向左）reduce 从右向左循环遍历数组，累加器（就是把之前遍历的数组），取出来的值只有一个。效率及其高 该方法应用一个函数是&quot;累加器&quot;，并处理列表的每个值（从左到右），以便将其减少到单个值。 reduceRight 返回结果，一样会遍历循环，有四个参数，它是会等全部循环遍历完成之后，然后在取那个 return 的值，意思就是取最后return出来的那个结果 参数： preValue : 代表上一次回调函数调用返回的值 （第 1 个参数） ele : 循环遍历的每一个当前元素对象 （第 2 个参数，什么变量都可以） index : 相当于for循环的那个 i，当前在表中操作的当前项的索引。，遍历第一遍：0，第二遍：1 （第 3 个参数，什么变量都可以） array : 当前元素所属的数组对象。相当于this，就是调用的是那个数组，一般用不到 （第 4 个参数，什么变量都可以） 12345var arr = [1,2,3,4,5];arr.reduce(function(preValue,ele,index,array)&#123; console.log(preValue); return ele;&#125;,10) // 实参，如果这里不给preValue值的话，preValue就会直接取数组的第一位，ele就取的第二位 1234567累加器:// 为什么说要用 reduce 做累加器呢，因为效率比for循环高var arr = [1,2,3,4,5];var value = arr.reduce(function(preValue,ele,index)&#123; return preValue + ele;&#125;) // 实参，如果这里不给preValue值的话，preValue就会直接取数组的第一位，ele就取的第二位console.log(value); 1234567891011121314reduce 源码剖析：Array.prototype.myReduce = function (func, init) &#123; var previous = init, k = this.length - 1; if (init == undefined) &#123; previous = this[0]; k = this.length - 2; &#125; for (k; k &gt; this.length; k --) &#123; previous = func(previous, this[k], k); &#125; return previous;&#125; 类数组1. 可以利用属性名模拟数组的特性 2. 可以动态的增长 length 属性 3. 如果强行让类数组调用 push 方法，则会根据 length 属性值的位置进行属性的扩充 1234567891011121314151617181920212223这个看着像数组，但是数组有的方法，他全部都没有，所以他是类数组 function test()&#123; foncole.log(arguments); argumetns.push(7); &#125; test(1,2,3,5,6,7); // 从控制台输出： // &gt; [1,2,3,5,6,7] // &lt;· 报错`类数组长得很像数组，但是没有数组所拥有的方法`。 var obj = &#123; '0' = 'a', '1' = 'b', '2' = 'c' &#125; var arr = ['a','b','c'] // 从控制台输出： // &gt; obj[0] // &lt;· 'a' // &gt; obj[0] // &lt;· 'a' 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101`下面就是类数组的基本形态` var obj = &#123; '0' : 'a', '1' : 'b', '2' : 'c' 'length' : 3, 'push' : Array.prototype.push &#125; // 从控制台输出： // &gt; obj.length('d') // &lt;· 4 // &gt; obj // &lt;· Object&#123;0:'a',1:'b',2:'c',3:'d',length:4&#125;// 分析：在控制台 push('d') 以后，obj的object多了一个 3 : d,长度也变成了 4`类数组：属性要为索引（数字）属性，必须要有 length 属性，最好加上 push 方法。`如果给一个对象加上 splice 方法，那么这个对象就长得像数组了。但是他仍探视对象，但是可以当作数组来用，需要自己添方法。 var obj = &#123; '0' : 'a', '1' : 'b', '2' : 'c', 'length' : 3, 'push' : Array.prototype.push, 'splice' : Array.prototype.splice // 可以把类数组变成数字 &#125; Array.prototype.push = function(target)&#123; thsi[thsi.length] = target; this.length ++; &#125; `如果对象 obj 调用这个方法，那么 this 变成了 obj` Array.prototype.push = function(target)&#123; obj[obj.length] = target; obj.length ++; &#125;阿里巴巴题目，问这个 obj 长什么样子？ bar obj = &#123; '2' : 'a', '3' : 'b', 'length' : 2， 'push' : Array.prototype.push &#125; obj.push('c'); obj.push('d'); // 答案： // obj Object&#123;2:'c',3:'d',length:4&#125;`关键点在 length 上面，根据 length 改变而改变，走一下length，既：`Array.prototype.push = function(taret)&#123; this[obj.length] = target; this.length ++;&#125; var obj = &#123; '1' : 'a', '2' : 'c', '3' : 'd', 'length' : 3, 'push' : Array.prototype.push &#125; obj.push('b'); // 答案：“ 1”：“a”，“2”：“ c”，“ 3”：“b”，“ length”： 4 var obj = &#123; '0' : 'a', '1' : 'b', '2' : 'c', name : 'abc', age : 123, length : 3, push : Array.prototype.push, splice : Array.prototype.splice &#125; // 从 console 输出: // &gt; obj // &lt;· ['a','b','c'] // &gt; obj.name // &lt;· 'abc' // &gt; obj.age // &lt;· 123 // &gt; obj.length // &lt;· 3 // &gt; for(var prop in obj)&#123;console.log(obj[prop])&#125; // &lt;· a // &lt;· b // &lt;· c // &lt;· abc // &lt;· 123 // &lt;· 3 // &lt;· function push()&#123;[native code]&#125; // &lt;· function splice()&#123;[native code]&#125; // &lt;· undefined 作业，练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861. 封装 type 方法达到下面的效果 // 封装 type typeof([]) -- array typeof(&#123;&#125;) -- object typeof(function) -- object typeof(new Number()) -- number Object typeof(123) -- number// console 输出 // &gt; Object.prototype.toString.call(new Number(123)) // &lt;· '[object Number]' // &gt; Object.prototype.toSTring.call(123) // &lt;· '[object Number]';答案: 1. 封装 type （这个方法是一个工具类方法，可以存放在库里面），区分 typeof 方法 1）先分类，原始值，引用值 2）区分引用值，先判断是不是 null 数组，对象，包装类（new number）会返回 object，通过 Object.prototype.toString; 1. function type(target)&#123; var template = &#123; '[object Array]' : 'array', '[object Object]' : 'object', '[object Number]' : 'number - object', '[object Boolean]' : 'boolean - object', '[object String]' : 'string - object' &#125; if(target === null)&#123; return null; &#125; if(typeof(target) == 'function')&#123; return 'function'; &#125;else if(typeof(target) == 'object')&#123; var str = Object.prototype.toString.call(target); return template(str); &#125;else&#123; return typeof(target); &#125; &#125;`简化之后` 2. function type(target)&#123; var template = &#123; '[object Array]' : 'array', '[object Object]' : 'object', '[object Number]' : 'number - object', '[object Boolean]' : 'boolean - object', '[object String]' : 'string - object' &#125; if(target === null)&#123; return null; &#125; if(typeof(target))&#123; var str = Object.prototype.toString.call(target); return template[str]; &#125;else&#123; return typeof(target); &#125; &#125; `进一步简化` function type(target)&#123; var ret = typeof(target); var temp = &#123; '[object Array]' : 'array', '[object Object]' : 'object', '[object Number]' : 'number - object', '[object Boolean]' : 'boolean - object', '[object String]' : 'string - object' &#125; if(target === null)&#123; return null; &#125;else if(ret = 'object')&#123; var str = Object.prototype.toString.call(target); return temolate[str]; &#125;else&#123; return ret; &#125; &#125; 12345678910111213141516171819202122232425262. 数组去重 // 数组去重 var arr = [1,1,1,1,2,2,2,0,0,0,'a','a','b','b'] arr.unique() --&gt; [1,2,0,'a','b']`数组去重(利用对象的特性做数组去重，去重就是去掉重复)思路：写一个对象，把数组的每一位当做对象的属性名。利用对象的特性（同一属性名不可以出现两次），先把第一位当作属性名添加进去，属性值随便写个，在看第一二位，如果第二位在对象里面有属性名，就看下一位，如果对象没有属性名，就把这个值添加进去当属姓名，只看对象的属性名，就去重了，这个方法叫 hash`答案： Array.prototype.unique = function()&#123; var temp = &#123;&#125;, arr = [], len = this.length; for(var i = 0;i &lt; len; i ++)&#123; if(!temp[this[i]])&#123; temp[this[i]] = 'abc'; arr.push(this[i]); &#125; &#125; return arr; &#125;`每一圈循环都要 this.length; 写成 var len = this.length;这样直接放值能少一些运算。 [this[i]]代表数组的第几位。 “abc”可以随便填值（要求是字符串，但是不为 false）， 但是填[this[i]]= [this[i]];在数组有 0 的时候就会有 bug。if 里面取到值什么都不敢，取到 undefined才开始操作，所以写非！，没有值，才处理 ` 复习复习包装类引用值就是一种对象（泛泛的概括类对象），包括数组，函数，对象。在内存里面存储。原始值不能有属性和方法，引用之才可以有，但是经过包装类后，原始值就能有属性和方法。 通过原始值访问属性和方法，系统为了让语法好用，不报错，系统会帮我们进行一个 js 内部机制包装类 123456789101112131415161718 var str = 'abc'; // new String('abc').length console.log(str.length);`思路：即隐式的 new String构造出一个字符串对象，然后把字符串内容与原来保持一 致 new String (‘abc’)，因为我们进行了 str.length 操作，那么他也加上.length，变成 了隐式 new String (‘abc’).length。这里虽然写的是 console.log(str.length)，实际上执 行的是 console.log(new String (‘abc’).length) 这样隐式的执行过程就是包装类。` var num = 123; num.abc = 'abc'; // new Number(num).abc = 'abc'; --&gt; delete // new Number(num).abc; console.log(num.abc);`答案 undefined思路：当num.abc = “abc”时，系统会进行包装类，隐式的 new Number(num).abc = “abc”；执行完这一步以后就会delet 掉这个隐式的值，并不保 留。等下一步又遇到 num.abc 时，又隐式的 new了一个 number。但是这个和上一个 是两个 new Number，是两个彼此独立的对象。``new.Number(123).abc 和 var num = new Number(123); num.abc 是一样的` 复习原型123456789`任何函数都有原型，包括构造函数，这是一个构造函数，原型需要基于构造函数，没有原型的构造函数没有意义，任何一个函数都有 prototype` Person.prototype.lastName = 'deng'; function Pereson()&#123; var this = &#123; __proto__ : Person.prototype &#125; &#125; var person = new Person(); console.log(person.lastName); 复习 creatObject.creat(); 是创造的对象，对象必须要有原型，Object.creat();需要指定创建对象的原型是谁，括号里面就要填谁（所以括号里面一定要估值） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 var demo = &#123; lastName : 'deng' &#125; var obj = Object.creat(demo); obj = &#123; __proto__ : demo &#125;`Object.creat(prototype.definedProperty)还能填第二个参数。第一个填的 prototype 表示你的原型是谁，第二个参数 definedProperty 是特性.(可读可写都是特性)` var num = 123; // 从 console 中控制： // &gt; delete num // &lt;· false // &gt; delete widnow.num // &lt;· false`这个 nun 算是 window 的苏醒。写在全局的属性，一旦经历了 var 的操作，所得出的属性 window，这种属性叫做不可配置的属性，不可配置的属性，delete不掉。直接增加的属性卡叫做可配置属性，delete 只能删除可配置的属性` var obj = &#123;&#125; obj.num; // 从 console 中控制： // &gt; delete obj.num // &lt;· true // &gt; obj // &lt;· Object &#123;&#125;直接在控制台操作对比，发现 var 过的属性是不可配置的属性,delete不掉 // 从 console 中控制： // &gt; window.num = 123 // &lt;· 123 // &gt; delete window.num // &lt;· true // &gt; window.num // &lt;· undefined // &gt; var num = 123; // &lt;· undefined // &gt; window.num // &lt;· 123 // &gt; delete window.num // &lt;· false // &gt; window.num // &lt;· 123 复习 this &amp; call1. 预编译 this --&gt; window 2. 谁调用的，this 指向谁 3. call 和 apply 能改变 this 的指向 4. 全局 this --&gt; window 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798注释掉的是预编译的过程 function test()&#123; var num = 123; function a()&#123; &#125; &#125; // test() --&gt; AO&#123; // arguments : &#123;&#125;， // this : window, // num : undefined, // a : function()&#123;&#125; // &#125;test();完全是等于 test.call();执行，其实 test() 执行会内部转换成 test.call();执行 function test()&#123; console.log(this); &#125; test.call(); // Window如果我们在 test.call();里面传值，第一个值就会作为函数执行时的 this 环境 function test()&#123; console.log(this); &#125; // test(); test.call(&#123;name : 'deng'&#125;); // Object&#123;name : 'deng'&#125; // test() --&gt; AO&#123; // arguments : &#123;&#125;, // this : &#123;name : 'deng'&#125;, // num : undefined, // a : function()&#123;&#125; // &#125; var name = 'window'; var obj = &#123; name : 'obj', say : function()&#123; name : 'obj', console.log(this.name); &#125; &#125; obj.say(); // obj var name = 'window'; var obj = &#123; name : 'obj', say : function()&#123; name : 'obj', console.log(this.name); &#125; &#125; obj.say.call(window); // window`obj.say.call(window);有 call 就打破一切规则，call() 里面传的是谁，就是谁` var name = 'window'; var obj = &#123; naem : 'obj'm say : function()&#123; console.log(this.name); &#125; &#125; var fun = obj.say; fun(); //--&gt; 只能走预编译`var fun = obj.say 先当与 var fun = say : function()&#123;&#125; 里面的函数体``fun(); 相当于让 say : function 在这函数在全局范围内自调用，不是谁调用的，就只能走预编译，this 就是 window` var name = 'window'; var obj = &#123; name : 'obj', say : function()&#123; console.log(this.name); &#125; &#125; var fun = obj.say; fun.call(obj); // obj想让 Person 实现 Student 的功能 function Person(name,age)&#123; this.name = name; this.age = age; &#125; function Student(name,age,sex)&#123; // var this = Object.creat(Student.prototype); this.name = name; this.age = age; // 简化为 Person.call(this,name,age); this.sex = sex; &#125; var student = new Student('long',18,'male'); 复习闭包闭包表象：一个函数套着另外一个函数，你把被嵌套的函数保存到套他的函数外面（a 套着 b，你把 b 弄出 a 里面），就形成了闭包（不一定要 return） 123456789101112131415161718192021222324252627282930313233下面两种都可以实现闭包 1)function a()&#123; function b()&#123; &#125; return b; &#125; a(); 2)var obj = &#123;&#125; function a()&#123; function b()&#123; &#125; obj.fun = b; &#125; a(); // 123 var a = 123; // this call go &#123; a : 123 &#125; ao &#123; a : undefined &#125; function test()&#123; a = 1; var a; &#125; test(); 复习构造函数通过构造函数构造对象的时候用 new,我执行函数的时候就不用 new 构造对象必须是 new 加上构造函数执行（如 person();）才能构造出对象 有了 new 之后，才会发生两步隐式变化（var this = {}； return this） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 function Person()&#123; // var this = &#123;&#125; this.name = 'abc'; this.age = 123; // return this; &#125; var pereson = new Person();// 没有 var person = new Person(); 只 Person 会走预编译，此时 this 指向 window私有化属性看不到 Var money = 100; 外部看不到 var money,就是闭包 function Person(name)&#123; // var this = &#123; // makeMoney : function()&#123;&#125; // offer : function()&#123;&#125; // &#125; var money = 100; this.name = name; this.makeMoney = function()&#123; money ++; &#125; this.offer = function()&#123; money --; &#125; // return this; &#125; var person = new Person(); var inherit = (function()&#123; var F = function()&#123;&#125;; return function(Target,Origin)&#123; F.prototype = Origin.prototype; Target.prototype = new F(); &#125; &#125;()) `立即执行函数执行完就成下面这样了` var inherit = function(Target,Origin)&#123; F.prototype = Origin.prototype; Target.prototype = new F(); &#125;引用值也可以进行类型转换`数组不等于数组，因为里面的地址不一样` // 从控制台输出 &gt; [] + '' &lt;· '' &gt; [] + 2 &lt;· '2' &gt; Number([]) &lt;· 0 &gt; [] == [] &lt;· false &gt; String([]) + 1 &lt;· '1' 复习克隆123456789101112131415 var obj = &#123; naem : 'abc' &#125; // 浅克隆 var obj1 = &#123; // 当拷贝引用值的收就不行了 &#125; for(var prop in prop)&#123; obj1[prop] = obj[prop]; &#125;`这样浅度克隆，克隆的是地址，缺点是你改我也改``深度克隆解决的就是引用值``null 和 undefined 不能和数字进行比较，不会进行类型转换，他们不作为比较值存在` 复习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119私有化变量 function Person(name,age,sex)&#123; var a = 0; this.name = name; this.age = age; this.sex = sex; function sss()&#123; a ++; documents.write(a); &#125; this.say = sss; &#125; bst oPrtrdon = mre Person(); oPerson.say(); oPerson.say(); var oPerson1 = new Person(); oPerson1.say(); // 打印 1，2，1 (function(x)&#123; delete x; return x; &#125;(1)); // 答案 1，删不掉x，该是什么是什么 function test()&#123; console.log(typeof(arguments)); &#125; test(); // 返回 object var h = function a()&#123; return 23; &#125; console.log(typeof a()); // error : a is not a defined // 报错选择你熟悉的一种方式实现JavaScript 对象的继承 // 案：声明模式实现 object 类型的 clone()方法 // 答案：深度克隆尝试优化以下代码，让代码看起来更优雅 function getDay(day)&#123; switch(day)&#123; case 1: documents.wirte('Monday'); break; case 2: documents.wirte('Tuesday'); break; case 3: documents.wirte('Wednesday'); break; case 4: documents.wirte('Thursday'); break; case 5: documents.wirte('Friday'); break; case 6: documents.wirte('Saturday'); break; case 7: documents.wirte('Sunday'); break; case default: documents.wirte('Error'); break; &#125; &#125; // 答案： function retDate(date)&#123; var arr = ['1','2','3']; var ret = arr[date - 1]; if(ret === undefined)&#123; return 'error'; &#125;else&#123; return ret; &#125; &#125;`SEO 是搜索引擎优化`HTML布局实现：头和尾固定，中间自适应。// 答案：三栏布局，头尾是指左右在页面中增加一个 div（宽度 400px，高度400px，背景颜色蓝色，边框颜色红 色），该 div要求在页面中居中显示。简单画图描述CSS盒模型css中的选择器有哪些？// 答案：id 选择器是 xxx，先说类型在举例JavaScript 中有哪些数据类型？// 答案：原始值里面有 XXX，引用值里面有 XXXX什么是 rem布局？html 顶部的DOCTYPE 有什么作用？有什么影响？Display的参数值及其含义描述一下盒模型// 答案：需要讲两种才满分css3可用伪类都有那些？position属性有哪些值，有什么区别？如何创建一个 div，并添加到页面里。写一个正则表达式，检验字符串首尾是否含有数字跨域请求数据的方法都有哪些？编写一个类和类继承，类名为Person，含有属性 name，age，含有方法$。一个 student 类，继承自Person，自由属性 score，自有方法 study（类指的就是构造函数）`一个字符串[a - z]组成，请找出该字符串第一只出现一次的字母。``字符串去重` try…catch防止我们报错的 try花括号{里面会正常执行，但是遇到 b 报错时 b 就执行不出来，后面的代码 c 就不执行了，但是外面的代码 d 还能执行}catch(e),这个 e 是可以随便写的，写 abc 都可以，也是一个形参 12345678910 try&#123; console.log('a'); console.log(b); console.log('c'); &#125;catch(e)&#123; &#125; console.log('d');`报错后，不执行后续的代码，但是依然可以执行外面的d` 在 try 里面发生的错误，不会执行错误后的 try 的里面的代码 catch 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 try&#123; console.log('a'); console.log('b'); console.log('c'); &#125;catch(e)&#123; console.log('e'); &#125; console.log('d');`如果 try里面的代码不出错，在 catch 里面的代码就不执行；` try&#123; console.log('a'); console.log(b); console.log('c'); &#125;catch(e)&#123; console.log('e'); &#125; console.log('d');`如果 try里面的代码出错，catch 负责补抓到错误信息封装到里面（error.massage error.name）， 错误对象只有 message 和 name。 ` try&#123; console.log('a'); console.log(b); console.log('c'); &#125;catch(e)&#123;// error error.message error.name --&gt; error onsole.log(e.message + \" \" + e.name); &#125; console.log('d'); // 从控制台输出： // a // b is not defined ReferenceError // d try&#123; console.log('a'); console.log(b); console.log('c'); &#125;catch(e)&#123; console.log(e.name + ' : ' + e.message); &#125; console.log('d'); // 从控制台输出： // a // ReferenceError : b is not defined // d`try&#123;&#125;catch(e)finally&#123;&#125;` Error.name 的六种值对应的信息Error.name : 前面是错误名称，后面是错误信息 1. EvalError : eval() 使用与定义不一致不一致（eval 是不允许被使用的） 2. RangeError : 数值越界 3. ReferenceError : 非法或不能识别的引用数值（未经声明就使用，未经定义就使用） 4. SyntaxError : 操作数类型错误 5. TypeError : 操作数类型错误 6. URIError : URI处理函数使用不当（引用地址错误） 大部分都是 3 和 4 这种错误， 伪代码也可以写，就比如 var 老于 = 123; 这就是伪代码 var str = avs ==&gt; ReferenceError es5.0 严格模式（这一章就是讲 es3.0 和 es5.0产生冲突的部分） 浏览器是基于 es3.0 和 es5.0 的新增方法使用的。 如果两种发生了冲突，就用 es3.0。 es5.0 严格模式是指 es3.0 和 es5.0 产生冲突发部分就是用 es5.0，否则就用 es3.0 es5.0 严格模式的启动方式，在页面逻辑最顶端写 &#39;use strict&#39; 用法在整个页面的最顶端写 &#39;use strict&#39;,可以写在全局的最顶端，也可以写在 某函数（局部）的最顶端，推荐使用局部的 123456789101112131415161718192021222324es5.0 不能用 argument.callee,但是 es3.0 可以用 // es5.0 严格模式的启动 'use strict'; function test()&#123; console.log(argumetns.callee); &#125; test(); // 报错：es5.0模式下不能用 callee 和 callerfunction test()&#123;&#125; 里面加 'use strict'; 是局部启动严格模式 function demo()&#123; console.log(arguments.callee); &#125; demo(); function test()&#123; 'use strict'; console.log(arguments.callee); &#125; // function demo()&#123; // console.log(arguments.callee) // &#125; // 报错 &#39;use strict&#39; 不在兼容 es3.0 的一些不规则语法。使用全新的 es5.0 规范。两种用法： 一、全局严格模式 局部函数内严格模式（推荐） 就是一行字符串，不会对不兼容严格模式的浏览器产生影响。 不支持 with，argumetns.callee，function.caller，变量赋值前必须声明，局部 this 必须被赋值（Perosn.call(null/unfined)) 赋值什么就是什么，拒绝重复属性和参数 12345'use strict'浏览器升级到 es5.0 才好用写成 strice();就有风险写成 'use strict'; 就有一个向后兼容的作用 123es5.0 严格模式下不能用 with with 可以改变作用域链 with()括号里面的代码会按照正常顺序执行，但是如果在括号里面添加了对象，就会把对象当作 with 要执行的代码体的作用域链的最顶端（最直接的最近的 AO） 123456789101112131415下面这个 with 看到的就是 var obj 的 name （with 改变作用域链） var obj = &#123; name : 'obj', age = 234 &#125; var name = 'window'; function test()&#123; var age = 123; var name = 'spoce'; with(obj)&#123; console.log(name); console.log(age); &#125; &#125; // obj,234 12345678910111213141516171819202122232425命名空间应该像下面这样用的，with 可以简化代码 var org = &#123; dp1 : &#123; jc : &#123; name : 'abc', age : 123 &#125;, deng : &#123; name : 'xiaodeng', age : 234 &#125; &#125;, dp2 : &#123; &#125; &#125; with(org.dp1.jc)&#123; console.log(name); &#125; with(document)&#123; write('a'); &#125;`这也是 with 的运用方式，用with 表示 document.write();` with 过于强大，可以改变作用域链，失去效率，所以es5.0不能用 argumetns.callee 123456function test()&#123; console.log(argumetns.callee);&#125;test();// 报错 -- TypeError ：'caller','callee' 12345678910arguments.callee 在 es5.0 严格模式下报错 'use strice'; function test()&#123; console.log(test.caller); &#125; function demo()&#123; test(); &#125; demo(); // 报错 -- TypeError ：'caller','callee' es5.0 严格模式下：变量赋值前必须声明，局部 this 必须被赋值 （Person.call(null/undefined) 赋值什么就是什么），拒绝重复属性和参数（this 不在指向 window） 12345var a = b = 3;// 报错a = 3;// 报错 1234567局部 this 必须被赋值 (Person.call(null/undefined)赋值什么就是什么) 'use strict'; function test()&#123; console.log(this); &#125; test(); // undefined 123456789101112131415161718192021该对象的 constructor是 Test 'use strict'; function Test()&#123; console.log(this); &#125; new Test(); // Test&#123;&#125; 'use strict'; function Test()&#123; console.log(this); &#125; new Test.call(&#123;&#125;); // Object&#123;&#125; 'use strict'; function Test()&#123; console.log(this); &#125; new Test.call(123); // 123 123456789`在 es3.0 里面是不能这样的` function Test()&#123; console.log(this); &#125; Test.call(123); // Number&#123;[[PrimitiveValue]]:123&#125; // &gt; new Number(123) 这是包装类的显示形式 // &lt;· Number&#123;[[PrimitiveValue]]:123&#125; 1234在 es5.0 中全局的 this 还是指向 window 'use strict'; console.log(this); //--全局范围 // Window 123456789101112拒绝重复属性和参数（this 不在指向 window） function test(name,name)&#123; console.log(name); &#125; test(1); // undefined function test(name,name)&#123; console.log(name); &#125; test(1,2); // 2 12345678910111213141516`在 es3.0 里面重复的参数是不报错的，但是在 es5.0 里面是会报错的` 'use strict'; function test(name,name)&#123; console.log(name); &#125; test(1,2); // SyntaxError:Duplicate -- 报错`重复的属性名在 es5.0 也不行，但是不报错（后面会覆盖前面的）` 'use strict'; var obj = &#123; name : '123', name : '234' &#125; eval 很强大，能把字符串当成代码来执行 但是约定俗成在 es3.0 中都不能使用 eval。eval是魔鬼，因为会改变作用域 123456789101112 'use strict'; var a = 123; eval('console.log(a)');// es3.0 都不能 eval();eval 是魔鬼 var global = 100; function test()&#123; global = 200; eval('console.log(global)'); &#125; test(); 1234567如果改变 global，他改变的是全局的当情况不同，eval 改变的作用域是不同的eval 还有自己独立的作用域理解：可以把回调函数理解为先定义好了函数，执行的时候再回头调用 什么是DOM DOM —&gt; Document Object Model（文档对象模型 DOM 定义了表示和修改文档所需的方法（对象，这些对象的行为和属性以及这些对象之间的关系。）DOM 对象即为宿主对象，有浏览器厂商定义，用来操作 html 和 xml 功能的一类对象的集合。 也有人称 DOM 是对 HTML 以及 XML 的标准编程接口 xml ==&gt; xhtml ==&gt; html xml 是最早的版本，xml里面的标签是可以自己定义的，被 js 里面的 jeson 取代了，dom 不能改变 css 样式表，但是可以简介改变行间样式的 css 1234567891011121314151617181920说的是改变不了 css 是指改变不了 css 的样式表，但是可以通过间接方式改变 html 的行间样式来改变 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.style.widht = '100px'; div.style.height = '100px'; div.style.backgroundColor = 'red'; &lt;/script&gt; &lt;/body&gt;`1. 找到 html 的方法：如 document。getElementsByTagName('div')就能把所有的 div 都选出来。如果想要拿到第一个 div ，写成 document.getElementByTagName('div') 后面就要加一个[0];就可以实现了2. div.style 选出来代表行间样式，选出来的就是 dom 对象3. js 不能写 -(号) ，只能用小驼峰方法写。如 background-color 写成 bakgroundColor` 1234567891011121314151617181920有 dom 操作以后就变成动态交互可以操作的了（你动一下，他给你一个反应）div.onclick 是一个交互效果的事件监听&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.style.widht = '100px'; div.style.height = '100px'; div.sytle.backgroundColor = 'red'; div.onclick = function()&#123; this.style.backgroundColor = 'green'; this.style.widht = '200px'; this.style.height = ' 50px;'; this.style.borderRadius = '50%'; &#125; &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718实现点击一下改变一下颜色 &lt;div&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.style.widht = 100px; div.style.height = '100px'; div..style.backgroundColor = 'red'; var count = 0; div.onlick = function()&#123; count ++; if(count % 2 == 1)&#123; this.style.backgroundColor = 'green'; &#125;else&#123; this.style.backgroundColor = 'red' &#125; &#125; &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344选项卡`写个选项卡，点第一个按钮出现第一对应的信息，点第二个按钮，第一个消失，第二个显示` &lt;head&gt; &lt;style&gt; .content&#123; display:none; width:200px; height:200px; border:2px solid red; &#125; .active&#123; background-color:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;button class=\"active\"&gt;111&lt;/button&gt; &lt;button&gt;222&lt;/button&gt; &lt;button&gt;333&lt;/button&gt; &lt;div class=\"content\" style=\"display:block\"&gt;1111&lt;/div&gt; &lt;div class=\"content\"&gt;2222&lt;/div&gt; &lt;div class=\"content\"&gt;3333&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var btn = document.ElementsByTagName('button'); var div = document.ElementsByClassName('content'); for(var i = 0; i &lt; btn.length; i ++)&#123; (function(n)&#123; btn[i].onlick = function()&#123; for(var j = 0;j &lt; btn.length; j ++)&#123; btn[i].className = ''; div[i].style.display = 'none'; &#125; this.className = 'active'; div[i].style.display = 'block'; &#125; &#125;(i)) &#125; &lt;/script&gt; &lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536373839小方块应用`document.body.appendChild(div); -- 意思是在body里面放一个 div``setInterval(function()&#123;&#125;,100) -- 是一个定时器功能，意思是每隔 100毫秒 就执行一次` var div = document.createElement('div'); document.body.appendChild(div); div.style.width = '100px'; div.style.height = '100px'; div.style.backgroundColor = 'red'; div.style.position = 'absolute'; div.style.left = '0'; div.style.top = '0'; setInterval(function()&#123; div.style.left = parseInt(div.style.left) + 2 + 'px'; div.style.top = parseInt(div.style.left) + 2 + 'px'; &#125;,50) `把上面的 setInterval(function()&#123;&#125;) 改成下面样式` var speed = 1; setInterval(function()&#123; speed += speed / 7; div.style.left = parseInt(div.style.left) + speed + 'px'; div.style.top = parseInt(div.style.top) + speed + 'px'; &#125;,10) `把上面的 setInterval(function()&#123;&#125;) 改成以下样式，可以让定时器停止` var speed = 1; var timer = setInterval(function()&#123; speed += speed / 20; div.style.left = parseInt(div.style.left) + speed + 'px'; div.style.top = parseInt(div.style.top) + speed + 'px'; if(parseInt(div.style.top) &gt; 200 &amp;&amp; parseInt(div.style.left) &gt; 200)&#123; clearInterval(timer) &#125; &#125;,10); 1234567891011121314151617181920212223242526实现键盘控制小方块 var div = document.createElement('div'); document.body.appendChild(div); div.style.widht = '100px'; div.style.height = '100px'; div.style.background = 'red'; div.style.position = 'absolute'; div.style.left = '0'; div.style.top = '0'; document.onkeydown = function(e)&#123; switch(e.which)&#123; case 38: div.style.top = parseInt(div.style.top) - 5 + 'px'; break; case 40: div.style.top = parseInt(div.style.top) + 5 + 'px'; break; case 37: div.style.left = parseInt(div.style.left - 5 + 'px'); break; case 39: div.style.left = parseInt(div.style.left) + 5 + 'px'; break; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546点击运动加速`思路：每一次按下的时候都记录一个新的时间片段，都减去上一个执行的时间 片段，如果时间片段都小于一定的毫秒数的话，我们让一个计数器去++，当连续小 于的时候，就让计数器连续++,如果++到一定数的时候，我们认为是连续按了，再按 就加速了，让每一次按的时候都判断一下,如果时间间隔过大的话，就让计数器重新 归 0``按住加速：就是这一次按下与下一次按下的速度间隔时间十分短暂，就认为他加速 了。` &lt;body&gt; &lt;button style=\" width: 100px;height: 50px; background:linear-gradient(to left,#999,#000,#432,#fcc);position: fixed;right:0;top:50%; text-align: center;line-height: height;color: #fff; font-size: 25px;font-family: Arial;\"&gt; 加速&lt;/button&gt; &lt;script&gt; var btn = document.getElementsByTagName('button')[0]; var div = document.createElement('div'); document.body.appendChild(div); div.style.width = '100px'; div.style.height = '100px'; div.backgroundColor = 'red'; div.style.position = 'absolute'; div.style.left = '0'; div.style.top = '0'; var speed = 5; btn.onlick = function () &#123; speed++; &#125; document.onkeydown = function (e) &#123; switch (e.which) &#123; case 38: div.style.top = parseInt(div.style.top) - speed + 'px'; break; case 40: div.style.top = parseInt(div.style.top) + speed + 'px'; break; case 37: div.style.left = parseInt(div.style.left) - speed + 'px'; break; case 39: div.style.left = parseInt(div.style.left) + speed + 'px'; break; &#125; &#125; &lt;/script&gt; &lt;/body&gt; 12345678910111213141516171819202122232425262728293031323334353637划过出现颜色`box-sizing:border-box -- 启动了另外一种盒模型（IE盒模型）` &lt;head&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; width: 10px; height: 10px; /* border: 1px solid black; */ float: left; list-style-type: none; box-sizing: border-box; &#125; ul &#123; width: 200px; height: 200px; &#125; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li img-data='0'&gt;&lt;/li&gt; * 400 &lt;/ul&gt; &lt;script&gt; var ul = document.getElementsByTagName('ul')[0]; ul.onmouseover = function (e) &#123; var event = e || window.evnet; var target = event.target || event.srcElement; target.style.backgroundColor = 'rgb(0,255, '+ target.getAttribute('img-data') + ')' target.setAttribute('img-data',parseInt(target.getAttribute('img-data')) + 6) &#125; &lt;/script&gt; &lt;/body&gt; DOM 基本操作 ①（大部分都是类数组）—— 方法类选中操作对节点的增删改查 () 号里面都不用写 . 或 # 查，查看元素节点 document：代表整个文档（如果给 html 标签上面再套一层标签就是 document） （Id）getElementById元素 id 在 Ie8 以下的浏览器，不区分 id 大小写，而且也返回 name 属性的元素，通过 id 标识我们来选择这个元素，一一对应 1234&lt;div name='only'&gt;123&lt;/div&gt;&lt;script&gt; var div = document.getElementId('only');&lt;/script&gt; 除了 id 以外，其余选择出来的都是一组，很少用 id 选择器 （标签）getElementsByTagName标签名，这是一个类数组，最主流的用法，经常用 1234567891011把页面里面的所有的 div 都选择出来&lt;div id='only'&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsTagName('div');&lt;/script&gt;// 从控制台输出// &gt; div// &lt;· [div#only]// &gt; div.push(1)// &lt;· 报错从 dom 开始，我们所学的一切系统给我们生成数组的东西，基本上都是类数组 12345加个 [0] 就选中了第一个 div，如果不加 0 ，那个 div 表示的是一个数组，设置背景颜色就会报错&lt;div id='only'&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt; （name）getElementsByNameIE不支持需注意，只有部分标签 name 可生效（表单，表单元素，img，iframe）不是在所有的浏览器都能用——开发一般不用 1234&lt;input name=\"fruit\"&gt;&lt;script&gt; var div = document.getElementsByName('frult')&lt;/script&gt; 12345678把下面所有的 div 都拿出来&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;script&gt; var div = document.getElementsByTagName('div')&lt;/script&gt; 只拿出第二个 div，加上[1],或在控制台上打 div[1] 1234567选择第一个 p 的方式如下&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var p = document.getElementsByTagName('p')[0];&lt;/script&gt; （Class）getElementsByClassName类名 -&gt;缺点： ie8和ie8 以下的 ie 版本中没有，可以多个 class 一起，不是所有浏览器都能用 123456789只选择 .demo 的 p 标签 写法如下：&lt;div&gt; &lt;p class='demo'&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var p = document.getElementsByClassName('demo')[0]&lt;/script&gt;注意哪怕整个文只有一个 demo，也要加 [0],不然选出来的就是一个组 （CSS）.querySelector() &lt;&gt; .querySelectorAll().querySelector -- css选择器，只能选择一个，在 ie7 和 ie7 一下的版本中没有 .querySelectorAll -- css选择器，全选，选一组，在 ie7 和 ie7 以下的版本中没有 .querySelectorAll()和.querySelector()选出来的元素不是实时的（是静态的），所以一般不用，其他的再怎么修改，跟原来的没有关系 id 选择器不能太依赖，一般当顶级框架使用，在 css 中一般用 class 选择器 query 是一个词条 123456789101112131415161718192021.querySelector()和.querySelectorAll()选出来的元素不是实时的，是静态的，是副本&lt;body&gt; &lt;div&gt; &lt;strong&gt;123&lt;/strong&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt; &lt;strong class='demo'&gt;&lt;/strong&gt; &lt;/span&gt; &lt;/div&gt; &lt;script&gt; var strong = document.querySelector('div &gt; span strong.demo'); var strong1 = document.querySelectorAll('div &gt; span strong.demo'); &lt;/script&gt;&lt;/body&gt;// 从控制器输出：// &gt; strong// &lt;· &lt;strong class='demo'&gt;123&lt;strong&gt;// &gt; strong1// &lt;· [strong.demo] 123456789101112131415`下面的都是实时的`&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div class='demo'&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName('div'); var demo = document.getElementsByClassName('demo')[0] var newDiv = document.createElement('div'); document.body.appendChild(newDiv); &lt;/script&gt;&lt;/body&gt;// 从控制器输出：// &gt; div// &lt;· [div,div.demo,div,div] 123456789101112.querySelectorAll()选中了所有的 div，但是实时操作不能实时反馈&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div class='demo'&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelectorAll('div'); var demo = document.getElementsByClassName('demo')[0]; var newDiv = document.createElement('div); document.body.appendChild(newDiv); &lt;/script&gt;&lt;/body&gt; DOM基本操作 ② — 非方法类的节点操作遍历节点树遍历节点树：（灵活，兼容好）--- 关系类的选择 parentNode ——&gt; 父节点（最顶端的 parentNode 为 #document） childNodes ——&gt; 子节点们（直接的节点数）节点包括文本节点，属性节点 firstChild ——&gt; 第一个子节点 lastChild ——&gt; 最后一个子节点 nextSibling ——&gt; 后一个兄弟节点 previousSibling ——&gt; 前一个兄弟节点 parentNode –&gt; 父节点1234567891011121314151617181920212223&lt;div&gt; &lt;strong&gt; &lt;span&gt;&lt;/span&gt; &lt;/strong&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从控制器输出：// &gt; strong.parentNode// &lt;· &lt;div&gt;&lt;/div&gt;// &gt; strong.parentNode.parentNode// &lt;· &lt;body&gt;&lt;/body&gt;// &gt; strong.parentNode.parentNode.parentNode// &lt;· &lt;html lang='en'&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;// &gt; strong.parentNode.parentNode.parentNode.parentNode// &lt;· #document// &gt; strong.parentNode.parentNode.parentNode.parentNode.parentNode// &lt;· null childNodes –&gt; 子节点1234567891011121314151617181920&lt;div&gt; &lt;strong&gt; &lt;span&gt;1&lt;/span&gt; &lt;/strong&gt; &lt;span&gt;&lt;/span&gt; &lt;em&gt;&lt;/em&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从控制器输出：// &gt; div.childNodes// &lt;· [text,strong,text,span,text,em,text]// &gt; div.childNodes.length// &lt;· 7// 解释： // 为什么是7个节点？ 第一个节点是 &lt;div&gt; 后面的文本节点（空格回车），第二个节点是元素节点 &lt;strong&gt;&lt;/span&gt;1&lt;/span&gt;&lt;/strong&gt;,第三个节点是跟着的文本节点（空格回车），第四个节点是 &lt;span&gt;&lt;/span&gt; 第五个是跟着的文本节点（空格回车）第六个是 &lt;em&gt;&lt;/em&gt;，第七个是跟着的文本节点（空格回车） firstChild &amp; lastChild –&gt; 第一个子节点，最后一个子节点1234567891011121314&lt;div&gt; 123 &lt;!-- This si comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;sctipt&gt; var div = document.getElementsByTagName('div')[0];&lt;/sctipt&gt;// 从控制器输出：// &gt; div.firstChild// &lt;· \"123\"// &gt; div.lastChild// &lt;· #text previousSibling &amp; nextSibling –&gt; 前一个兄弟节点，后一个兄弟节点previousSibling 前一个兄弟节点 nextSibling 后一个兄弟节点 12345678910111213141516171819202122232425&lt;div&gt; &lt;!-- This is comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var strong = document.getElementsByTagName('strong')[0];&lt;/sctipt&gt;// 从控制器输出：// &gt; strong.nextSibling// &lt;· #text// &gt; strong.nextSibling.nextSibling// &lt;· &lt;span&gt;&lt;/span&gt;// &gt; strong.nextSibling.nextSibling.nextSibling// &lt;· #text// &gt; strong.nextSibling.nextSibling.nextSibling.nextSibling// &lt;· null// &gt; strong.previousSibling// &lt;· #text// &gt; strong.previousSibling.previousSibling// &lt;· comment// &gt; strong.previousSibling.previousSibling.previousSibling// &lt;· #text 基于元素节点树的遍历 – 不包含文本节点parentElement – 遍历元素父节点 children – 遍历元素子节点 childElementCount – 查看元素子节点的个数 firstElementChild – 第一个元素子节点 lastElementChild – 最后一个元素子节点 previousElementSibling – 前一个兄弟节点 nextElementSibling – 后一个兄弟节点 除 children 外，其余的 ie9 及以下不兼容 parentElement –&gt; 返回当前元素的父元素节点 – IE不兼容1234567891011121314151617&lt;div&gt; 123 &lt;!-- This is comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;sctipt&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从控制器输出：// &gt; div.parentElement// &lt;· &lt;body&gt;&lt;/body&gt;// &gt; div.parentElement.parentElement// &lt;· &lt;html lang='en'&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;// &gt; div.parentElement.parentElement.parentElement// &lt;· null children –&gt; 只返回当前元素的元素子节点12345678910111213&lt;div&gt; 123 &lt;!-- This is comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从控制器输出：// &gt; div.children// &lt;· [strong,span] childElementCount – 当前元素节点的子元素节点个数childElementCount === children.length 当前元素节点的子元素节点个数（IE 不兼容）———— 基本不用，因为与 length 相等 123456789101112131415&lt;div&gt; 123 &lt;!-- This is comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt;&lt;div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从控制器输出：// &gt; div.childElementCount// &lt;· 2// &gt; div.children.length// &lt;· 2 firstElementChild &amp; lastElementChild –&gt; 第一个元素节点，最后一个元素节点firstElementChild --&gt; 返回的是第一个元素节点（IE不兼容） lastElementChild --&gt; 返回的是最后一个元素节点（IE不兼容） 123456789101112131415&lt;div&gt; 123 &lt;!-- This is comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从控制器输出：// &gt; div.firstElementChild// &lt;· &lt;strong&gt;&lt;/strong&gt;// &gt; div.lastElementChild// &lt;· &lt;span&gt;&lt;/span&gt; previousElementSibling &amp; nextElementSibling –&gt; 前一个兄弟元素节点，后一个兄弟元素previousElementSibling --&gt; 前一个兄弟元素节点 nextElementSibling --&gt; 后一个兄弟元素 1234567891011121314151617181920212223&lt;div&gt; 123 &lt;!-- This si comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;i&gt;&lt;/i&gt; &lt;b&gt;&lt;/b&gt;&lt;/div&gt;&lt;script&gt; var strong = document.getElementsByTagName('strong')[0];&lt;/script&gt;// 从控制器输出：// &gt; strong.nextElementSibling// &lt;· &lt;span&gt;&lt;/span&gt;// &gt; strong.nexElementSibling.nextElementSibling// &lt;· &lt;em&gt;&lt;/em&gt;// &gt; strong.nextElementSibling.nextElementSibling.nextElementSibling// &lt;· &lt;i&gt;&lt;/i&gt;// &gt; strong.previousElementSibling// &lt;· null 除 children 外，parentElement、node.childElementCount、firstElementChild、lastElementChild、nextElementSibling、previousElementSibling 在 ie9 及以下不兼容 真正常用的就是 children，兼容性好 每一个节点的四个属性nodeName – 节点标签名 nodeValue – 文本注释节点 nodeType – 查看节点类型 attributes – 属性节点 hasChildNodes – 判断有没有子节点 nodeName – 节点标签名元素的标签名，以大写形式表示，只读，不可写 1234567891011121314151617181920&lt;div&gt; 123 &lt;!-- This si comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;i&gt;&lt;/i&gt; &lt;b&gt;&lt;/b&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// &gt; 从控制器输出：// &gt; div.childNodes[1].nodeName// &lt;· '#comment'// &gt; div.childNodes[3].nodeName = 'abc'// &lt;· 'abc'// &gt; divchildNodes[3].nodeName// &lt;· 'strong' nodeValue – 文本/注释节点Text 文本节点或 Comment 注释节点的文本内容，可读写 1234567891011121314151617181920212223242526272829&lt;div&gt; 123 &lt;!-- This is comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;i&gt;&lt;/i&gt; &lt;b&gt;&lt;/b&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 控制台输出：// &gt; div.childNodes[0].nideValue// &lt;· '123'// &gt; div.chidlNodes[0].nodeValue = 234// &lt;· 234// &gt; div.childNodes[0].nodeValue// &lt;· '234'// &gt; div.childNodes[0]// &lt;· '234'// &gt; div.childNodes[1].nodeValue// &lt;· 'This si comment'// &gt; div.childNodes[1].nodeValue = 'That si comment'// &lt;· 'That si comment'// &gt; div.childNodes[1]// &lt;· &gt;!-- That is comment --&gt; nodeType（最有用） – 节点类型该节点的类型，只读返回这个 div 的所有的元素节点 123456789101112131415161718192021222324数字是调用 nodeType 返回的数字，代表着每一个节点的类型元素节点 —— 1属性节点 —— 2文本节点 —— 3注释节点 —— 8document —— 9DocumentFragment —— 11&lt;div&gt; 123 &lt;!-- This is comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;i&gt;&lt;/i&gt; &lt;b&gt;&lt;/b&gt;&lt;/div&gt;// 控制台输出：// &gt; div.childNodes[0].nodeType// &lt;· 3(文本节点)// &gt; div.childNodes[3].nodeType// &lt;· 1(元素节点) 123456789101112131415161718192021222324252627282930313233把 div 下面所有的直接子元素节点挑出来，放在数组里面返回，不能用 children&lt;div&gt; 123 &lt;!-- This is comment --&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt; &lt;em&gt;&lt;/em&gt; &lt;i&gt;&lt;/i&gt; &lt;b&gt;&lt;/b&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; function retElementChild(node)&#123; // no children var temp = &#123; length : 0, push : Array.prototype.push, splice : Array.prototype.splice &#125;, child = node.childNodes, len = child.length; for(var i = 0; i &lt; len;i ++)&#123; if(child[i].node.length === 1)&#123; temp.push(child[i]); &#125; &#125; return temp; &#125; console.log(retElementChild(div));&lt;/script&gt;// [strong，span，em，i，b] attributes – 属性节点Element 节点的属性集合 1234567891011121314151617181920&lt;div id=\"only\" class=\"demo\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从控制台输出：// &gt; div.attributes// &lt;· NamedNodeMap&#123;0: id,1: class,length: 2&#125;// &gt; div.attributes[0]// &lt;· id='only'// &gt; div.attributes[0].nodeType// &lt;· 2// &gt; div.attributes[0].value// &lt;· 'only'// &gt; div.attributes[0].name// &lt;· 'id'// &gt; div.attributes[0].value = 'abc'// &lt;· 'abc'// &gt; div// &lt;· &lt;div id='abc' class='demo'&gt;&lt;/div&gt; 属性名不能改，属性值可以，但是我们一般不会用这种方法 我们一般用 getAttribute 和 setAttribute 去取 hasChildNodes – 判断有没有子节点节点的一个方法 Node.hasChildNodes(); -- 他有没有子节点，返回值是 true 或 false 12345678910&lt;div id=\"only\" class=\"demo\"&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从console输出：// div.hasChildNodes()// true 12345678910&lt;div id=\"only\" class=\"demo\"&gt; &lt;!-- this is comment --&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从console输出：// div.hasChildNodes()// true 12345678910&lt;div id=\"only\" class=\"demo\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从console输出：// div.hasChildNodes()// true 12345678910当这种情况下是 false （没有空格，没有回车）&lt;div id=\"only\" class=\"demo\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0];&lt;/script&gt;// 从console输出：// div.hasChildNodes()// false 1234567属性的节点是 div 上面的，不是 div 里面的&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/span&gt;&lt;/span&gt; &lt;!-- thsi is comment --&gt;&lt;/div&gt; DOM接口/结构树dom 结构树代表的是一系列继承关系 1234567891011121314151617 |-- XMLDocument |-- Document --| | |-- HTMLDocument | | |-- Text |-- HTMLHeadElement |-- characterData --| |Node ---| |-- Comment |-- HTMLBodyElement | | | |-- HTMLTitleElement | | |-- Element -- HTMLElement --------|-- TMLParagraphElement | |-- HTMLInputElement | |-- HTMLTableElement | |-- …etc… 12345678910`Document 和 document的关系`&gt; Document&lt;· function Document()&#123;[native code]&#125;&gt; Document.prototype.abc = 'abc';&lt;· 'abc'&gt; document.abc&lt;· 'abc' document --&gt; HTMLDocument.prototype --&gt; Document.prototype document 继承自 HTMLDocument.prototype HTMLDocument.prototype 继承自 Document.prototype 1234567891011121314151617181920212223圆形是不是一个对象？HTMLDocument.prototype = &#123; __proto__ : Document.prototype&#125;例： document --&gt; HTMLDocument.prototype --&gt; Document.prototype// console输出： // &gt; HTMLDocument.prototype.bcd = '123' // &lt;· '123' // &gt; document // &lt;· #document // &gt; document..bcd // &lt;· '123' // &gt; Document.prototype.bcd = '123' // &lt;· '123' // &gt; HTMLDocument.prototype.bcd = '234' // &lt;· '234' // &gt; document.bcd // &lt;· '234' DOM 结构树中，Node也是构造函数，comment 是注释 HTMLDocument 和 HTMLElement 实际上并列了对应的 XML，但是因为不用了 XML 就省略了，HTMLHeadElement 就是 head 标签，其余类推 123456789101112例： HTMLBodyElement.protootype.abc='demo'; var body = document.getElementsByTagName('body')[0]; var head = document.getElementsByTagName('head')[0];// console输出 // &gt; body.abc // &lt;· 'demo' // &gt; head..bcd // &lt;· undefiend`如果使用 HTMLElement.prototype.abc=\"demo\"; 定义，则body和head都可以使用` 1234567891011121314151617181920212223看一看一层一层返回的是什么东西// console输出 // &gt; document.__proto__ // &lt;· HTMLDocument&#123;Symbol&#123;symbol.toStringTag&#125;:'HTMLDocument'&#125; // &gt; document.__proto__.__proto__ // &lt;· Document&#123;Symbol&#123;Symbol.toStringTag&#125;:'Document',Symbol&#123;symbol.unscopables&#125;:Object&#125; // &gt; document.__proto__.__proto__.__proto__ // &lt;· Node &#123;ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5, …&#125; // &gt; document.__proto__.__proto__.__proto__.__proto__ // &lt;· EventTarget &#123;Symbol(Symbol.toStringTag): \"EventTarget\", : ƒ, removeEventListener: ƒ, dispatchEvent: ƒ, constructor: ƒ&#125; // &gt; document.__proto__.__proto__.__proto__.__proto__.__proto__ // &lt;· Object&#123;&#125; // &gt; document.body // &lt;· &lt;body&gt;…&lt;/body&gt; // &gt; document.body.toString() // &lt;· '[object HTMLBodyElement]' 思路： 绘制dom树，符合深度优先（纵向）原则，比如先看head → title → meta → body → div → strong → span dom树是节点解析，dom树解析完毕代表dom数所有的节点解析完毕，不代表加载（下载完毕）完毕。如看到img标签就放到dom树上，然后同时下载。 dom树形成完了以后，就等css树形成【cssTree也是深度优先原则。】。 domTree + cssTree = randerTree，randerTree形成以后才，渲染引擎才会绘制页面，domTree改变，randerTree也会改变，会重排，影响效率,要尽量避免重排。 randerTree触发重排（reflow）的情况：dom节点的删除，添加，dom节点的宽高变化，位置变化，display none ==&gt; block，offsetWidth，offsetLeft repaint重绘：效率也比较低，效率影响较小。触发情况：改颜色，图片 DOM 基本操作 - 定义方法 ③定义方法一、getElementById方法定义在Document.prototype上，即Element节点上不能使 二、getElementsByName定义在HTMLDocument.prototype上，既非html中的document以外不能使用（xml document,Element） 三、getElementsByTagName方法定义在Document.prototype和Element.prototype上 1234567891011121314例:选取 div 里面的 span &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;script&gt; var div = document.getElementsByTagName('dib')[0]; var span = document.getElementsByTagName('span')[0]; &lt;/script&gt; // &gt; span // &lt;· &lt;span&gt;1&lt;/span&gt;`开发中，经常利用先选择的父级，在他父级里面再次选什么元素来定位一个元素` var div = document.getElementsByTagName(&#39;*&#39;); 选择所有 四、HTMLDocument.prototype定义了一些常用的属性，body、head分别指代HTML文档中的&lt;body&gt;、&lt;head&gt;标签 123456例： // &gt; document.body // &lt;· &lt;body&gt;&lt;/body&gt; // &gt; document.head // &lt;· &lt;head&gt;&lt;/head&gt; 五、Document.prototype定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代&lt;html&gt;元素 123456例： // &gt; document.documentElement // &lt;· &lt;html lang='en'&gt; // &lt;head&gt;&lt;/head&gt; // &lt;body&gt;&lt;/body&gt; // &lt;/html&gt; 六、getElementsByClassName、querySelectorAll、querySelector在Document,Element类中均有定义div.getElementsByClassName(&#39;&#39;) 作业练习一、遍历元素节点数，要求不用 children 属性（在原型链上编程）1234567891011&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt; &lt;strong&gt;&lt;/strong&gt; &lt;b&gt;&lt;/b&gt; &lt;/span&gt;&lt;/div&gt;低级方法，给一个父节点，把子节点全部遍历出来，并打印高级方法：打印树形结构 → 分层打印出来 先看 div 再看子元素节点， 再挨个判断 二、封装函数，返回元素 e 的第 n 层祖先元素1234567891011121314151617181920212223242526&lt;body&gt; &lt;div&gt; &lt;strong&gt; &lt;span&gt; &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;/strong&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function retParent(elem,n)&#123; while(elem &amp; n)&#123; elem = elem.parentElement; n--; &#125; return elem; &#125; var i = document.getElementsByTagName('i')[0];&lt;/script&gt;// 从console输出 &gt; retParent(i,1) &lt;· &lt;span&gt;&lt;/span&gt; &gt; retParent(i,2) &lt;· &lt;strong&gt;&lt;/strong&gt; 三、封装函数，返回元素 e 的第 n 个兄弟节点，n为证，返回后面的兄弟节点，n 为负，返回前面的，n 为 0，返回自己12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt; &lt;strong&gt;&lt;/strong&gt; &lt;!-- this is comment --&gt; &lt;i&gt;&lt;/i&gt; &lt;address&gt;&lt;/address&gt;&lt;/div&gt;&lt;script&gt; function retSibling(e,n)&#123; while(e &amp;&amp; n)&#123; if(n &gt; 0)&#123; e = e.nextElementSibling; n--; &#125;else&#123; e = e.previousElementSibling; n++; &#125; &#125; return e; &#125; var strong = document.getElmentsByTagName('strong')[0];&lt;/script&gt;// 从console输出 // &gt; retSibling(strong,1) // &lt;· &lt;i&gt;​&lt;/i&gt;​ // &gt; retSibling(strong,2) // &lt;· &lt;address&gt;​&lt;/address&gt;​ // &gt; retSibling(strong,3) // &lt;· null // &gt; retSibling(strong,1000) // &lt;· null // &gt; retSibling(strong,-1) // &lt;· &lt;p&gt;​&lt;/p&gt;​ // &gt; retSibling(strong,-2) // &lt;· &lt;span&gt;​&lt;/span&gt;​ // &gt; retSibling(strong,-3) // &lt;· null // &gt; retSibling(strong,-300) // &lt;· null // &gt; retSibling(strong,0) // &lt;· &lt;strong&gt;​&lt;/strong&gt;​ 上面的 ie9 不兼容，考虑到兼容性，可以按照下面思路写 12345678910111213141516171819202122function retSibling(e,n)&#123; while(e &amp;&amp; n)&#123; if(n &gt; 0)&#123; if(e.nextElementSibling)&#123; e = e.nextElementSibling; &#125; else &#123; for(e = e.nextSibling; e &amp;&amp; e.nodeType != 1; e = e.nextSibling); &#125; n --; &#125; else &#123; if (e.previousElementSibling) &#123; e = e.previousElementSibling; &#125; else &#123; for (e = e.previousSibling; e &amp;&amp; e.nodeType != 1;e = e.previousSibling); &#125; n++; &#125; return e; &#125;&#125;`如果 for 循环执行体是空的，那么可以不写&#123;&#125;` 四、编辑函数，封装 children功能，解决以前部分浏览器的兼容问题12345678910111213141516171819202122232425&lt;div&gt; &lt;b&gt;&lt;/b&gt; abc &lt;!-- this is comment --&gt; &lt;strong&gt; &lt;span&gt; &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;/strong&gt; &lt;/div&gt;&lt;script&gt;Element.prototype.myChildren = function()&#123; var child = this.childNodes; var len = child.length; var arr = []; for(var i = 0;i &lt; len;i ++)&#123; if(child[i].nodeType == 1)&#123; arr.push(child[i]); &#125; &#125; return arr;&#125;var div = document.getElementsByName('div')[0];&lt;/script&gt; 五、自己封装 hasChildren()方法，不可以用children属性123456789101112131415&lt;script&gt; var i = document.getElementsByTagName('i')[0]; var div = document.getElementsByTagName('div')[0]; Element.prototype.myHasChildNodes = function()&#123; var child = this.childNodes; var len = child.length; for(var i = 0;i &lt; len; i++)&#123; if(child[i].nodeType == 1)&#123; return true; &#125; &#125; return flase; &#125;&lt;/script&gt; DOM 基本操作 - 增|插|删|替④增document.createElement(); — 增加或创建元素节点（标签） – 常用document.createTextNode(); — 创建文本节点document.createComment(); — 创建注释节点document.createDocumentFragment(); — 创建文档碎片节点插 — 剪切操作12345.appendChild()可以理解为.pushinsertBefore(a,b)一定是先insert a，before b，就是拿 a 插入到 b 的前面insertAfter(a,b)就是拿 a 插入到 b 的后面 appendChild().appendChild()可以理解为.push 12345678910例：把 span 插入到 div 里面 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;/body&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; var span = document.getElementsByTagName('span')[0]; div.appendChild(span); // -- 把 span 插入到 div 里面 &lt;/script&gt; 1234567891011把目标节点内部的节点上顺序逆序 Element.prototype.invertedChild = function()&#123; var child = this.children, len = child.length; for(var i = len - 2;i &gt;= 0;i --)&#123; this.appendChild(child[i]); &#125; return this; &#125; var div = document.getElementsByTagName('div')[0]; div.invertedChild(); insertBefore(a,b)insertBefore(a,b)一定是先insert a，before b，就是拿 a 插入到 b 的前面 1234567891011例：把 strong 插入到 span 的前面 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;/body&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; var span = document.getElementsByTagName('span')[0]; var strong = document.createElement('strong'); div.insertBefore(strong,span); // -- 把 strong 插入到 span 前面 &lt;/script&gt; insertAfter(a,b)insertAfter(a,b)一定是先insert a，before b，就是拿 a 插到 b 的后面 123456789101112131415161718192021222324`insertAfter 系统没有定义，所以是自己利用 insertBefore 来写的一个相反的方法`&lt;body&gt; &lt;div&gt; &lt;i&gt;&lt;/i&gt; &lt;b&gt;&lt;/b&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Element.prototype.insertAfter(targetNode,afterNode)&#123; var beforeNode = afterNode.nextElementSibling; if(beforeNode == null)&#123; this.appendChild(targetNode); &#125;else&#123; this.insertBefore(targetNode,beforeNode); &#125; &#125; var div = document.getElementsByTagName('div')[0]; var b = document.getElementsByTagName('b')[0]; var span = document.getElementsByTagName('span')[0]; var p = document.createElement('p');&lt;/script&gt; 删removeChild()就是被剪切出来了 123456789101112131415161718192021&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;&lt;/body&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; var span = document.getElementsByTagName('span')[0]; var strong = document.createElement('strong'); var i = document.create('i'); div.insertBefore(strong,span); div.insertBefore(i,strong);&lt;/script&gt;// 从console输出： // &gt; div.removeChild(i); // &lt;· &lt;i&gt;&lt;/i&gt; // &gt; var ii = div.removeChild(i); // &lt;· undefined // &gt; ii // &lt;· &lt;i&gt;&lt;/i&gt; remove()1234567891011121314151617181920&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;&lt;/body&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; var span = document.getElementsByTagName('span')[0]; var strong = document.createElement('strong'); var i = document.create('i'); div.insertBefore(strong,span); div.insertBefore(i,strong);&lt;/script&gt;// 从console输出： // &gt; i.remove() // &lt;· undefined // &gt; strong.remove(); // &lt;· undefined // &gt; span.remove() // &lt;· undefined 替换replaceChild(new,origin)replaceChild(new,origin); 用新的 new 去置换旧的 origin 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;&lt;/body&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; var span = document.getElementsByTagName('span')[0]; var strong = document.createElement('strong'); var i = document.create('i'); div.insertBefore(strong,span); div.insertBefore(i,strong); var p = document.createElement('p');&lt;/script&gt;// 从console输出： // &gt; div // &lt;· &lt;div&gt; // &lt;i&gt;&lt;/i&gt; // &lt;strong&gt;&lt;/strong&gt; // &lt;span&gt;&lt;/span&gt; // &lt;/div&gt; // &gt; div.replaceChild(p,strong) // &lt;· &lt;strong&gt;&lt;/strong&gt; // &gt; div // &lt;· &lt;div&gt; // &lt;i&gt;&lt;/i&gt; // &lt;p&gt;&lt;/p&gt; // &lt;span&gt;&lt;/span&gt; // &lt;/div&gt; DOM 基础操作 - Element节点的方法|属性⑤Element 节点的一些属性innerHTML \\ innerTextinnerHTML –&gt; 给 HTML文档赋值 – 可取，可写，可赋值，赋值之后覆盖原来的内容 123456789101112131415161718192021222324取：&lt;div&gt; &lt;span&gt;123&lt;/span&gt; &lt;strong&gt;234&lt;/strong&gt;&lt;/div&gt;// 从console输出： // &gt; div.innerHTML // &lt;· \" // &lt;span&gt;123&lt;/span&gt; // &lt;strong&gt;234&lt;/strong&gt; // \"写：&lt;div&gt; &lt;span&gt;123&lt;/span&gt; &lt;strong&gt;234&lt;/strong&gt;&lt;/div&gt;// 从console输出： // &gt; div.innerHTML = '123' // &lt;· '123' // &gt; div // &lt;· '123' -- 覆盖 innerText –&gt; 给HTML文档添加文本 – 可取，可赋值（老版本火狐不兼容）/ textContent（火狐使用这个，老版本 IE 不好使） 1234567891011121314&lt;div&gt; &lt;span&gt;234&lt;/span&gt;&lt;/div&gt;// 从console输出： // &gt; div // &lt;· &lt;div&gt;&lt;span&gt;234&lt;/span&lt;/div&gt; // &gt; div.innerText = 123 // &lt;· 123 // &gt; div // &lt;· &lt;div&gt;123&lt;/div&gt; -- 赋值要谨慎，因为赋值会把原来的文本覆盖 Element 节点的一些方法setAttribute \\ getAttributesetAttribute 设置，往元素里面写值（class，id）等等,比如： 1demo.setAttribute('属性名','属性值'); // 我们可以自己添加属性和属性值 getAttribute 取元素的值 12345678910111213141516171819&lt;div&gt; &lt;span&gt;234&lt;/span&gt;&lt;/div&gt;// 从console输出 // &gt; div.setAttribute('class','demo'); -- 添加 类.class // &lt;· undefined // &gt; div // &lt;· &lt;div class='demo'&gt;…&lt;/div&gt; // &gt; div.setAttribute('id','only'); -- 添加 id // &lt;· undefined // &gt; div // &lt;· &lt;div class='demo' id='only'&gt;…&lt;/div&gt; // &gt; div.getAttribute('id','only'); -- 取 id 值 // &lt;· undefined // &gt; div.getAttribute('id'); // &lt;· 'only' 123456789101112131415161718192021222324通过 div.setAttribute('id','only')动态的去改div的值 &lt;head&gt; &lt;style&gt; #only&#123; font-size: 20px; color:fff; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;234&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.onclick = function()&#123; this.setAttribute('id','only') &#125;&lt;/script&gt; data-log当满足一定条件时，if就可以动态操作了，配合事件连成整体操作 这个行间属性可以设置系统没有的。data-log是打点，点击率，这是人工设置的行间 属性，不是系统定义的 1234567891011如何去取这个 data-log？ &lt;div&gt; &lt;a href='#' data-log='0'&gt;hehe&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; var a = document.getElementsByTagName('a')[0]; a.onclick = function()&#123; console.log(this.getAttribute('data-log')); &#125; &lt;/script&gt; 12345678910给三个标签，让他们行间有一个属性 this-name，比如第一个 div，第二个span &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;strong&gt;&lt;/strong&gt; &lt;script&gt; var all = document.getElementsByTagName('*'); for(var i = 0;i &lt; all.length; i++)&#123; all[i]setAttribute('this-item',all[i].nodeName); &#125; &lt;/script&gt; 日期对象 Date() — 就是一种对象，是系统提供好的var date = new Date()大写的Date是系统提供的一个构造函数，通过new Date的方法会给我们返回一个对象，这个对象就是一个日期对象。日期对象有很多属性和方法。小的date代表此时此刻的时间。用小的date调用方法，如date.getDate() Date 对象属性（不够标准） 属性 : 描述 constructor : 返回对创建对象的Date`函数的引用。原型上的属性 prototype : 使您有能力向对象添加属性和方法。prototype`是构造函数的属性 Date 对象方法 `方法 ：描述 Date()———：返回当日的日期和时间 getDate()———：制作出对象，从 Date 对象返回一个月中的某一天（1 ~ 31） getDay()——：今天是一周的第几天，如果是 2 是星期二，但是是指第三天（第一天是周日，也就是 0）。从 Date 对象返回一周中的某一天（1 ~ 6） getMonth()——：一月份返回值是 0，从 Date 对象返回月份（0 ~ 11） getFullYear()——：从 Date 对象以四位数字返回年份 getYear()——：已废弃。请使用 getFullYear()` 方法代替 getHours()——：返回 Date 对象的小时（0 ~ 23） getMinutes()——：返回 Date 对象的分钟（0 ~ 59） getSeconds()——：返回 Date 对象的秒钟（0 ~ 59） getMilliseconds()——：返回 Date 对象的毫秒（0 ~ 999） getTime()——：返回 1970 年 1 月 1 日（纪元时刻）至今的毫秒数。经常用于项目的计算时间。获取时间戳 setDate()——：设置 Date 对象中月的某一天（1 ~ 31） setMonth()——：设置 Date 对象中月份（0 ~ 11） setFullYear()——：设置 Date 对象中的年份（四位数字） setYear()——：已废弃，请使用 setFullYea()方法代替 setHours()——：设置 Date 对象中的小时（0 ~ 23） setMinutes()——：设置 Date 对象中的分钟（0 ~ 59） setSeconds()——：设置 Date 对象中的秒钟（0 ~ 59） setMilliseconds()——：设置 Date 对象中的毫秒（0 ~ 999） setTime()———：以毫秒设置 Date 对象。机械之间交换时间 toSource()——：返回该对象的源代码 toString()——：把 Date 对象转换为字符串 toTimeString()——：把 Date 对象的时间部分转换为字符串 toDateString()——：把 Date 对象的日期部分转换为字符换 getUTC 一类，parse() 的没用，不放表格里面，可以在 w3school date 中查看全部 在控制台调用 date.getSeconds 就是 date 创建时间的毫秒数，是静止的，不是动态的。这个 date 对象记录的是出生的那一刻的时间，不是实时的。 123456例：利用 getTime() 计算程序计算的毫秒数var firstTime = new Date().getTime();for(var i = 0;i &lt; 1000000;i ++)&#123;&#125;var lastTime = new Date().getTime();console.log(lastTime - firstTime); 123456例：setDate()&gt; date.setDate(26)&lt;· 1580021359911&gt; date&lt;· Sun Jan 26 2020 14:49:19 GMT+0800 (中国标准时间) 123456789例：循环执行用 setIntervalvar date = new Date();date.setMinutes(54);setInterval(function()&#123; if(new Date.getTime() - date.getTime() &gt; 1000)&#123; console.log('什么什么什么！！！') &#125;&#125;,1000) 123456例：setTime()&gt; date.setTime(12345678900)&lt;· 12345678900&gt; date&lt;· Sun May 24 1970 05:21:18 GMT+0800 (中国标准时间) 12345678例：toString() 和 toTimeString() 和 toDateString()&gt; date.toString&lt;· \"Sun May 24 1970 05:21:18 GMT+0800 (中国标准时间)\"&gt; date.toTimeString()&lt;· \"05:21:18 GMT+0800 (中国标准时间)\"&gt; date.toDateString()&lt;· \"Sun May 24 1970\" 作业：封装函数，打印当前是何年何月何日何时，几分几秒 js 定时器一、setInterval() —- 定时循环器注意：setInterval(&quot;func()&quot;,1000);定时循环器 1234567891011例：setInterval(function()&#123;&#125;,1000);定时器，意思是 1000 毫秒执行一次这个函数var time = 1000;setInterval(function()&#123; console.log('a');&#125;,time)var time = 2000;`time = 2000 不能改变函数里面的时间，只能执行写在 time 的时间数``如果先定义 1000 毫秒，在后面改成 2000 毫秒，程序仍按 1000 毫秒执行，因为他只识别一次，不能通过改变 time 改变 setInterval 的快慢 ` 12345678例：查数var i = 0；setInterval(function()&#123; i ++; console.log(i);&#125;,1000) 1234567891011121314例：判断定时器准确不准确？var firstTime = new Date().getTime();setInterval(function()&#123; var lastTime = new Date().getTime(); console.log(lastTime - firstTime); firstTime = lastTime;&#125;,1000);`setInterval() 计算时间非常不准确`注意：`setInterval(); 是 window 的方法，在全局上就算不写 window.setInterval(); 他也会上全局的 GO 里面查找，所以不写 window 也行`·每一个 setInterval(); 都会返回一个一个数字，作为唯一的标识，有唯一标识就可以把他清除掉（利用 clearInterval() 清除）` 12345678910例：每一个 setInterval 都有着返回值，timer 是逐一罗列放下排序var timer = setInterval(function()&#123;&#125;,1000);var timer2 = setInterval(function()&#123;&#125;,1000);// 从 console.log 输出：// &gt; timer// &lt;· 1// &gt; timer2// &lt;· 2 二、clearInterval() —- 停止定时循环器（setInterval()）12345678910例：一般写了 setInterval() 就要写 clearInterval()// clearInterval();var i = 0;var timer = setInterval(function()&#123; console.log(i ++); if(i &gt; 10)&#123; clearInterval(timer); &#125;&#125;,10) 三、setTimeout() —- 真正的定时器,隔了一段时间后再执行（起推迟作用），并且 只执行一次1234567例：隔了 1000 毫秒才执行，并且只执行一次setTimeout(function()&#123; console.log('a');&#125;,1000);`常应用于电影试看 5 分钟` 四、clearTimeout() —- 清除 setTimeout(); 让他停止执行1234567例：这种写法，setTimeout();还没执行就被清除了，就执行不了了var timer = setTimeout(function()&#123; console.log('a');&#125;,1000)clearTimeout(timer); 123456789101112131415例：这个 timer = setTimeout();返回的唯一标识和 setInterval 返回的唯一标识是不会重叠的，他们两个是依次的var timer = setTimeout(function()&#123; console.log('a');&#125;,1000)var timer2 = setInterval(function()&#123;&#125;,1000);clearTimeout(timer);// 从 console 输出&gt; timer&lt;· 1&gt; timer2&lt;· 2 setInterval(); setTimeout(); clearInterval(); clearTimeout();这四个都是全局对象，都是window上的方法，内部函数function里面的this指向 window 1234例：setInterval(\"function()\",1000) 和 setTimeout(); 都有另一种形式展现，里面可以写成字符串，例如\"console.log('a');\"。但是一般用 function()&#123;&#125;setInterval(function()&#123;&#125;,1000); --- 标准形式setInterval(\"console.log('a');\",1000); --- 特殊形式，一般不这样写，意思是 1000 毫秒执行一次console.log 计时器作业计时器，到三分钟停止 定时器要计数，计完数以后要填到结构里面，下面的起的两个变量 minutes 和 seconds 用于计数，计完数以后要填到 dom 结构里面（元素标签最正确的说法是 dom结构， 因为他可以被 dom操作） 12345678910111213141516171819202122232425262728input&#123; border: 1px solid black; text-align: right; font-size: 20px; font-weight: bold;&#125;minutes:&lt;input type=\"text\" value='0'&gt;seconds:&lt;input type='text' value='0'&gt;var minutesNode = document.getElementsTagName = ('input')[0];var secondsNode = document.getElementsTagName = ('input')[1];var minutes = 0, seconds = 0;var timer = seInterval(function()&#123; var seconds = 0; if(seconds == 60)&#123; minutes ++; seconds = 0; &#125; minutesNode.value = minutes; secondsNode.value = seconds; if(minutes = 3)&#123; clearInterval(timer); &#125;&#125;,10) DOM / BOM 基本操作一、查看滚动条的滚动距离 window.pageXOffset（横向）/ pageYOffset（纵向） IE8及IE8以下不兼容（IE9部分不兼容）IE9以上能用 123例：滚动条往下滚动了 400px，求浏览器最顶端到滚动条滚动的位置的像素答：400px + 首屏像素（此时这个屏幕的底端距离整个王爷的最顶端也是这样算的） IE8及IE8以下的使用兼容方法 1)document.body.scrollLeft / scrollTop —- document.body.横向 / 纵向 2)document.documentElement.scrollLeft / scrollTop —- document.documentElement.横向 / 纵向 上面两个兼容性比较混乱，其中一个有值，另外一个的值一定是 0，这两个最好的用法是取两个值相加，因为不可能存在两个同时有值 例如：document.body.scrollLeft + document.documentElementscrollLeft 封装兼容方法（那个浏览器都好用），求滚动轮滚动距离 getScrollOffset() 12345678910111213function getScrollOffset()&#123; if(window.pageXOffset)&#123; return &#123; x : window.pageXOffset, y : window.pageYOffset &#125; &#125;else&#123; return &#123; x : document.body.scrollLeft + document.documentElement.scrollLeft, y : document.bodu.scrollTop + document.documentElement.scrollTop &#125; &#125;&#125; 二、查看视口的尺寸可视区窗口就是编写的 html 文档可以看到的部分，不含菜单栏、地址栏、控制台 注意渲染模式： 1234567891. 渲染模式 : &lt;! DOCTYPE html&gt; 是 html5 的（在 emmet 插件下 html:5 就出来了）2. 怪异/混杂模式 : 试图去兼容之前的语法，去掉&lt;!DOCTYPE html&gt;这一行即可开启（向后兼容）例：document.compatMode是判断是怪异模式还是标准模式 CSS1Compat -- 标准模式 BackCompat -- 怪异模式向后兼容 window.innerWidth / innerHeight 可视区域的宽高（加上 滚动条的宽度 / 高度） 123IE8 及 IE8 以下不兼容如果窗口放大页面了，页面的尺寸也会拉伸了，尺寸就会变小 document.documentElement.clientWidth / clientHeight 标准模式下，任意浏览器都兼容 document.body.clientWidth / clientHeight 适用于怪异渲染模式的浏览器 封装兼容性方法，返回浏览器视口尺寸 getViewportOffset() 12345`例：document.compatMode`是判断是怪异模式还是标准模式CSS1Compat -- 标准模式BackCompat -- 怪异模式向后兼容 1234567891011121314151617181920function getViewportOffset()&#123; if(window.innerWidth)&#123; return &#123; w : window.innerWidth, h : window.innerHeight &#125; &#125;else&#123; if(document.compatMode == 'CSS1Compat')&#123; return &#123; w : document.documentElement.clienWidth, h : document.documentElement.clienHeight &#125; &#125;else&#123; return &#123; w : document.body.clienWidth, h : document.body.clienHeight &#125; &#125; &#125;&#125; 三、查看元素的几何尺寸 domEle.getBoundingClientRect() – 查看元素的几何尺寸 domEle.getBoundingClientRect() 这是 es5.0 的方法，但只用了解 12345678910例： &gt; div.getBoundingClientRect(); &lt;· ClientRect bottom : 200 height : 100 left : 100 right : 200 top : 100 widht : 100 &gt; __proto__ : ClientRect 求的是四个边和窗口之间的像素距离，right 是右边离 document 的边有 200px，也可以理解成求的是左上点和右下点的位置 兼容性很好 该方法返回一个对象，对象里面有left,top,right,bottom等属性。left和top代表该元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标 height 和 width 属性老版本IE并未实现 在老版本的IE里面，利用右侧边right减左侧面left解决 返回的结果并不是实时的 dom.offsetWidth , dom.offsetHeight – 查看元素的宽/高 dom.offsetWidth 元素的宽 dom.offsetHeight 元素的高 求的值是包括 padding 的 dom.offsetWidth和domEle.getBoundingClientRect()出现的值是一样的，求的值是一样的，求的值都是padding + content（视觉尺寸），可以被代替。 四、查看元素的位置 dom.offsetLeft，dom.offsetTop – 查看元素的 x , y 轴位置 dom.offsetLeft 元素的 x 轴位置 dom.offsetTop 元素的 y 轴位置 对于无定位父级的元素，返回的是相对于文档的坐标 对于有定位父级的元素，返回相对于最近的有定位的父级的坐标（无论是 left 还是 margin-left 等都是距离） dom.offsetParent – 返回最近的有定位的父级 返回最近的有定位的父级，如无，返回body，body.offsetParent 返回 null 这个方法能求有定位的父级 12345678910111213141516171819202122例：求元素相对于文档的坐标，以`getElementPosition()`命名思路：先看有没有有定位的父级，如果有，先求他与有定位父级的距离，然后把视角换到他有定位的父级上，这他这个有定位的父级上还有没有有定位的父级，一段一段的加，一直加到最后，是一个循环递归的过程// 求元素相对于文档的坐标function getElementPosition(elem)&#123; if(!elem || !elem.offsetLeft)&#123; return null; &#125; var actualLeft = elem.offsetLeft, actualTop = elem.offsetTop, current = elem.offsetParent; // 取得元素的 offsetParent while(current !== null)&#123; actualLeft += current.offsetLeft; actualTOp += current.offestTop; current = current.offsetParent; &#125; return &#123; left : actualLeft, top : actualTop &#125;&#125; 1234567891011121314// 相对于父级的位置坐标function getElementPosition(ele)&#123; if(ele.offsetParent.nodeName = 'BODY')&#123; return &#123; left : ele.offsetLeft, top : ele.offsetTop &#125; &#125;else&#123; return &#123; left : ele.offsetLeft + getElementPosition(ele.offsetParent).left, top : ele.offsetTop + getElementPosition(ele.offsetParent).top &#125; &#125;&#125; 让滚动条滚动 window 上有三个方法 scroll(),scrollTo(),两个功能一样，scrollBy();累加滚动距离 window.scroll(x,y),scrollTo(x,y)功能是一样的，里面能填两个参数 window.sroll(x 轴滚动的距离，y 轴滚动的距离)，里面的 xy 可以填负数 window.scrollBy(x,y)是累加滚动距离，填负数就往上滚动 三个方法功能类似，用法都是将 x,y 坐标传入。即实现让滚动轮滚动到当前的位置 区别 : scrollBy() 会在之前的数据基础之上做累加 eg : 可以利用scrollBy()做快速阅读的功能 12345678910111213141516171819例:start = document.getElementsByTagName('div')[0];stop = document.getElementsByTagName('div')[1];var timer = 0;var key = true;start.onclick = function()&#123; if(key)&#123; timer = setInterval(function()&#123; window.scrollBy(0,10) &#125;,100) key = false; &#125;&#125;stop.onclick = function()&#123; clearsetInterval(timer); key = true;&#125; 脚本化 CSSdom不能操作css,是间接操作css,这一部分需要记下 一、读写元素 css 属性（间接控制） – dom.style.propdom.style.prop; 只有这个是可读可写的，其他属性都是只能读 1）可读写行间样式，没有兼容性问题，碰到float这样的关键字属性，前面应该加css（行间样式意外没有用） eg:flaot ————&gt; cssFloat,因为float属性在js里面是保留字，所以一般如果想要用float的话就用cssFloat 2）复合属性必须拆解（建议），组合单词变成小驼峰写法 3）写入的值必须是字符串格式 4）dom.style.prop 只能操作 css 行间样式 5）dom.style 属性。能拿，能写（通过写间接改变了 css 属性） 1234567891011例： &gt; div.style &lt;· CSSStyleDeclaration &#123;alignContent: \"\", alignItems: \"\",alignSelf: \"\", alignmentBaseline: \"\", all: \"\", …&#125; `CSSstyleDeclaration`是`css`样式表声明（类数组，有索引类的属性），把你能够用的所有的`css`都展示出来，里面不填写就是没有值是空串。 可以用`div.style['width']`拿出属性，也可以用`div.style.width`,效果一样。 在`js`访问属性的时候没有`-杠`的形式，不能写`background-color`，要写小驼峰。 不在`html`文件里面写的值也可以利用js调用，如`div.style.borderRadius=\"50\"` 二、查询计算样式 – window.getComputedStyle(ele,null)window.getComputedStyle(ele,null); 可以选取伪元素，并获取:window.getComputedStyle(ele,null);括号里面要填两个东西，第一个ele是填的你要获取谁，第二个先填写null（null解决的就是伪元素的问题，它可以填写伪元素，填null只是用于平常元素，在null的地方写入伪元素，就可以选择获取伪元素，用它可以获取伪元素的样式表） 1）window.getComputedStyle(ele,null); 原生底层方法，展示权重最高的 2）计算样式只读，不可以写入 3）返回的样式都是经过计算的，并且都是绝对值，没有相对单位，相对值会转换成绝对值显示 4）IE8及IE8以下不兼容 5）dom.style.prop 是取行间样式的值，取一个元素显示样式的值，window.getComputedStyle()更准 1234在控制台操作就能有一个 css 样式表（类数组）&gt; window.getComputedStyle(div,null)&lt;· CSSStyleDeclaration &#123;0: \"animation-delay\", 1: \"animation-direction\",2: \"animation-duration\", 3: \"animation-fill-mode\", 4: \"animation-iteration-count\", 5: \"animation-name\", 6: \"animation-play-state\"…… window.getComputedStyle 不管填不填值都有值，这里的值都是默认的，这回获取的是这个当前元素所展现出的 css 属性的显示值都是页面中展现的最终效果的值 1234567891011121314151617181920&lt;head&gt; &lt;style&gt; div&#123; font-size:10em; // 1em = 16px &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style='float:left;height:100px;background-color:red'&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; &lt;/script&gt;&lt;/body&gt;// 从console输出：&gt; window.getComputedStyle(div,null).width&lt;· 160px; // 10em = 160px&gt; window.getComputedStyle(div,null).backgroundColor&lt;· \"rgb(255,0,0))\" // red = rgb(255,0,0) 返回的样式都是经过计算的，并且都是绝对值，没有相对单位，相对值会转换成绝对值显示 三、查询样式 – ele.currentStyleele.currentStyle; 1）ele.currentStyle 展示权重最高的 2）计算样式只读，不可以写入 3）返回的计算样式的值不是经过转换的值，是原封不动的值 4）IE独有的属性，只能用于IE 123例：['width']写成`.width`也可以，推荐写`点 .`div.currentStyle['width'] == div.currentStyle.width 总结封装兼容性查询计算css样式方法 getStyle()12345678910function getStyle(elem,prop)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(elem,null)[prop];// 必须填写中括号 &#125;else&#123; return elem.currentStyle(prop); // 必须填写中括号 &#125;&#125;`function getStyle`(elem,prop)&#123;&#125;// elem 是指获取谁的（dom 元素），prop 是获取的是什么属性 详细介绍获取伪元素方法，改变伪元素例：理解 window.getComputedStyle(ele,null);第二个值是 null 获取伪元素的方法：window.getComputedStyle(ele,null);括号里面要填两个东西，第一 个ele是填的是你要获取谁，第二个先填写null（null解决的就是伪元素的问题，用它可以获取伪元素的样式表） 12345678910111213141516171819202122&lt;head&gt; &lt;style&gt; div::after&#123; content:\"\"; width:50px; height:50px; background-color:green; display:inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"float:left;height:100px;width:100px;background-color:red\"&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; window.getComputedStyle(div,\"after\"); &lt;/script&gt;&lt;/body&gt;window.getComputedStyle(div,“after”);就获取了伪元素的样式表，在控制台操作&gt; window.getComputedStyle(div,'after').width&lt;· '50px' 怎么改变伪元素; 改变伪元素并不一定要改变样式，可以改变 class; 12345678910111213141516171819202122232425262728293031323334353637383940&lt;head&gt; &lt;style&gt; .green::after&#123; content:\"\"; width:50px; height:50px; background-color:green; display:inline-block; &#125; .yellow::after&#123; content:\"\"; width:50px; height:50px; background-color:yelllow; display:inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"green\" style=\"float:left;height:100px;width:100px;background-color:red\"&gt;&lt;/div&gt; &lt;script&gt; var div = document.getElementsByTagName('div')[0]; var count = 0; div.onclick = function()&#123; count ++; if(count % 2 == 1)&#123; div.className = 'yellow'; &#125;else&#123; div.className = 'green'; // class 是保留字，所以用className &#125; &#125; &lt;/script&gt;&lt;/body&gt;// 如上`虽然我们通常用style改变css样式，但我们也可以通过改变class改变css样式``通过改变 class 来实现改变，改变状态位的操作``class 是保留字，所以要避开，用className` 小练习，让方块运动小方块持续运动; 123456789101112function getStyle(elem,prop)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(elem,null)[prop]; &#125;else&#123; return elem.currentStyle[prop]; &#125;&#125;var div = var document.getElementsByTagName('div')[0];setInterval(function()&#123; div.style.left = parseInt(getStyle(div,'left')) + 10 + 'px'&#125;,100) 加速运动,设置到一个时候就停止了; 1234567891011121314151617function getStyle(elem,prop)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(elem,null)[prop]; &#125;else&#123; return elem.currentStyle[prop]; &#125;&#125;var div = document.getElementsByTagName('div');var speed = 3;var timer = setInterval(function()&#123; div.style.left = parentInt(getStyle(div,'left')) + speed + 'px'; if(parentInt(div.style.left) &gt; 500)&#123; clearInterval(timer); &#125;&#125;,100) 事件什么是事件1）document.styleSheets 2）该属性存储了一个 html 文档里面的所有 css 样式表的集合事件（所有事件都是用的小写） 交互是你对页面动一下，页面给你一个反馈 何为事件？ – 就是一个动作，没有效果也是事件 重要吗？ – 交互体验的核心功能 12345678910演示 demo -- 点击事件&lt;div style=\"width: 100px;height: 100px;background-color:red\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.onclick = function()&#123; console.log('a'); // 点击之后控制台出现 a &#125;&lt;/script&gt; 绑定事件方法一、句柄绑定方式：’on’ + type（事件类型）句柄绑定方式：elem.’on’ + 事件类型 = function(event){}; 只可以用function来绑定事件，若绑定匿名函数，则无法解除 打个比方：click 点击事件 例：div.&#39;on&#39; + click = function(){} == div.onclick = function(){} 兼容性很好，但是一个元素只能绑定一个事件处理程序: 12345678910`例：div.onclick = function()&#123;&#125;`div.onclick 就叫做可以被点击的事件（绑定事件类型），`function()&#123;&#125;`是反馈，一旦事件被触发，就要执行`function`里面的函数（绑定的是一个事件处理函数）div.onclick = function()&#123; console.log('a');&#125;// b 覆盖了 a，这是赋值的原因div.onclick = function()&#123; console.log(b);&#125; 基本等同于写在 HTML 行间上，如下: 12345671. &lt;div onclick=\"console.log('a')\"&gt;&lt;/div&gt;2. div.onclick = function()&#123; console.log('a');&#125;1 和 2 的效果是一样的，只是书写方式不一样 onclick=&#39;console.log(&quot;a&quot;)&#39; 是句柄的绑定方式，写在行间不用写function(){} 二、常用写法：()elem.(type,function(){},false); IE9 以下不兼容，可以为一个事件绑定多个处理程序 div.(&#39;事件类型&#39;,处理函数,false); 123456789例：&lt;div style=\"widht:100px;height:100px;background-color:red;\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div'); div.addEventListener('click',function()&#123; console.log('a'); &#125;,false)&lt;/sript&gt; 1234567891011121314div.addEventListener('click',test,false);function()&#123;&#125; 是函数引用，和外面定义一个 function()&#123;&#125; 直接写 test 是一样的例：&lt;div style=\"widht:100px;height:100px;background-color:red\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.addEventListener('click',test,false); function test()&#123; console.log('a'); &#125;&lt;/script&gt; 时间有一个事件监听机制: 123456789101112131415例：一个事件绑定了两个处理函数&lt;div style=\"widht:100px;height:100px;background:red;\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.addEventListener('click',function()&#123; console.log('a'); &#125;,false); div.addEventListener('click',function()&#123; console.log('b'); &#125;,false)`console.log 打印出来是两个函数结果，这是两个处理函数，是两个地址，所以可以输出两个结果`&lt;/script&gt; 123456789101112131415例：下面只执行一个函数，这种写法是一个地址，一个人&lt;div style=\"widht:100px;height:100px;background:red;\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.addEventListener('click',test,false); div.addEventListener('click',test,false); function test()&#123; console.log('a'); &#125;`elem.addEventListener 不能给同一个函数绑定多次，重复的绑定一个函数就不可以用了,只能输出一个结果`&lt;/script&gt; 三、IE专用：attachEvent()div.attachEvent(‘on’ + click’ + function(){}); IE 独有，一个事件可以绑定多个处理程序，同一个函数绑定多次都可以 div.attachEvent(&#39;on&#39; + 事件类型，处理函数); div.attachEvent(&#39;onclick&#39;,function(){}) 12345678例： var div = document.getElementsByTagName('div')[0]; div.attachEvent('onclick',test,false); div.attachEvent('onclick',test,false); function test()&#123; console.log('a'); &#125; 1234567891011121314151617181920例：想给三个 li 都绑定这个事件&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var liCol = document.getElementsByTagName('div')[0], len = li.length; (function(i)&#123; for(var i = 0;i &lt; len; i++)&#123; liCol[i].addEventListener('click',function()&#123; console.log(i); &#125;,false) &#125; &#125;(i))&lt;/script&gt; 事件处理程序的运行环境 elem.onclick = function(){} 程序this指向是dom元素本身（指向自己） elem.addEventListener(type,fn,false) 程序this指向是dom元素本身（指向自己） elem.attachEvent(‘on’ + type,fn) 程序this指向window 可以通过call来指向自己 123456div.attachEvent('onclick',function()&#123; handle.call('div');&#125;)function handle()&#123; console.log('a');&#125; 封装绑定事件函数1234567891011function addEvent(elem, type, handle) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type, handle, false); &#125; else if (elem.attachEvent) &#123; elem['on' + type] = function () &#123; handle.call(elem); &#125; &#125; else &#123; elem[\"on\" + type] = handle; &#125;&#125; 解除事件绑定方法一、句柄方式解除绑定：elem.’on’ + type（事件类型） = false/nullelem.&#39;on&#39; + type = false/null; ==&gt; 就是解除 elem.&#39;on&#39; + type = function(e)){} 12345678910111213141516171819例：用 div.onclick = null; 解除事件&lt;div style=\"width:100px;height:100px;background-color:red\"&gt;&lt;/div&gt;&lt;script&gt;`直接解除事件，不可以再执行` var div = document.getElementsByTagName('div')[0]; div.onclick = function()&#123; console.log('a'); &#125; div.onclick = null;`只能执行一次的事件的写法` var div = document.getElementsByTagName('div')[0]; div.onclick = function()&#123; console.log('a'); this.onclick = null; &#125;&lt;/script&gt; 二、常用方式解除绑定：elem.removeEventListener(type,fn,false)elem.removeEventListener(type,function(){},false); div.removeEventListener(&#39;事件类型&#39;,处理函数,false); 12345678910例：elem.removeEventListener(type,fn,false);var div = document.getElementsByTagName('div')[0];div.addEventListener('click',test,false);function test()&#123; console.log('a'); this.removeEventListener('click',test,false);&#125;`test`如果填别的function()&#123;&#125;,就找不到他了，就没有办法清除，所以函数体一般要写在外面 三、IE专用方式解除：elem.detachEvent(‘on’ + type,fn)elem.detachEvent(‘on’ + click’ + function(){}); elem.detachEvent(&#39;on&#39; + 事件类型，处理函数); 12345678910例：div.detachEvent('onclick',test)var div = document.getElementsByTagName('div')[0]; div.attachEvent('onclick',test,false); div.attachEvent('onclick',test,false); function test()&#123; console.log('a'); this.detachEvent('onclick',test,false); &#125; 封装解除绑定函数1234567function removeEvent(elem, type, handle) &#123; if (elem.removeEventListener) &#123; elem.removeEventListener(type, handle, false); &#125; else &#123; elem.detachEvent('on' + type, handle); &#125;&#125; 事件处理模型 – 事件冒泡、捕获事件处理的两个模型：事件冒泡、捕获（不能同时存在） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;head&gt; &lt;style&gt; .wrapper&#123; width:300px; height:300px; background-color:red; &#125; .content&#123; width:200px; height:200px; bakground-color:green; &#125; .box&#123; width:100px; height:100px; background-color:orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/dvi&gt;&lt;/div&gt; &lt;script&gt; var wrapper = document.getElementsByClassName('wrapper')[0]; var content = document.getElementsByClassName('content')[0]; var box = document.getElementsByClassName('box')[0]; wrapper.addEventListener('click',function()&#123; console.log('wrapper'); &#125;,false) content.addEventListener('click',function()&#123; console.log('content'); &#125;,false) box.addEventListener('click',function()&#123; console.log('content'); &#125;,false) &lt;/script&gt;&lt;/body&gt;// 从控制台输出：// &gt; box// content// wrapper`只是点了黄色区域，但是出现了 box，content，wrapper 三个结果，往下漏了，这就是事件冒泡` 事件冒泡结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，及同一事件，自子元素冒泡向父元素（自底向上）; 结构上存在父子关系的元素，如果点击到子元素，会一级一级向父元素传递这个事件（从代码的角度是自底向上一层一层冒泡的） 123456789101112131415161718192021222324252627例：加了 margin，只点黄色方块，还是出现了 box，content，wrapper。所以与视觉无关&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/dvi&gt;&lt;/div&gt;var wrapper = document.getElementsByClassName('wrapper')[0];var content = document.getElementsByClassName('content')[0];var box = document.getElementsByClassName('box')[0];wrapper.addEventListener('click',function()&#123; console.log('wrapper');&#125;,false)content.addEventListener('click',function()&#123; console.log('content');&#125;,false)box.addEventListener('click',function()&#123; console.log('content');&#125;,false)// 从控制台输出：// &gt; box// content// wrapper`加了 margin，只点黄色区域，还是出现了 box，content，wrapper 三种结果，所以与视觉无关` 事件捕获1）结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，及同一事件，自父元素捕获至子元素（事件源元素）（自顶向下）; 2）IE 没有捕获事件; 一个对象的一个事件类型，只能存在一个事件处理模型（冒泡或捕获） elem.addEventListener(type,fn,true);第三个参数就是事件捕获，把false改为true 1234567891011121314151617181920212223242526例：把 false改成 true，就变成了事件捕获，只把 false 改成 true 就变成事件捕获了&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/dvi&gt;&lt;/div&gt;var wrapper = document.getElementsByClassName('wrapper')[0];var content = document.getElementsByClassName('content')[0];var box = document.getElementsByClassName('box')[0];wrapper.addEventListener('click',function()&#123; console.log('wrapper');&#125;,true)content.addEventListener('click',function()&#123; console.log('content');&#125;,true)box.addEventListener('click',function()&#123; console.log('content');&#125;,true)// 从控制台输出：// &gt; wrapper// content// box 结果和事件冒泡结果反了过来，先红色区域捕获事件并且执行，再绿色区域捕获事件并且实行，最后只执行事件黄色区域。_捕获是把结构的最外面先抓住_。最外面先捕获，再一层层向里面捕获，最里面的是按常规执行 思考：同一个对象的同一个事件类型，上面绑定了两个事件处理函数，一个符合冒泡，一个符合捕获，点一个元素后，是先捕获，还是先冒泡？ 3）触发顺序，先捕获，后冒泡; 同一个对象的一个事件处理类型，上面绑定了两个事件处理，分别执行事件冒泡和时间执行 123456789101112131415161718192021222324252627282930// 沿用上面代码wrapper.addEventListener('click',function()&#123; console.log('wrapper');&#125;,true)content.addEventListener('click',function()&#123; console.log('content');&#125;,true)box.addEventListener('click',function()&#123; console.log('content');&#125;,true)wrapper.addEventListener('click',function()&#123; console.log('wrapper');&#125;,false)content.addEventListener('click',function()&#123; console.log('content');&#125;,false)box.addEventListener('click',function()&#123; console.log('content');&#125;,false)// 从控制台输出// wrapper// content// box// boxBubble// contentBubble// wrapperBubble`先捕获，后冒泡` 12345678910111213141516171819202122232425262728// 改变一下冒泡，捕获的顺序wrapper.addEventListener('click',function()&#123; console.log('wrapper');&#125;,false)content.addEventListener('click',function()&#123; console.log('content');&#125;,false)box.addEventListener('click',function()&#123; console.log('content');&#125;,false)wrapper.addEventListener('click',function()&#123; console.log('wrapper');&#125;,true)content.addEventListener('click',function()&#123; console.log('content');&#125;,true)box.addEventListener('click',function()&#123; console.log('content');&#125;,true)// 从控制台输出// wrapper// content// boxBubble// box// contentBubble// wrapperBubble 顺序是先捕获红色，在捕获绿色，boxBubble黄色区域执行，box黄色区域执行，冒泡到绿色，冒泡到红色（谁先绑定，谁先执行，boxBubble 先绑定，所以先执行） 4）focus，blur，change，submit，reset，select 等事件不冒泡; 取消冒泡和阻止默认事件1234567891011例：给 div 绑定一个事件，也给document绑定一个事件（点击div，也冒泡到document）&lt;div style=\"width:100px;height:100px;background-color:red;\"&gt;&lt;/div&gt;document.onclick = function()&#123; console.log('你闲的啊！')&#125;var div = document.getElementsByTagName('div')[0];div.onclick = function()&#123; this.style.background = 'green';&#125; 在每一个事件处理函数中【div.onclick = function(){}】,我们可以写一个形参（如e），系统可以传递 事件对象（记载了数据发生时的状态和信息） 到这个参数里面去 一、取消冒泡1）W3C标准：event.stopPropagation() event.stopPropagation(); – 但不支持 ie9 以下版本 123456789101112例：事件对象上有一个 event.stopPropagation() 取消冒泡事件&lt;div style=\"width:100px;height:100px;background-color:red;\"&gt;&lt;/div&gt;document.onclick = function()&#123; console.log('你闲的啊啊');&#125;var div = document.getElementsByTagName('div')[0];div.onclick = function(e)&#123; e.stopPropagation(); this.tyle.background='green';&#125; 2）IE专用：event.cancelBubble = true12345678910111213例：ie 里面事件对象上有一个 event.cancelBubble = true;能取消冒泡事件&lt;div style=\"width:100px;height:100px;background-color:red;\"&gt;&lt;/div&gt;document.onclick = function()&#123; console.log('你闲的啊啊');&#125;var div = document.getElementsByTagName('div')[0];div.onclick = function(e)&#123; e || window.event; // 解决 ie 兼容问题 e.cancelBubble = true; this.tyle.background='green';&#125; 封装取消冒泡函数 stopBubble(event)12345678function stopBubble(event)&#123; event || window.event; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; 二、阻止默认事件什么是默认事件 – 表单提交，a 标签跳转，右键菜单等12345例：浏览器点击右键出菜单，是一个事件（默认事件）document.oncontextmenu = function()&#123; console.log('a'); // 在网页中鼠标右键控制台打印 'a'&#125; 1）句柄阻止默认事件方式：return false兼容性非常好，以对象属性的方式注册的事件才生效（这是句柄的方式阻止默认事件，只有句柄的方式绑定事件才好使）; return false 是只有句柄绑定方式才可以用的阻止默认事件方式 12345例：document.oncontextmenu = function()&#123; console.log('a'); return false; // 在网页右键点击的时候不会出现菜单了，但还在控制台打印 'a'&#125; 2）W3C标准：event.preventDefault() event.preventDefault(); W3C标注，IE9以下不兼容 123456例：document.oncontextmenu = function(e)&#123; console.log('a'); e.preventDefault();&#125; 3）兼容IE：event.returnValue = false event.returnValue = false — 兼容IE 12345document.oncontextmenu = function(e)&#123; e = e || window.event; // 兼容IE console.log('a'); e.returnValue = false;&#125; 封装阻止默认事件的函数 cancelHandler(event)1234567function cancelHandler(event)&#123; if(event &amp;&amp; event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; widnow.event.returnValue = false; &#125;&#125; 123456789101112131415例：a 标签有一个跳转的默认事件a.onclick = function()&#123; return false; // 句柄阻止方式&#125;a.addEventListener(e)&#123; e.preventDefault(); // w3c 标准阻止方式&#125;a.addEventListener(e)&#123; window.e.returnValue = false; // IE阻止方式&#125;&lt;a href='javascript:void(false)'&gt;&lt;/a&gt; // 直接在 a 标签加入也可以 事件对象非 ie 浏览器会把事件对象（记载了数据发生时的状态和信息）打包传到参数里面去 ie 浏览器在 window.evnet 里面储存事件对象 12345678例：&lt;div style=\"widht:100px;height:100px;background-color:red\"&gt;&lt;/div&gt;var div = document.getElementsByTagName('div')[0];div.onclick = function(e)&#123; console.log(e); // 非 ie 浏览器会记录事件对象&#125; 一、event || window.event 用于IE兼容window.event 用于IE，event 只能用于非 ie 浏览器 1234567891011121314例：这是储存事件对象的兼容性写法var div = document.getElementsByTagName('div')[0];div.onclick = function(e)&#123; var event = e || window.event; console.log(event);&#125;// 从控制台输出：// MouseEvent &#123;isTrusted: true, screenX: 966, screenY: 174, clientX: 86, clientY: 36, …&#125;// clientX : 76// clientY : 77// 鼠标坐标点，可以用这个来记录鼠标坐标点 事件对象上有个专门的信息是存储事件源的。就是 srcElement 属性，可以查看事件源 12345678910111213例：&lt;div class=\"wrapper\" style=\"width:100px;height:100px;background-color:red;\"&gt; &lt;div class=\"box\" style=\"width:50px;height:50px;background-color:green;\"&gt;&lt;/div&gt;&lt;/div&gt;var wrapper = document.getElementsByClassName('wrapper')[0];var box = document.getElementsByClassName('box')[0];wrapper.onclick = function(e)&#123; var event = e || window.event; console.log(event);&#125; 点红色会执行，点绿色会冒泡执行。点红色是点击到他自己来执行;点绿色身上，触发事件的点在绿色身上，是绿色传递的，我们把 触发事件的地方叫做事件源。 事件源对象（找事件源对象的方法）event.target – 火狐独有的; event.srcElement – IE独有的; 这俩 chrome 都有; 1234567891011121314例：时间源对象的兼容性写法&lt;div class=\"wrapper\" style=\"width:100px;height:100px;background-color:red;\"&gt; &lt;div class=\"box\" style=\"width:50px;height:50px;background-color:green;\"&gt;&lt;/div&gt;&lt;/div&gt;var wrapper = document.getElementsByClassName('wrapper')[0];var box = document.getElementsByClassName('box')[0];wrapper.onclick = function(e)&#123; var event = e || window.event; var target = event.target || event.srcElement; console.log(target);&#125; 事件委托123456789101112131415161718192021222324例：我们给每个 li 绑定事件，要求点那个 li 就输出那个内容，这不涉及闭包问题&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt;&lt;/ul&gt;var li = document.getElementsByTagName('li');var len = li.length;for(var i = 0;i &lt; len;i ++)&#123; li[i].onclick = function()&#123; console.log(this.innerText); &#125;&#125;// 上面的写法不是很好（如果是三千亿个li就没有效率了）不能动态，要用事件源和事件冒泡解决 事件委托：利用事件冒泡，和事件源对象进行处理; 优点： 性能 不需要循环所有的子元素一个一个绑定事件 灵活 当有新的子元素不需要重新绑定事件 1234567891011121314151617181920例：给每个 li 绑定事件，再增加 li 也能使用&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt;&lt;/ul&gt;var ul = document.getElementsByTagName('ul')[0];ul.onclick = function(e)&#123; var event = e || window.event; var target = event.target || event.srcElement; console.log(target.innerText);&#125; 面试问题： 什么是事件捕获，一个是冒泡，一个是捕获，第二种捕获不是事件处理模型，而是一种真实的事件获取的过程，用于解决拖拽出方块的问题 第二种捕获仅在 IE 好使，利用 div.setCapture(); 会捕获页面上发生的所有事情，都获取到自己身上。对应的用 div.releaseCapture();释放。但是方法比较老旧，一般不用。 事件分类鼠标事件 不需要小驼峰和大驼峰 W3C 标准规定：click 事件只能监听左键，只能通过 mousedown 和 mouseup 来判断鼠标键; 如何解决 mousedown 和 click 的冲突; 移动端 onmousedown 不能用，只能用 touchstart，touchmove，touchend; 12345678910111213141516171819onclick | 鼠标点击事件onmousedown | 鼠标按键被按下时执行函数onmouseup | 鼠标按键被松开时执行函数onmousemove | 鼠标移动到指定元素上移动时执行函数contextmenu | 右键取消菜单事件onmouseover | 鼠标指针移动到元素上执行函数 -- 支持冒泡onmouseout | 鼠标在移出指针时执行函数 -- 支持冒泡onmouseenter | 鼠标指针移动到元素上执行函数 - 不支持冒泡 - html5onmouseleave | 鼠标在移出指针时执行函数 - 不支持冒泡 - html5ondblclick | 当用户双击某个对象时触发 click = mousedown + mousemove; 12345678910111213141516例：click = mousedown + mousemovedocument.onclick = function()&#123; console.log('click');&#125;document.onmousedown = function()&#123; console.log('mousedown');&#125;document.onmouseup = function()&#123; console.log('mouseup');&#125;// mousedown// mouseup// click`触发顺序是：mousedown、mouseup、click` 用 button 来区分鼠标的按键; 只有 mouseup、mousedown两个事件可以区分鼠标左右键 button返回值：右键：2，左键：0，滚轮：1 123456789document.onmousedown = function (e) &#123; if (e.button == 2) &#123; console.log('2,right'); &#125; else if (e.button == 0) &#123; console.log('0,left'); &#125; else if (e.button == 1)&#123; console.log('1,middle'); &#125;&#125; 键盘事件 触发顺序是 keydown &gt; keypress &gt; keyup 12345onkeydown | 事件会在用户按下一个键盘按键时发生onkeyup | 事件会在键盘按键被松开时发生onkeypress | 事件会在键盘按键被按下并释放一个键时发生 1）keydown 和 keypress 的区别: i ：keydown 可以响应任意键盘按键，keypress 只可以响应字符类键盘按键; 检测字符不准确，keypress 检测字符很准确。但是 keydown 能监控所有，包括上下左右都能监控，但是 keypress 只能监控字符。 用法：如果你想监控字符类按键，并想区分大小写，就用 keypress，如果是操作类按键的话，就用 keydown 上的 which 属性来区分按键（which：39 是给按键牌号 39，不是 ascii 码） ii ：keypress 返回的 ASCII 码，可以转换为相应字符; 1234567891011121314151617例：连续按键盘的时候就是连续触发 keydown 和 keypress，松开触发 keyupdocument.onkeypress = function()&#123; console.log('keypress');&#125;document.onkeydown = function()&#123; console.log('keydown');&#125;document.onkeyup = function()&#123; console.log('keyup');&#125;// keydown// keypress// keyup注意：游戏触发设置在 keydown 上，机械键盘抬起速度快反馈力量大，对游戏没用 charCode：获取按下的键盘按键 Unicode 编码值; 静态 String.fromCharCode() 方法返回由指定的 Unicode 编码转换为输入的键; 12345例：利用下面，把 Unicode 编码转成对应值document.onkeypress = function(e)&#123; console.log(String.fromCharCode(e.charCode));&#125; 表单事件12345678910111213141516171819oninput | 在用户输入时触发（有变化（增删改）都会触发 input 事件）onchange | 事件会在输入的内容改变时触发（点击别的物体时触发）onfocus | 事件在对象获得焦点时发生onblur | 事件会在对象失去焦点时发生onreset | 表单重置时触发onsearch | 用户向搜索域输入文本时触发 (&lt;input=\"search\"&gt;)onselect | 用户选取文本时触发 (&lt;input&gt; 和 &lt;textarea&gt;)onsubmit | 表单提交时触发onfocusin | 元素即将获取焦点时触发onfocusout | 元素即将失去焦点时触发 input: 12345678例如：input 框里面所以有变化（增删改）都会触发 input 事件&lt;input type=\"text/css\"&gt;var input = document.getElementsByTagName('div')[0];input.oninput = function(e)&#123; console.log(this.value);&#125; change: 12345678例：change 对比鼠标聚焦，或失去焦点时，两个状态是否发生改变，如果两个状态没有改变就不触发，如果发生改变就触发&lt;input type=\"text/css\"&gt;var input = document.getElementsByTagName('input')[0];input.onchange = function(e)&#123; console.log(this.value);&#125; focus，blur: 1&lt;input type=\"text/css\" value=\"请输入用户名\" style=\"color:#999\" onfocus=\"if(this.value == '请输入用户名')&#123;this.value = '';this.style.color='#424242'&#125;\" onblur=\"if(this.value == '')&#123;this.value = '请输入用户名';this.style.color='#999'&#125;\"&gt; 鼠标键盘事件对象属性1234567891011121314151617181920212223242526272829altKey | 返回当事件被触发时，\"ALT\" 是否被按下。button | 返回当事件被触发时，哪个鼠标按钮被点击。clientX | 返回当事件被触发时，鼠标指针的水平坐标。clientY | 返回当事件被触发时，鼠标指针的垂直坐标。ctrlKey | 返回当事件被触发时，\"CTRL\" 键是否被按下。Location | 返回按键在设备上的位置charCode | 返回onkeypress事件触发键值的字母代码。key | 在按下按键时返回按键的标识符。keyCode | 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。which | 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。metaKey | 返回当事件被触发时，\"meta\" 键是否被按下。relatedTarget | 返回与事件的目标节点相关的节点。screenX | 返回当某个事件被触发时，鼠标指针的水平坐标。screenY | 返回当某个事件被触发时，鼠标指针的垂直坐标。shiftKey | 返回当事件被触发时，\"SHIFT\" 键是否被按下。 窗体操作类（window 上的事件）onscroll，onload123onload | 事件会在页面或图像加载完成后立即发生（所有页面加载完毕，才能执行）onscroll | 事件在元素滚动条在滚动时触发 onscroll: 12345例：scroll 当滚动条一滚动，scroll 事件就触发了window.onscroll = function()&#123; console.log(window.pageXOffset + \" \" + window.pageYOffset);&#125; ie6没有fixed定位，就用position的top = 原来的 top + 滚动条的位置来写。absolute定位相对于文档定位，就用absolute定位模拟fixed定位，挪动距离加载absolute的top上读到js的时候就阻断页面，所以必须把js写在下面才能把上面的东西读出来 onload: 123456789例：load重要但是不用。window.onload 发生在什么时候window.onload = function()&#123; var div = document.getElementsByTagName('div')[0]; console.log(div); div.style.width = '100px'; div.style.height = '100px'; div.style.backgroundColor = 'red';&#125; 利用了 onload 就能操作写在下面的 div 了，但是我们不能这样用 理由：html 和 css 是一起解析的，在解析的时候会有 html 有 domTree，css 有 cssTree 生成（树形图的顶底是 document，然后是html，然后是 head，body） ，两个树拼在 一起是 renderTree 什么时候把节点放在树里？dom节点解析，如确定是 img 标签就把他放到树里。（先 解析完 img，同时开启一个线程异步的去下载里面的内容，后下载完） 我们把 js 的 script 标签写在最下面的好处是，这些刚刚解析完 js 就能操作页面了， 就更快了。而 window.onload 要等整个页面解析完，下载完才能操作 js，才能触发事 件（效率很差） onload 能提醒我们什么时候整个页面解析完毕。在设计广告时，就 要用 onload，等整个页面下载完了才开始用，但是onload 绝对用于主程序里面 练习总结一、封装拖拽元素函数（不兼容）12345678910111213141516171819202122232425262728293031function drag(elem) &#123; addEventListener(elem, 'mousedown', function (e) &#123; var e = e || window.event; var diX = e.clientX - elem.offsetLeft; var diY = e.clientY - elem.offsetTop; elem.addEventListener('mousemove', mouseMove, false); elem.addEventListener('mouseup', mouseUp, false); &#125;); function mouseMove(e) &#123; var e = e || widow.event; var left = e.clientX - diX; var top = e.clientY - diY; if (left &lt; 0) &#123; left = 0; &#125; else if (left &gt; window.innerWidth - elem.innerWidth) &#123; left = window.innerWidth - elem.innerWidth; &#125; if (top &lt; 0) &#123; top = 0; &#125; else if (top &gt; window.innerHeight - elem.innerHeight) &#123; top = window.innerHeight - elem.innerHeight; &#125; elem.style.left = left + 'px' elem.style.top = top + 'px' &#125; function mouseUp(e) &#123; var e = e || window.event; elem.removeEventListener('click', mouseMove, false); elem.removeEventListener('click', mouseUp, false); &#125;&#125; 二、输入框功能完善123&lt;input type=\"text\" value=\"请输入用户名\" style=\"color:#999\"onfocus=\"if(this.value == '请输入用户名')&#123;this.value = '';this.style.color = '#424242'&#125;\"onblur=\"if(this.value == '')&#123;this.value = '请输入用户名';this.style.color = '#999'&#125;\"&gt; 三、提取密码框的密码123456var input = document.getElementsByTagName('input')[0];input.onkeypress = function(e)&#123; var e = e || window.event; var test = String.fromCharCode(e.charCode); console.log(test);&#125; 四、轮播图五、贪吃蛇游戏六、扫雷游戏JSON和异步加载jsJSONJSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的） JSON.parse(); JSON ————&gt; String JSON.stringify(); String ————&gt; JSON 12345678例如：json的属性名必须加双引号（传的是二进制文本）`json 格式`&#123; \"name\" : \"deng\", \"age\" : 123&#125; 1234567var obj = &#123; \"name\" : \"abc\", \"age\" : 123&#125;// JSON.stringify(obj)// \"&#123;\"name\":\"abc\",\"age\":\"123\"&#125;\" 123456789101112var obj = &#123; \"name\" : \"abc\", \"age\" : 123&#125;var str = JSON.stringify(obj);// str// \"&#123;\"name\":\"abc\",\"age\":\"123\"&#125;\"// JSON.parse(str)// Object &#123;name: \"abc\", age: 123&#125; 异步加载Js js是单线程的，会阻断 HTML，css 加载（因为js会修改 html 和 css 一起加载会乱），所以是同步加载 js。先下载 js，在下载 HTML 和 css。常规来说 js 是同步加载的，所以我们讲讲 js 异步加载的情况; js加载的缺点：加载工具方法没必要阻塞文档，过的 js 加载会影响页面效率，一旦网速不好，那么整个网站将等待 js 加载而不进行后续渲染等工作; 有些工具方法需要按需加载，用到再加载，不用不加载; javascript 异步加载的三种方案 一、IE专用 deferdefer异步加载，但要等到 dom 文档全部解析完成（dom 树生成完）才会被执行。只有 IE 能用 1234567&lt;script type=\"text/javascript\" scr=\"xxx\" defer=\"defer\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" scr=\"xxx\" defer=\"defer\"&gt; console.log('a');&lt;/script&gt;`两种方法,可以在内部用，也可以再外部用` 二、w3c标准 asyncasync 异步加载，加载完就执行，async 只能加载外部脚本，不能把 js 写在 script 标签里，ie9 以上可以用，w3c 标准 123&lt;script type=\"text/javascript\" scr=\"xxx\" async=\"async\"&gt;&lt;/script&gt;`只有一种方法,只能加载外部脚本` 三、创建 script创建script，插入到 DOM 中，加载完毕后callBack（按需加载，方便） –&gt; 常用 12345678例：var script = document.createElement('script');script.type = 'text/javascript';script.src = 'tools.js';document.head.appendChild(script); // 如果不写这一段，就是只加载，不执行，像这样写了执行以后才执行setTimeout(function()&#123; test(); // 这个test函数是 tools.js 里面的函数，执行的是tools.js的函数&#125;,1000) 为什么要用 setTimeout（定时器）呢？因为还没有下载完成，因为程序执行时非常快的，当程序读到 document.head 读到 test(); 时，上面的 script.type 和 script.src 还没有下载完，所以执行不了。所以，能不能有一个东西提示我们，他下载完了我们再用? 方法一用 onload 方法 非 ie 方法，script.onload = function(){},触发 script.onload 事件就代表他下载完了，当他们下载完了再执行 test. 1234567var script = document.createElement('script');script.type = 'text/javascript';script.src = 'tools.js';script.onload = function() &#123; test(); // test 函数是 tools.js 的函数，执行的也是 tools.js 的函数&#125;document.head.appendChild(script); 方法二ie 上有一个状态码，script.readyState，功能与 script.onlaod 相似。 script.readyState = ‘loading’; 最开始的值; script.readyState = ‘complete’ 或者 ‘leaded’ 表示加载完成; 12345678910111213141516171819我们封装一个函数：function loadScript(url,callback)&#123; var script = document.createElement('script'); script.type = 'text/javascript'; if(script.readyState)&#123; script.onreadystatechenge = function () &#123; if(script.readyState == 'complete' || script.readyState == 'loaded')&#123; callback(); &#125; &#125; &#125;else&#123; script.onload = function () &#123; callback(); &#125; &#125; script.src = url; document.head.appendChild(script);&#125; 时间里面有一个绑定的事件处理函数，当满足一定执行条件才执行的函数叫做回调函数，回调函数叫 callback 12345678910111213141516function loadScript(url,callback)&#123;…&#125;loadScript('tools.js',test); // test 是 tools.js 里面的函数，调用的是 tools.js 的函数// 从控制台输出：报错执行顺序：先 function loadScript()&#123;&#125;【不会看里面的代码是什么】再 loadScript() 【这一步的时候不知道 test 是什么】然后执行`function`里面的内容，为了解决上面的问题，如下例：function loadScript(url,callback)&#123;…&#125;loadScript('tools.js',function () &#123; test();&#125;);这样，用一个`function`来做第二个参数，而`function`里面则执行函数，这样也没有问题 js时间线js加载时间线：依据 js 出生的那一刻起，记录了一系列浏览器按照顺序做的事情（就是一个执行顺序） 时间线步骤（创建 document 对象 ==&gt; 文档解析完 ==&gt; 文档解析完加载完执行完）: 创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = &#39;loading&#39;。 遇到link外部css创建线程，进行异步加载，并继续解析文档。 遇到script外部js,并且没有设置async、defer,浏览器同步加载，并阻塞，等待 js 加载完成并执行该脚本，然后继续解析文档。 遇到script外部 js，并且设置有async、defer，浏览器创建线程异步加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用 document.write()，因为当你整个文档解析到差不多，再调用document.write()会把之前所有的文档流都清空，用里面的文档代替） 遇到img等（带有src），先正常解析 dom 结构，然后浏览器异步加载src，并继续解析文档。看到标签直接生产dom树，不用等着img加载完src。 当文档解析完成（domTree建立完毕，不是加载完毕），document.readyState = &#39;interactive&#39;。 文档解析完成后，所有设置有 defer 的脚本会按照顺序执行。（注意与async的不同，但同样禁止使用document.write()）; document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 当所有async的脚本加载完成并执行后、img等加载完成后（页面所有的都执行加载完之后），document.readyState = &#39;complete&#39;，&#39;window&#39;对象触发load 事件。 从此，以异步响应方式处理用户输入、网络事件等。 123456789例：异步加载禁止使用 document.write()&lt;div style=\"width:100px;height:100px;bakground-color:red\"&gt;&lt;/div&gt;// 用window.onload 会等整个页面执行加载完才执行，消除文档流（把自己都给删了）&lt;script&gt; window.onload = function () &#123; document.write('a'); &#125;&lt;/script&gt; 1234567891011121314例：执行到 document.readyState 时，整个 dom 树还没有解析完成，所以不会是 interactive&lt;div style=\"width:100px;height:100px;bakground-color:red\"&gt;&lt;/div&gt;&lt;script&gt; console.log(document.readyState);&lt;/script&gt;&lt;script&gt; console.log(document.readyState);&lt;/script&gt;// 从控制台输出：// &gt; loading// &gt; loading 1234567891011121314例：我们就利用 window.onload 事件，看到的是 complete,代表执行加载完&lt;div style=\"width:100px;height:100px;bakground-color:red\"&gt;&lt;/div&gt;// 用window.onload 会等整个页面执行加载完才执行，消除文档流（把自己都给删了）&lt;script&gt; console.log(document.readyState); window.onload = function () &#123; console.log(document.readyState); &#125;&lt;/script&gt;// 从控制台输出：// &gt; loading// &gt; complete 123456789101112131415例：如果想要看到 interactive，就用 onreadystatechenge 事件。&lt;div style=\"width:100px;height:100px;bakground-color:red\"&gt;&lt;/div&gt;&lt;script&gt; console.log(document.readyState); document.onreadystatechenge = function () &#123; // 所有事件都是用小写 console.log(document.readayState); &#125;&lt;/script&gt;// 从控制台输出：// &gt; loading// &gt; interactive// &gt; complete 1234567891011121314151617181920例：DOMContentloadend 事件只能用在 addEvventListener 事件绑定上面&lt;div style=\"width:100px;height:100px;bakground-color:red\"&gt;&lt;/div&gt;&lt;script&gt; console.log(document.readyState); document.onreadystatechange = function () &#123; console.log(document.readyState); &#125; document.addEventListener('DOMContentloaded',function()&#123; console.log('a'); &#125;,false);&lt;/script&gt;// 从控制台输出：// &gt; loading// &gt; interactive// &gt; a// &gt; complete 123456789101112通用写法是把 JS 的 script 写在最下面，为什么我们要把他写在最下面？写在最下面意味着上面的 dom 已经处理完毕了。window.onload 是整个页面加载完才执行，慢等 dom 解析完毕等执行完就执行，比较快。如下window.onload // : 区别：慢，只要有一个图片没有加载完，window.onload 就不能用，所以效率非常低下script 标签写在上面。既能操作 div，又能 dom 解析完就处理，效率很高。但是最好还是写在最下面&lt;script type='text/javascript'&gt; document.addEventListener('DOMContentLoad',function () &#123; var div = document.getElementsByTagName('div')[0]; console.log(div); &#125;,false); RegExp 正则表达式正则表达式的作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择 RegExp对象表示正则表达式，它是对字符串执行模式匹配的强大工具（判断字符串满不满要求）。正则表达式其他语言也有，规则是一样的，在这个基础上，js增加了自己独特的方法 创建正则表达式的方法第一种方法：正则表达式字面量 //正则表达式字面量：var 变量 = /表达式/; 12345例:var reg = /abc/;var str = 'abcd';console.log(reg.test(str));// &gt; true 1234567891011例：意思是正则表达式测验一下字符串含不含有我规定的片段var reg = /abc/; // 我规定的片段var str = 'abcd'; // 声明一个变量console.log(reg.test(str));// 我测验一下 str 里面有没有我规定片段的片段，如果有返回 true，如果没有 false// &gt; truevar reg = /abce/;var str = 'abcd';console.log(reg.test(str));// &gt; false,顺序不对或者没有挨着，都是不算的 12345678910例：像下面这种，虽然都有 abce，但是没挨着，或者排序不对，都不算var reg = /abce/;var str = 'abcde';console.log(reg.test(str));// false, 顺序不对var reg = /ab/;var str = 'abababab';console.log(str.match(reg));// ['ab'], match 是 str 的方法，可以查看 str 匹配 reg 的内容 第二种方法：new RegExp()new RegExp方法：var reg = new RegExp(&#39;pattern&#39;) 12345例：括号里面写的规则var str = 'abcd';var reg = new RegExp('abc');console.log(reg.test(str));// &gt; true 123下面是给正则表达式增加属性的方法var str = 'abcd';var reg = new RegExp('abc','m'); 正则表达式 3种 属性（修饰符）i 是 ignoreCase的缩写，是忽视大小写的意思，例如:var reg = /abce/i; 12345例：var reg = /abce/i;var str = 'ABCEd';console.log(reg.test(str));// true g 是全局匹配的意思，_选择全部的东西，例如：_var reg = /abce/g; 1234567891011例：var reg = /ab/;var str = 'ababababab';console.log(str.match(reg));// ['ab']例：var reg = /ab/g;var str = 'ababababab';console.log(str.match(str));// ['ab','ab','ab','ab','ab'] m 是执行多行匹配_，例如：_var reg = /abce/m; 12345例：^a 的意思是必须是 a 开头的var reg = /^a/gm; // g是全局匹配，选择全部的东西var str = 'abcde\\na'; // \\n 是换行的意思，转义字符,就是实际上已经是两行了console.log(str.match(reg));// ['a','a']; 正则表达式的表达式 reg.test()只能判断这个字符有没有符合要求的判断，返回的结果只有true和false str.match()可以把所有的东西匹配出来，返回给你，比上一种方法更直观，还能告诉你返回了多少个 1234567概况 | 表达式代表的是区间 范围 代表一位 |[] | 标记一个中括号表达式的开始。要匹配 [请使用\\[转义一下[^] | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39; 之后的位置。 |[a-z] | 字符范围。匹配指定范围内的任意字符。例如，&#39;[a-z]&#39; 可以匹配 &#39;a&#39; 到 &#39;z&#39; 范围内的任意小写字母字符。 |[A-Z] | 字符范围。匹配指定范围内的任意字符。例如，&#39;[A-A]&#39; 可以匹配 &#39;A&#39; 到 &#39;Z&#39; 范围内的任意小写字母字符。 |[0-9] | 字符范围。匹配指定范围内的任意字符。例如，&#39;[0-9]&#39; 可以匹配 &#39;0&#39; 到 &#39;9&#39; 范围内的任意小写字母字符。 |(red\\|blue\\|green\\) | 或 | 123456789例：想把一、二、三位都是数字都匹配出来，不同，可变化的数字，可以用 [] 来写，一个 [] 可以代表一个数，[] 里面放的是范围，是一个区间，如 [1234567890] ，如下图：var reg = /[1234567890][1234567890][1234567890]/g;// 里面放了3个[],就代表可以匹配3个数字var str = '123adsf654as8df56d4f';console.log(str.match(reg));// ['123','654']; 12345例：var reg = /[ab][cd][d]/g;var str = 'abcd';console.log(str.match(reg));// ['bcd']，指的是和 ab、cd、d匹配的数字 123456789例：0-9 是指 0 到 9，A-Z 是指大 A 到 Z，a-z 是指小 a - zvar reg = /[0-9A-Za-z][cd][d]/g;var str = 'abcd'// 就相当于字符和数字全部匹配了，也可以 A-z,直接从大A到小z// 这是按 ASCII 码排序的，从大写到小可以写成 A-zvar reg = /[0-9A-z][cd][d]/g;var str = 'ab1cd';console.log(str.match(reg));// [1cd] 12345例：^ 在正则表达式里面和外面的意思不一样，在正则表达式里面是 非 的意思var reg = /[^a][^b]/g;var str = 'ab1cd';console.log(str.match(reg));// ['b1','cd']，就是打印出不是 a 开头的和 b 开头的东西 12345678910例：| 在正则表达式种是 或 的意思var reg = /(abc|bcd)/g;var str = 'abc';console.log(str.match(reg));// ['abc']var reg = /(abc|bcd)[0-9]/g;var str = 'bcd2';console.log(str.match(reg));// ['bcd2'] 正则表达式的元字符正则表达式的元字符和表达式是要给东西; 元字符（Metacharacter）是拥有特殊含义的字符; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970字符 | 描述\\ | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符() | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)&#123;&#125; | 标记限定符表达式的开始。要匹配 &#123;，请使用 \\&#123;n$ | 匹配任何结尾为 n 的字符串。 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。$n | 代表第几个子表达式的内容，比如：$1 代表第一个子表达式的内容n* | 匹配任何包含零个或多个 n 的字符串。这个变量可以出现 0 到无数次。 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于&#123;0,&#125;n+ | 匹配任何包含至少一个 n 的字符串。这个变量可以出现 1 到无数次。 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 &#123;1,&#125;n? | 匹配任何包含零个或一个 n 的字符串。这个变量 0或 1 个一匹配。匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 &#123;0,1&#125;。n&#123;X&#125; | 匹配包含 X 个 n 的序列的字符串。n 是一个非负整数。匹配确定的 n 次。例如，'o&#123;2&#125;' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。n&#123;X,&#125; | 匹配包含至少 X 个 n 的序列的字符串。n 是一个非负整数。至少匹配n 次。例如，'o&#123;2,&#125;' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o&#123;1,&#125;' 等价于 'o+'。'o&#123;0,&#125;' 则等价于 'o*'。n&#123;X,Y&#125; | 匹配包含 X 至 Y 个 n 的序列的字符串。m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，\"o&#123;1,3&#125;\" 将匹配 \"fooooood\" 中的前三个 o。'o&#123;0,1&#125;' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。n? | 匹配任何包含零个或一个 n 的字符串。这个变量 0 或 1 个一匹配。 当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。. | 查找单个字符，除了换行和行结束符。匹配除 \"\\n\" 和 \"\\r\" 之外的任何单个字符。要匹配包括 '\\n' 和 \"\\r\" 在内的任何字符，请使用象 '[.\\n\\r]' 的模式。(?:pattern) | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies)' 就是一个比 'industry|industries' 更简略的表达式。(?=n) | 匹配任何其后紧接指定字符串 n 的字符串。正向预查，在任何匹配 n 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 \"Windows 2000\" 中的 \"Windows\" ，但不能匹配 \"Windows 3.1\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!n) | 匹配任何其后没有紧接指定字符串 n 的字符串。后面不跟着 n 负向预查，在任何不匹配 n 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 \"Windows 3.1\" 中的 \"Windows\"，但不能匹配 \"Windows 2000\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。x|y | 形容或。匹配 x 或 y。例如，'z|food' 能匹配 \"z\" 或 \"food\"。'(z|f)ood' 则匹配 \"zood\" 或 \"food\"。[^a-z] | 形容非，负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 就是匹配任何不在 'a' 到 'z' 范围内的任意字符。\\cx | 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。\\b | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。\\B | 匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。\\s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\n | 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\f | 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\v | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\r | 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\t | 匹配一个制表符。等价于 \\x09 和 \\cI\\S | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]\\d | 匹配一个数字字符。等价于 [0-9]。\\D | 匹配一个非数字字符。等价于 [^0-9]。\\w | 匹配包括下划线的任何单词字符。就是于'[A-Za-z0-9_]'\\W | 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。\\n | 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\\uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符。 匹配 xxxx，其中 xxxx 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)贪婪匹配 | 贪婪匹配。变成贪婪匹配（能少就不多），在量词后面加个'？'号。例如：var reg = /a+?/g;懒惰性 | 懒惰性则是正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。如果想捕获目标中所有符合条件的字符串的话，我们可以用标识符g来标明是全局捕获 运算符的优先级： 12345678910111213`从左到右进行运算,不同优先级的运算先高后低:`运算符 | 描述\\ | 转义符(), (?:), (?=), [] | 圆括号和方括号*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125; | 限定符^, $, \\任何元字符、任何字符 | 定位点和序列（即：位置和顺序）| | 替换，\"或\"操作字符具有高于替换运算符的优先级，使得\"m|food\"匹配\"m\"或\"food\"。若要匹配\"mood\"或\"food\"，请使用括号创建子表达式，从而产生\"(m|f)ood\"。 RegExp 对象方法、属性RegExp 对象方法属性（FF是火狐浏览器，IE 的 ie 浏览器，从哪个版本开始兼容）; 1234567891011121314151617属性 | 描述global | RegExp 对象是否具有标志 g，进行全局匹配ignoreCase | RegExp 对象是否具有标志 i，不区分大小写input | 被匹配的串lastIndex | 一个整数，标示开始下一次匹配的字符位置lastParen | 被最后一个括号括起来的子串lastContent | 最近一次匹配以左的子串multiline | RegExp 对象是否具有标志 m，进行多行匹配source | 正则表达式的源文本 123456789101112131415方法 | 描述compile | 编译正则表达式exec | 检索字符串中指定的值。返回找到的值，并确定位置test | 检索字符串中指定的值match | 找到一个或多个正则表达式的匹配search | 检索与正则表达式相匹配的值，返回的不是 -1 都匹配成功了，返回的是匹配这个东西的位置split | 把字符串分割为字符串数组replace | 替换和正则表达式匹配的字符串，replace 的精华是正则表达式 注意 *？意思是能取 0，就不取多 想匹配空格，直接写，就可以了 想把选中的字符替换成$，直接写$是不行的，需要加上转义字符$ 由于在替换文本里面$有了特殊的含义（$代表反向引用），如果想要是替换 $ 这个字符的话，需要写成 $$，充当转义字符 正则表达式要匹配一个反向引用的东西，写\\ 1234var str = 'aa\\\\aaaa';var reg = /\\\\/g;console.log(str.match(reg));// ['\\'] 在正则表达式里面要匹配问号？写? 其余*+-()星号加号减号都类似 1234var str = 'aa?aaaa';var reg = /\\?/g;console.log(str.match(reg));// ['?'] 正则表达式应用123456789101112//验证邮码 100010（不可以以0开头的6位数）/^[1-9]\\d&#123;5&#125;$///验证手机号/^[1-9]\\d&#123;10&#125;$///验证日期/^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$///精确 ^\\d&#123;4&#125;-(0?[1-9]|1[0-2])-((0?[1-9])|((1|2)[0-9])|30|31)$//验证邮箱/\\w+@\\w+(\\.\\w+)+/// 12345例：下面是想去重，变成 abc，先匹配一串，再取一var str = 'aaaaaaaaaaaabbbbbbbbbccccccccc';var reg = /(\\w)\\1*/g;console.log(str.replace(reg,$1));// abc 12345678百度招聘 14 年最后一题:给 var str = '100000000000'; 这个数字科学计数法，每隔三位打点思路：找规律，从后往前查，每三位打个点，换个空进去【什么样的空？后面的数 一定是 3 的倍数，(\\d&#123;3&#125;)+是 3 的倍数位个数字，这里面的东西一到多个，第一个/ 后面的空后面加上正向预查，后面是3 的倍数位个数字，$以什么结尾】空的后面跟 着 3 的倍数位个数字并且以这个结尾。\\B 非单词边界答案：var str = '1000000000000';var reg = /(?=(\\B)(\\d&#123;3&#125;))+$/g;console.log(str.replace(reg,'.')); BOMBOM 是 brower object model 的缩写，简称浏览器对象模型，主要处理浏览器窗口和框架，描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，回退历史记录，获取url……。 一、BOM 与 DOM（Document Object Model）的关系javascript是通过访问BOM对象来访问、控制、修改浏览器 window是BOM的属性，也就是说BOM的window包含了document，因此通过window对象的document属性就可以访问、检索、修改文档内容与结构 document对象又是DOM模型的根节点。因此，BOM包含了DOM，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档 DOM的大部分内容都是W3c标准规范，所以兼容性很好，不需要太多的兼容性代码，而BOM则不一样，BOM没有W3c规范，每个浏览器厂家的规范也就不一样了。 二、BOM对象包含的对象不是说BOM下面只包含了一个window对象吗？其实BOM对象下面只有一个window对象，但是因为了解清除，所以其他四个也是比较重要的对象了; 123456789Window | Javascript 层级中的顶层对象，表示浏览器窗口Navigator | 包含客户端浏览器的信息。（比如浏览器的版本号）History | 包含了浏览器窗口访问过的URL（比如历史记录，前进、后退）Location | 包含了当前URL的信息（地址栏中的信息）Screen | 包含了客户端显示屏的信息（返回一些屏幕信息，基本上用不到） Window 对象Window对象表示一个浏览器窗口或一个框架，在客户端JavaScript中，Window对象是全局对象，所有的表达式都在当前的环境中计算，也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。例如，可以只写document，而不必写window.document； window 对象属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849`closed` | 返回窗口是否已被关闭，例：window.closed;defaultStatus | 设置或返回窗口状态栏中的默认文本。（仅Opera支持）document | 对 Document 对象的只读引用，请参阅 Document 对象`history` | 对 History 对象的只读引用。请参数 History 对象`innerHeight` | 返回窗口的文档显示区的高度`innerWidth` | 返回窗口的文档显示区的宽度length | 设置或返回窗口中的框架数量`location` | 用于窗口或框架的 Location 对象，请参阅 Location 对象name | 设置或返回窗口的名称`Navigator` | 对 Navigator 对象的只读引用，请参阅 Navigator 对象opener | 返回对创建此窗口的窗口的引用outerheight | 返回窗口的外部高度outerwidth | 返回窗口的外部宽度`pageXoffset` | 设置或返回当前页面相对于窗口显示区左上角的 X 位置`pageYoffset` | 设置或返回当前页面相对于窗口显示区左上角的 Y 位置parent | 返回父窗口`Screen` | 对 Screen 对象的只读引用，请参数 Screen 对象self | 返回对当前窗口的引用，等价于 Window 属性status | 设置窗口状态栏的文本（默认只支持 Opera）top | 返回最顶层的先辈窗口window | window 属性等价于 self 属性，它包含了对窗口自身的引用`screenLeft` | 返回窗口相对于屏幕的 X 坐标。`screenTop` | 返回窗口相对于屏幕的 Y 坐标。`screenX` | 返回窗口相对于屏幕的 X 坐标。`screenY` | 返回窗口相对于屏幕的 Y 坐标。 window 对象方法12345678910111213141516171819202122232425262728293031323334353637`alert()` | 显示或弹出带有一段消息和一个确认按钮的警告框blur() | 把键盘焦点从顶层窗口移开focus() | 把键盘焦点给予一个窗口`setInterval()` | 按照指定的周期（以毫秒来调用函数或计算表达式），定时器`setTimerout()` | 在指定的毫秒数后调用函数或计算表达式，定时器，只执行一次`clearInterval()` | 取消由setInterval设置的定时器tiemout`clearTimeout()` | 取消由setTimeout设置的定时器tiemout`close(`) | 关闭浏览器窗口`confirm()` | 显示或弹出带有一段消息以及确认按钮和取消按钮的对话框，确认返回true，取消返回falsecreatePopup() | 创建一个弹出窗口，只有ie支持（不包括ie11）moveBy(x,y) | 可相对窗口的当前坐标把它移动指定的像素，moveBy(100,100)中的100就代表100像素，可以配合 open()来时使用moveTO() | 把窗口的左上角移动到要给指定的坐标`open()` | 打开一个新的浏览器窗口或查找一个已命名的窗口，window.open(URL,name（窗口的名称）,features,replace),例如：open('url','name（窗口的名称）','属性')print() | 打印（就是打印当前页面）当前窗口内容`prompt()` | 显示可提示用户输入的对话框`resizeBy()` | 按照指定的像素调整窗口的大小`resizeTo()` | 把窗口的大小调整到指定宽度和高度`scrollBy()` | 按照指定的像素值来滚动内容`scrollTo()` | 把内容滚动到指定的坐标 Navigator 对象Navigator对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。虽然这个对象的名称显而易见的是Netscape的Navigator浏览器，但其他实现了JavaScript的浏览器也支持这个对象 Navigator 对象属性12345678910111213141516171819202122232425appCodeName | 返回浏览器的代码名。以 Netscape 代码为基础的浏览器中，它的值是\"Mozila\"。为兼容Microsoft也是appMinorVersion | 返回浏览器的次级版本。（IE4、Opera支持）appName | 返回浏览器的名称appVersion | 返回浏览器的平台和版本信息browserLanguage | 返回当前浏览器的语言（IE 和 Opera 支持）`cookieEnabled` | 返回指明浏览器中是否启用 cookie 的布尔值cpuClass | 返回浏览器系统的 CPU 等级（IE支持）`onLina` | 返回执行系统是否处于脱机模式的布尔值（连没连网）platform | 返回运行浏览器的操作系统平台systemLanguage | 返回当前系统的默认语言。（IE支持）`userAgent` | 返回有客户机发送服务器的 user-agent 头部的值。userLanguage | 返回操作系统设定的自然语言。（IE 和 Opera 支持）plugins | 返回包含客户端安装的所欲插件的数组 Navigator 对象方法123javaEnabled() | 规定浏览器是否支持并启用了 JavataintEnabled() | 规定浏览器是否启用数据污点（data tainting） HistoryHistory 对象包含用户（在浏览器窗口中）访问过的URL; History 对象属性1length | 返回浏览器历史列表中的 URL 数量 History 对象方法12345back() | 加载 history 列表中的前一个 URLforward() | 加载 history 列表中的下一个 URLgo() | 加载 history 列表中的某个具体页面,例如 history.go(-2) Location 对象Location 对象包含有关当前 URL 的信息; Location 对象属性123456789101112131415`hash` | 设置或返回从井号（#）开始的 URL（锚）。`host` | 加载 history 列表中的下一个 URLhostname | 加载 history 列表中的某个具体页面,例如 history.go(-2)`href` | 设置或返回完整的 URL`pathname` | 设置或返回当前 URL 的路径部分port | 设置或返回当前 URL 的端口号`protocol` | 设置或返回当前 URL 的协议`search` | 设置或返回从问号（？）开始的 URL(查询部分) Location 对象方法12345`assign()` | 加载新的文档`reload('force')` | 重新加载当前文档，参数可选，不填或填 false 则取浏览器缓存的文档`replace()` | 用新的文档替换当前文档 Screen 对象 Screen对象包含有关客户端显示屏幕的信息。每个Window对象的screen属性都引用一个Screen对象。Screen对象中存放着有关显示浏览器屏幕的信息。Javascript程序将利用这些信息来优化它们的输出，以达到用户的显示要求。例如，一个程序可以根据显示器的尺寸选择使用大图像还是使用小图像，它还可以根据显示器的颜色深度选择使用16位色还是使用8位色的图形。另外，JavaScript程序还能根据有关屏幕尺寸的信息将新的浏览器窗口定位在屏幕中间 Screen 对象属性123456789101112131415161718192021availHeight | 返回显示屏的高度（除 Windows 任务栏之外）availWidth | 返回显示屏的宽度（除 Windows 任务栏之外）bufferDepth | 设置或返回调色板的比特深度（仅 IE 支持）colorDepth | 返回目标设备或缓冲器上的调色板的比特深度deviceXDPI | 返回显示屏幕的每英寸水平点数（仅 IE 支持）deviceYDPI | 返回显示屏幕的每英寸垂直点数（仅 IE 支持）fontSmoothingEnabled | 返回用户是否在显示控制面板中启用了字体平滑（仅 IE 支持）height | 返回显示屏幕的高度logicaIXDPI | 返回显示屏幕每英寸的水平方向的常规点数（仅 IE 支持）logicaIYDPI | 返回显示屏幕每英寸的垂直方向的常规点数（仅 IE 支持）pixelDepth | 返回显示器的颜色分辨率（比特每像素） JavaScript 必会知识点（琐碎、相互独立） 属性映射 HTML属性，映射到Element; cdn（缓存服务器）; 断点调试（debugger;）; typeof(new Array).proto.constructor();; 渲染模式 在多年以前（IE6诞生以前），各大浏览器都处于各自比较封闭的发展中（基本没有兼容性可谈）。随着web的发展，兼容性问题的解决越来越显得迫切，随即，各浏览器厂商发布了按照标准模式（遵循各厂商制定的统一标准）工作的浏览器，比如IE6就是其中之一。但是考虑到以前建设的网站并不支持标准模式，所以各大浏览器在加入标准模式的同时也保留了混杂模式（即以前那种未按照统一标准工作的模式，也叫怪异模式） 12345678910DOCTYPE // 三种标准模式的写法1. &lt;!DOCTYPE html&gt;2. &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;3. &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;如果当&lt;!DOCTYPE html&gt;不写，或者写错了，都会进入到怪异渲染模式中 渲染模式 : &lt;! DOCTYPE html&gt; 是 html5 的，写三种的任何一种都是可以的，都是正常渲染模式 怪异/混杂模式 : 试图去兼容之前的语法，去掉这一行即可开启（向后兼容） document.compatMode是判断是怪异模式还是标准模式 CSS1Compat – 标准模式; BackCompat – 怪异模式向后兼容; 怪异模式不是说对所有的浏览器都管用，主要是针对IE6及以下的浏览器版本的。 怪异模式下盒模型会变成IE盒模型，行盒也会可以改变宽高 IE盒模型：box-sizing:border-box; 属性：content-box; 元素的宽高 = 边框 + 内边距 + 内容宽高 属性：border-box; 元素的宽高 = width/height的宽高 W3c标准盒模型： 宽度 = 左外边距 + 左边框 + 左内边距 + width + 右内边距 + 右边框 + 右外边距 高度 = 上外边距 + 上边框 + 上内边距 + height + 下内边距 + 下边框 + 下外边距 img图片预加载 \\ 图片懒加载图片预加载: 123456// 图片预加载，就是在全部内容加载完之后再加载图片var OImg = new Image();OImg.src = '图片地址';OImg.onload = function () &#123; document.body.appendChild(OImg);&#125; 图片懒加载: 12345678// 图片懒加载，我需要你的时候在加载，不需要你的时候就不要加载&lt;button&gt; getTime &lt;/button&gt;var oBtn = document.getElementsByTagName('button')[0];OBtn.onclick = function()&#123; var OImg = new Image(); OImg.src = '图片地址'; document.body.appendChild(OImg);&#125; 文档碎片12345678&lt;ul&gt;&lt;/ul&gt;var Oul = document.getElementsByTagName(\"ul\")[0];for (var i = 0; i &lt; 10000; i++)&#123; var Oli = document.createElement(\"li\"); Oli.innerHTML = i; Oul.appendChild(Oli);&#125; 但是， 如果当我们要向document中添加大量数据时(比如1w条)， 如果像上面的代码一样， 逐条添加节点， 这个过程就可能会十分缓慢。当然, 你也可以建个新的节点, 比如说div, 先将oP添加到div上, 然后再将div添加到body中.但这样要在body中多添加一个 &lt; div &gt; &lt; /div&gt;.但文档碎片不会产生这种节点. 12345678910&lt;ul&gt;&lt;/ul&gt;var OUl = document.getElementsByTagName(\"ul\")[0];var ODiv = document.createElement(\"div\");for (var i = 0; i &lt; 10000; i++)&#123; var OLi = document.createElement(\"li\"); OLi.innerHTML = i; ODiv.appendChild(OLi);&#125;OUl.appendChild(ODiv); 为了解决这个问题， 我们可以引入createDocumentFragment() 方法， 它的作用是创建一个文档碎片， 把要插入的新节点先附加在它上面， 然后再一次性添加到document中。 代码如下： 代码如下: 12345678910111213&lt;ul&gt;&lt;/ul&gt;//先创建文档碎片var oFragmeng = document.createDocumentFragment();var OUl = document.getElementsByTagName(\"ul\")[0];for (var i = 0; i &lt; 10000; i++) &#123; var OLi = document.createElement(\"li\"); OLi.innerHTML = i; //先附加在文档碎片中 oFragmeng.appendChild(OLi);&#125;//最后一次性添加到document中OUl.appendChild(oFragmeng);//这就是文档碎片 12345678//当然，还有一种方法:用字符串拼接也可以&lt;ul&gt;&lt;/ul&gt;var OUl = document.getElementsByTagName('ul')[0];var str = ''; // 声明一个空字符串for(var i = 0;i &lt; 1000;i ++)&#123; str += '&lt;li&gt;' + i + '&lt;/li&gt;'; // 让标签用字符串＋起来&#125;OUl.innerHTML = str; // 最后用innerHTML插入到ul里面 byClassName（封装函数，兼容性vrey Good!）12345678910111213141516171819document.prototype.getByClassName = function(classname)&#123; var allDomArr = Array.prototype.slice.call(document.getElementsByTagName('8'),0); var filterArr = []; function dealClass(dom)&#123; var reg = /\\s+/g; var arrClassName = dom.className.replace(reg,' ').trim(); return arrClassName; &#125; allDomArr.forEach(function(ele,index)&#123; var itemClassArr = dealClass(ele).split(' '); for(var i = 0;i &lt; itemClassArr.length;i ++)&#123; if(itemClassArr[i] == className)&#123; filterArr.push(ele); break; &#125; &#125; &#125;) return filterArr;&#125; Math 对象 Math.abs(num) : 返回num的绝对值 Math.acos(num) : 返回num的反余弦值 Math.asin(num) : 返回num的反正弦值 Math.atan(num) : 返回num的反正切值 Math.atan2(y,x) : 返回y除以x的商的反正切值 Math.ceil(num) : 返回大于num的最小整数 Math.cos(num) : 返回num的余弦值 Math.exp(x) : 返回以自然数为底,x次幂的数 Math.floor(num) : 返回小于num的最大整数 Math.log(num) : 返回num的自然对数 Math.max(num1,num2) : 返回num1和num2中较大的一个 Math.min(num1,num2) : 返回num1和num2中较小的一个 Math.pow(x,y) : 返回x的y次方的值 Math.random() : 返回0到1之间的一个随机数 Math.round(num) : 返回num四舍五入后的值 Math.sin(num) : 返回num的正弦值 Math.sqrt(num) : 返回num的平方根 Math.tan(num) : 返回num的正切值 Math.E : 自然数(2.718281828459045) Math.LN2 : 2的自然对数(0.6931471805599453) Math.LN10 : 10的自然对数(2.302585092994046) Math.LOG2E : log 2 为底的自然数(1.4426950408889634) Math.LOG10E : log 10 为底的自然数(0.4342944819032518) Math.PI : π(3.141592653589793) Math.SQRT1_2 : 1/2的平方根(0.7071067811865476) Math.SQRT2 : 2的平方根(1.4142135623730951) Math.random()生成一个随机数，生成一个 0 ~ 1 之间的一个随机数。 12345678例：var arr = ['a','b','c','d','e'];var str = '';for(var i = 0;i &lt; 3;i ++)&#123; str = arr[Math.floor(Math.random() * 5)];&#125;console.log(str);// 可以取一个数组中任意三个字母 12345678910例：var arr = ['a','b','c','d','e'];var str = '';for(var i = 0;i &lt; 3;i ++)&#123; str = arr[Math.floor(Math.random() * 3 + 2)];&#125;console.log(str);// 可以取数组中2 ~ 5中的任意三个字母;就比如：我想让随机数在 2 ~ 5 之间取一个随机数，就例如：Math.random() * 3 + 2 // 3是2到5之间的一个数字，2就是5-3=2； 1234567891011例：抽奖var num = Math.random() * 10;if(num &lt; 0.001)&#123; console.log('一等奖');&#125;else if(num &lt; 0.01)&#123; console.log('二等奖')&#125;else if(num &lt; 0.1)&#123; console.log('三等奖')&#125;else&#123; console.log('特等奖')&#125; String 对象String 对象属性 constructor 对创建该对象的函数的引用 length字符串的长度 prototype允许您向对象添加属性和方法 String 对象方法 charAt(n) ：返回在指定位置的字符，字符串的索引，第n位 charCodeAt() ：返回在指定的位置的字符的Unicode编码。这个返回值是0 - 65535之间的整数。(当返回值是&lt;=255时为英文，当返回值&gt;255时为中文) concat() ：连接两个或更多字符串，并返回新的字符串。 fromCharCode() ：将 Unicode 编码转为字符。 indexOf() ：返回某个指定的字符串值在字符串中首次出现的位置，如果没有找到匹配的字符串则返回 -1。 includes() ：查找字符串中是否包含指定的子字符串。 lastIndexOf() ：从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现* 的位置。 match() ：查找找到一个或多个正则表达式的匹配。 repeat() ：复制字符串指定次数，并将它们连接在一起返回。 replace() ：在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。 search() ：查找与正则表达式相匹配的值。 slice(a,b) ：提取字符串的片断，并在新的字符串中返回被提取的部分，剪切，从a剪切到b。 split() ：把字符串分割为字符串数组。 startsWith() ：查看字符串是否以指定的子字符串开头。 substr() ：从起始索引号提取字符串中指定数目的字符。 substring() ：提取字符串中两个指定的索引号之间的字符。 toLowerCase() ：把字符串转换为小写。 toUpperCase() ：把字符串转换为大写。 trim() ：去除字符串两边的空白 toLocaleLowerCase() ：根据本地主机的语言环境把字符串转换为小写。 toLocaleUpperCase() ：根据本地主机的语言环境把字符串转换为大写。 valueOf() ：返回某个字符串对象的原始值。 toString() ：返回一个字符串。 String HTML：包装方法 HTML ：返回包含在相对应的 HTML 标签中的内容。 以下方法并非标准方法，所以可能在某些浏览器下不支持。 anchor()：创建 HTML 锚。 big()：用大号字体显示字符串。 blink()：显示闪动字符串。 bold()：使用粗体显示字符串。 fixed()：以打字机文本显示字符串。 fontcolor()：使用指定的颜色来显示字符串。 fontsize()：使用指定的尺寸来显示字符串。 italics()：使用斜体显示字符串。 link()：将字符串显示为链接。 small()：使用小字号来显示字符串。 strike()：用于显示加删除线的字符串。 sub()：把字符串显示为下标。 sup()：把字符串显示为上标。 javaScript书写规范：命名规范1234567891011121314151617181920212223242526常量名 全部大写并单词间用下划线分隔 如：CSS_BTN_CLOSE、TXT_LOADING对象的属性或方法名 小驼峰式（little camel-case） 如：init、bindEvent、updatePosition 示例：Dialog.prototype = &#123; init: function () &#123;&#125;, bindEvent: function () &#123;&#125;, updatePosition: function () &#123;&#125; … &#125;;类名（构造器） --&gt;小驼峰式但首字母大写 --&gt;如：Current、DefaultConfig函数名 --&gt;小驼峰式 --&gt;如：current()、defaultConfig()变量名 --&gt;小驼峰式 --&gt;如：current、defaultConfig私有变量名 --&gt;小驼峰式但需要用_开头 --&gt;如：_current、_defaultConfig变量名的前缀 --&gt;续 代码格式 12345\"()\"前后需要跟空格\"=\"前后需要跟空格\",\"后面需要跟空格JSON对象需格式化对象参数if、while、for、do语句的执行体用\"&#123;&#125;\"括起来 “{}”格式如下 123if (a==1) &#123; //代码&#125;; 避免额外的逗号 var arr = [1,2,3,]; for-in循环体中必须用hasOwnProperty方法检查成员是否为自身成员，避免来自原型链上的污染。 长语句可考虑断行 12345TEMPL_SONGLIST.replace('&#123;TABLE&#125;', da['results']) .replace('&#123;PREV_NUM&#125;', prev) .replace('&#123;NEXT_NUM&#125;', next) .replace('&#123;CURRENT_NUM&#125;', current) .replace('&#123;TOTAL_NUM&#125;', da.page_total); 为了避免和JSLint的检验机制冲突，“.”或“+”这类操作符放在行尾 12345TEMPL_SONGLIST.replace('&#123;TABLE&#125;', da['results']). replace('&#123;PREV_NUM&#125;', prev). replace('&#123;NEXT_NUM&#125;', next). replace('&#123;CURRENT_NUM&#125;', current). replace('&#123;TOTAL_NUM&#125;', da.page_total); 如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入/global/声明。 /*global alert: true, console: true, top: true, setTimeout: true */ 使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱,在条件判断时，这样的一些值表示false 12345nullundefined与null相等字符串''数字0NaN 在==时，则会有一些让人难以理解的陷阱 1234567891011(function () &#123; var undefined; undefined == null; // true 1 == true; //true 2 == true; // false 0 == false; // true 0 == ''; // true NaN == NaN;// false [] == false; // true [] == ![]; // true&#125;)(); 对于不同类型的 == 判断，有这样一些规则，顺序自上而下 12345undefined与null相等一个是number一个是string时，会尝试将string转换为number尝试将boolean转换为number0或1尝试将Object转换成number或string 而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用=== ===会先判断两边的值类型，类型不匹配时为false。 下面类型的对象不建议用new构造 12345new Numbernew Stringnew Booleannew Object //用&#123;&#125;代替new Array //用[]代替 引用对象成员用obj.prop代替obj[“prop”]，除非属性名是变量。 从number到string的转换。 123456789/** 推荐写法*/var a = 1;typeof(a); //\"number\"console.log(a); //1var aa=a+'';typeof(aa); //\"string\"console.log(aa); //'1'/** 不推荐写法*/new String(a)或a.toString() 从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。 1234567/** 推荐写法*/var a = '1';var aa = parseInt(a,10);typeof(a); //\"string\"console.log(a); //'1'typeof(aa); //\"number\"console.log(aa); //1 从float到integer的转换 1234/** 推荐写法*/Math.floor/Math.round/Math.ceil/** 不推荐写法*/parseInt 字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。 1234567891011121314/**推荐的拼接方式array的push、join*/var str=[], list=['测试A','测试B'];for (var i=0 , len=list.length; i &lt; len; i++) &#123; str.push( '&lt;div&gt;'+ list[i] + '&lt;/div&gt;');&#125;;console.log(str.join('')); //&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt;/** 不推荐的拼接方式+=*/var str = '', list=['测试A','测试B'];for (var i = 0, len = list.length; i&lt; len; i++) &#123; str+='&lt;div&gt;' + list[i] + '&lt;/div&gt;';&#125;;console.log(str); //&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt; 尽量避免使用存在兼容性及消耗资源的方法或属性 不要使用with，void，evil，eval_r，innerText 注重HTML分离, 减小reflow, 注重性能 图片规范命名应用小写英文、数字、_组合，便于团队其他成员理解 12header_btn.gifheader_btn2.gif 页面元素类图片均放入img文件夹, 测试用图片放于img/testimg文件夹，psd源图放入img/psdimg文件夹。 图片格式仅限于gif、png、jpg等。 用png图片做图片时,要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果,请为ie-6单独定义背景，并尽量避免使用半透明的png图片。 背景图片请尽可能使用sprite技术, 减小http请求 注释规范： JAVASCRIPT、CSS文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。 /* * 注释块 */ 中间可添加如下信息 1234567891011121314151617181920212223@file 文件名@addon 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中@argument 用大括号中的自变量类型描述一个自变量@author 函数/类作者的姓名@base 如果类是继承得来，定义提供的类名称`@class`用来给一个类提供描述，不能用于构造器的文档中@constructor 描述一个类的构造器@deprecated 表示函数/类已被忽略@exception 描述函数/类产生的一个错误@exec @extends 表示派生出当前类的另一个类@fileoverview 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前@final 指出函数/类@ignore 让jsdoc忽视随后的代码@link 类似于@link标签，用于连接许多其它页面@member 定义随后的函数为提供的类名称的一个成员@param 用大括号中的参数类型描述一个参数@private 表示函数/类为私有，不应包含在生成的文档中@requires 表示需要另一个函数/类@return 描述一个函数的返回值@see 连接到另一个函数/类@throws 描述函数/类可能产生的错误@type 指定函数/成员的返回类型@version 函数/类的版本号","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"jqeury","slug":"jquery","date":"2020-03-19T13:33:38.078Z","updated":"2020-04-01T04:15:29.615Z","comments":true,"path":"2020/03/19/jquery/","link":"","permalink":"http://yoursite.com/2020/03/19/jquery/","excerpt":"第一节 jQuery初步认知jQuery概述 jQuery是什么: 是一个javascript代码仓库，我们称之为javascript框架。 是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。","text":"第一节 jQuery初步认知jQuery概述 jQuery是什么: 是一个javascript代码仓库，我们称之为javascript框架。 是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。 - - 它可以帮我们做什么(有什么优势) - 轻量级、体积小，使用灵巧(只需引入一个js文件) - 强大的选择器 - 出色的DOM操作的封装 - 出色的浏览器兼容性 - 可靠的事件处理机制 - 完善的Ajax - 链式操作、隐式迭代 - 方便的选择页面元素(模仿CSS选择器更精确、灵活) - 动态更改页面样式/页面内容(操作DOM，动态添加、移除样式) - 控制响应事件(动态添加响应事件) - 提供基本网页特效(提供已封装的网页特效方法) - 快速实现通信(ajax) - 易扩展、插件丰富 JQuery概念 javascript概念 基于Js语言的API和语法组织逻辑，通过内置window和document对象，来操作内存中的DOM元素 JQuery概念 基于javascript的，同上，提高了代码的效率 如何引入JQuery包 引入本地的JQuery 引入Google在线提供的库文件（稳定可靠高速） 使用Google提供的API导入 &lt;script type=“text/javascript” src=“jquery.js”&gt;&lt;/script&gt; 写第一个JQUery案例 解释:在JQuery库中，$是JQuery的别名，$()等效于就jQuery() 123456&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;&lt;script type=“text/javascript”&gt; $(function()&#123; alert(“jQuery 你好!”); &#125;);&lt;/script&gt; 讲解$(function(){}); $是jQuery别名。如$()也可jQuery()这样写,相当于页面初始化函数，当页面加载完毕，会执行jQuery()。 希望在做所有事情之前，JQuery操作DOM文档。必须确保在DOM载入完毕后开始执行，应该用ready事件做处理HTML文档的开始 $(document).ready(function(){}); 类似于js的window.onload事件函数，但是ready事件要先于onload事件执行 window.onload = function(){}; 为方便开发，jQuery简化这样的方法，直接用$()表示 JQuery的ready事件不等于Js的load： 执行时机不同：load需要等外部图片和视频等全部加载才执行。ready是DOM绘制完毕后执行，先与外部文件 用法不同：load只可写一次，ready可以多次 window.onload与$(document).ready()对比 window.onload $(document).ready() 执行时机 必须等网页中所有内容加载完后(图片)才执行 网页中的DOM结构绘制完后就执行,可能DOM元素相关的东西并没有加载完 编写个数 不能同时执行多个 能同时执行多个 简化写法 无 $(document).ready(function(){ //.. });推荐写法：$(function(){ }); jQuery有哪些功能(API)： 选择器 过滤器 事件 效果 ajax 简单的JQuery选择器： JQuery基本选择器（ID选择器，标签选择器，类选择器，通配选择器和组选择器5种） ID选择器：document.getElementById(id)与$(&quot;#id&quot;)对比(改变文字大小)—id唯一，返回单个元素 标签选择器：document.getElementsByTagName(tagName)与$(&quot;tagname&quot;)对比—多个标签，返回数组 类选择器:$(&quot;.className&quot;)–多个classname（改变背景图片） 通配选择器：document.getElementsByTagName(&quot;*&quot;)与$(&quot;*&quot;)对比—指范围内的所有标签元素 组选择器：$(&quot;seletor1,seletor2,seletor3&quot;)—-无数量限制，用逗号分割 初步了解JQuery JQuery是什么 javascript用来干什么的： 操作DOM对象 动态操作样式css 数据访问 控制响应事件等 jQuery作用一样，只是更加快速简洁 如何引用JQuery 12345678&lt;script type=\"text/javascript\"&gt;&lt;/script&gt;写第一个JQUery案例&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;&lt;script type=“text/javascript”&gt; $(function()&#123; alert(“jQuery 你好!”); &#125;);&lt;/script&gt; $()讲解 $在JQuery库中，$是JQuery的别名，$()等效于就jQuery(). $()是JQuery方法,赞可看作是JQuery的选择器，与css选择器相似（可做对比） var jQuery==$ =function(){} $()本质就是一个函数也就是 jQuery的核心函数 只要是jQuery的对象都这样变量加上一个符号$方便识别：var $div = $(&quot;#&quot;) 123function $(id)&#123; return document.getElementById(id); &#125; $()和document是相等的吗 12345&lt;div id=\"a\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"b\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"c\" class=\"aa\"&gt;&lt;/div&gt;alert(document.getElementById(\"id\") == $(\"#aa\"));//返回结果为falsealert(document.getElementById(\"id\") == $(\"#aa\").get(0));//返回true 代理对象$() jQuery中返回的是代理对象本身 jQuery的核心原理是通过选择器找到对应的代理对象 jQuery全都是通过方法操作 样式选择器$(&quot;.className&quot;) $(&quot;.aa&quot;).css(&quot;color&quot;,&quot;green&quot;); id选择器(“”) $(&quot;#a&quot;).css(&quot;background-color&quot;,&quot;#ff0066&quot;); 标签选择器 $(&quot;p&quot;).css(&quot;color&quot;,&quot;#cc3366&quot;); 组选择器 $(&quot;#b ul li&quot;).size(); 对象转换($(element)) 原生dom对象和jquery代理对象的相互转换 12345$(传入的原生对象);//原生对象转化成jQuery对象var nav = document.getElementById(\"nav\");var $nav = $(nav);alert($nav.get(0) == nav);//true 检索范围的限制（$(&#39;字符串&#39;,element)） 总结：三种写法对比： 方式一：不推荐 搜索速度最慢 $(&quot;#nav&quot;).css(); $(&quot;#nav li&quot;).css(); 方式二：搜索速度最快 链式操作 $(&quot;#nav&quot;).css().children().css(); 方式三：也常用 速度第二快 var $nav = $(&quot;#nav&quot;).css(); $(&quot;li&quot;,$nav).css(); $nav限制了搜索范围 速度快 总结： $() jquery核心方法的作用和使用场景 如果是一个字符串参数并且没有标签对（选择器）$(ul.nav&quot;) 如果是一个字符串参数并且有标签对（创建html标签）$(&quot;&lt;img&gt;&quot;) –最终加到DOM树中 $xx.append(&quot;&lt;img&gt;&quot;); 如果是传入一个element dom对象，直接包装为proxy对象返回 $(DOM对象) 如果第一个参数是字符串，第二个是element dom对象的话，那么就是在element这个dom对象里面寻找选择器对应的元素并且代理 $(&quot;li&quot;,$DOM对象) 代理模式以及代理内存结构 第二节 选择器 来回顾一下CSS常用的选择器 选择器 语法 描述 标签选择器 E{css规则} 以文档元素作为选择符 ID选择器 #ID{css规则} ID作为选择符 类选择器 E.className{css规则} class作为选择符 群组选择器 E1,E2,E3{css规则} 多个选择符应用同样的样式 后代选择器 E F{css规则} 元素E的任意后代元素F 选择器引擎规则($(&#39;字符串&#39;)) css选择器的规则 标签选择器 – $(‘p’) id选择器 – $(‘#id’) 类选择器 – $(‘.class’) 混合选择器 – $(‘.class p’) css3的选择器规则 状态和伪类（:even :odd :first :last :eq(index)） 属性（[attr=value]） 层级选择器:通过DOM的嵌套关系匹配元素 jQuery层级选择器—-包含选择器、子选择器、相邻选择器、兄弟选择器4种 a.包含选择器：$(&quot;a b&quot;)在给定的祖先元素下匹配所有后代元素。(不受层级限制) b.子选择器：$(&quot;parent &gt; child&quot;)在给定的父元素下匹配所有子元素。 c.相邻选择器：$(&quot;prev + next&quot;) 匹配所有紧接在prev元素后的next元素。 d.兄弟选择器：$(&quot;prev ~ siblings&quot;) 匹配prev元素之后的所有sibling元素。 过滤选择器 基本过滤选择 选择器 说明 返回 :first 匹配找到的第1个元素 单个元素 :last 匹配找到的最后一个元素 单个元素 :eq() 匹配一个给定索引值的元素 单个元素 :even 匹配所有索引值为偶数的元素 集合元素 :odd 匹配所有索引值为奇数的元素 集合元素 :gt(index) 匹配所有大于给定索引值的元素 集合元素 :lt(index) 匹配所有小于给定索引值的元素 集合元素 :not 去除所有与给定选择器匹配的元素 集合元素 :animated 选取当前正在执行动画的所有元素 集合元素 :focus 选取当前正在获取焦点的元素 集合元素 :find() 获得当前元素集合中每个元素的后代 集合元素 内容过滤选择器 选择器 描述 返回 :contains(text) 选取含有文本内容为text的元素 集合元素 :empty 选取不包含子元素获取文本的空元素 集合元素 :has(selector) 选择含有选择器所匹配的元素的元素 集合元素 :parent 选取含有子元素或者文本的元素 集合元素 可见过滤选择器 选择器 描述 返回 :hidden 选择所有不可见的元素 集合元素 :visible 选取所有可见的元素 集合元素 属性过滤选择器 选择器 说明 返回 [attribute] 选取拥有此属性的元素 集合元素 [attribute=value] 选取属性值为value值的元素 集合元素 [attribue^=value] 选取属性的值以value开始的元素 集合元素 [attribue$=value] 选取属性的值以value结束的元素 集合元素 子元素过滤选择器 选择器 说明 返回 :nth-child(index/even/odd) 选取每个父元素下的第index个子元素或者奇偶元素（index从1算起） 集合元素 :first-child 选取每个元素的第一个子元素 集合元素 :last-child 选取每个元素的最后一个子元素 集合元素 :nth-child()选择器是很常用的子元素过滤选择器，如下 :nth-child(even)选择每个父元素下的索引值是偶数的元素 :nth-child(odd)选择每个父元素下的索引值是奇数的元素 :nth-child(2)选择每个父元素下的索引值是2的元素 :nth-child(3n)选择每个父元素下的索引值是3的倍数的元素 (n从1开始) 表单对象属性过滤选择器 选择器 说明 返回 :enabled 选取所有可用元素 集合元素 :disabled 选取所有不可用元素 集合元素 :checked 选取所有被选中的元素（单选框、复选框） 集合元素 :selected 选取所有被选中的元素（下拉列表） 集合元素 表单选择器 选择器 说明 :input 选取所有input textarea select button元素 :text 选取所有单行文本框 :password 选取所有密码框 :radio 选取所有单选框 :checkbox 选取所有多选框 :submit 选取所有的提交按钮 :image 选取所有的图像按钮 :reset 选取所有的重置按钮 :button 选取所有的按钮 :file 选取所有的上传域 :hidden 选取所有的不可见元素 特定位置选择器 :first :last :eq(index) 指定范围选择器 :even :odd :gt(index) :lt(index) 排除选择器 :not 非 第三节 选择器优化 使用合适的选择器表达式可以提高性能、增强语义并简化逻辑。常用的选择器中，ID选择器速度最快，其次是类型选择器。 a. 多用ID选择器 b. 少直接使用class选择器 c. 多用父子关系，少用嵌套关系 d. 缓存jQuery对象 使用过滤器 jQuery提供了2种选择文档元素的方式：选择器和过滤器 a. 类过虑器：根据元素的类属性来进行过滤操作。 hasClass(className)：判断当前jQuery对象中的某个元素是否包含指定类名，包含返回true，不包含返回false b. 下标过滤器：精确选出指定下标元素 eq(index)：获取第N个元素。index是整数值，下标从0开始 c. 表达式过滤器 filter(expr)/(fn)：筛选出与指定表达式/函数匹配的元素集合。 功能最强大的表达式过滤器，可接收函数参数，也可以是简单的选择器表达式 d. 映射 map(callback)：将一组元素转换成其他数组 e. 清洗 not(expr)：删除与指定表达式匹配的元素 f. 截取 slice(start,end)：选取一个匹配的子集 查找 向下查找后代元素 children():取得所有元素的所有子元素集合（子元素） find():搜索所有与指定表达式匹配的元素(所有后代元素中查找) 查找兄弟元素 siblings()查找当前元素的兄弟 第四节 代理对象属性和样式操作 代理对象属性和样式操作 attr prop(一般属性值是boolean的值或者不用设置属性值，一般使用) css(最好不用，一般我用来做测试) addClass / removeClass 操作原生DOM的时候用的方式：一次只能操作一个 操作属性：setAttribute / getAttribute 操作样式：style.xx = value 操作类样式：className=&#39;&#39; 获取DOM的子元素children属性 DOM里面添加一个子元素appendChild() 操作jQuery代理对象的时候：批量操作DOM对象(全都是通过方法操作) 操作属性：attr()、prop() attr和prop区别：如果属性的值是布尔类型的值 用prop操作 反之attr attr主要依赖的是Element对象的getArribute()和setAttribute()两个方法 prop主要依赖的是JS中的对象属性和设置方式 操作样式：css() 操作类样式：addClass() removeClass() 操作DOM子元素：children() 添加子元素：append() 第五节 jQuery中DOM操作 DOM是一种与浏览器、平台|语言无关的接口，使用该接口可以轻松的访问 页面中的所有的标准组件 DOM操作的分类 DOM Core DOM core并不专属于JavaScript，任何支持DOM的程序都可以使用 JavaScript 中的getElementByID() getElementsByTagName() getAttribute() setAttribute()等方法都是DOM Core的组成部分 HTML-DOM HTML -DOM的出现比DOM-Core还要早，它提供一些更简明的标志来描述HTML元素的属性 比如：使用HTML-DOM来获取某元素的src属性的方法 element.src CSS-DOM 针对CSS的操作。在JavaScript中，主要用于获取和设置style对象的各种属性，通过改变style对象的属性，使网页呈现不同的效果 查找、创建、删除、复制、替换节点 查找节点 查找属性节点 attr() 可以获取各属性的值 创建节点 $(html)：根据传递的标记字符串，创建DOM对象 插入节点 方法 说明 append() 插入到所有子元素的最后一位 appendTo() 颠倒append()的操作 prepend() 插入到所有子元素的第一位 prependTo() 颠倒prepend()的操作 after() 剪切到元素的后面 insertAfter() 颠倒after()的操作 before() 剪切到元素的前面 insertBefore() 颠倒before()的操作 删除节点 jQuery提供了三种删除节点的方法 remove() detach() empty() remove()方法 当某个节点用remove()方法删除后，该节点所包含的所有后代节点将同时被删除，将会只剩下一个DOM元素，不再有事件功能了，但还是可以继续使用删除后的引用 detach() 和remove()方法一样，也是从DOM中去掉所有匹配的元素，与remove()不同的是，所有绑定的事件、附加的数据等，都会被保留下来，等待下一次的使用 empty() empty()方法并不是删除节点，而是清空节点，它能清空元素中所有后代节点 复制节点 使用clone()方法来完成 在clone()方法中传递一个参数true，同时复制元素中所绑定的事件 替换节点 replaceWith():将所有匹配的元素替换成指定的元素 replaceAll():用匹配的元素替换掉指定元素 注意：两者效果一致，只是语法不同 $A.replaceAll($B)等效于 $B.replaceWhith($A); 样式操作 获取样式和设置样式 attr() 追加样式 addClass()，添加属性 移除样式 removeClass()移除属性 切换样式 toggle() 方法只要是控制行为上的重复切换（如果元素是显示的，则隐藏；如果元素原来是隐藏的，则显示） toggleClass() 方法控制样式上的重复切换（如何类名存在，则删除它，如果类名不存在，则添加它） 判断是否含有某个样式 hasClass() 可以用来判断元素是否含有某个class,如有返回true 该方法等价于is() 设置和获取HTML、文本和值 html() 此方法类似JavaScript中innerinnerHTML属性，可以用来读取和设置某个元素中的HTML内容 text() 此方法类型JavaScript中innerHTML，用来读取和设置某个元素中的文本内容 val() 此方法类似JavaScript中的value属性，用来设置获取元素的值。无论是文本框、下拉列表还是单选框，都可以返回元素的值，如果元素多选，返回一个包含所有选择的值的数组 遍历节点 children() 方法 该方法用来取得匹配元素的子元素集合 childre()方法只考虑子元素而不考虑其他后代元素 next() 方法 返回被选元素的后一个同级元素 nextAll() 方法 当前元素下面的所有同级元素 prev() 方法 返回被选元素的前一个同级元素 prevAll() 方法 当前元素前面的所有同级元素 siblings() 方法 用于匹配元素前后所有的同辈元素 prevUntil() 方法 prevUntil()方法返回selector与stop之间的每个元素之前所有同级元素 $(“selector”).prevvUntil(“stop”) 返回在类名为 “start” 和 “stop”的两个&lt;li&gt;元素之间的所有同级元素： nextUntil() 方法 nextUntil()方法返回selector与stop之间的每个元素之后所有同级元素 $(“selector”).nextUntil(“stop”) 返回在类名为 “start” 和 “stop”的两个&lt;li&gt;元素之间的所有同级元素： parent() 方法 获得集合中每个元素的父级元素 parents() 方法 获得集合中每个元素的祖先元素 offsetparent() 方法 返回离自己最近用于定位的父节点元素 closest() 方法 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 定位操作 CSS DOM技术简单的来说就是读取和设置style对象的各种属性 用css()方法获取元素的样式属性，可以同时设置多个样式属性 CSS DOM中关于元素定位有几个常用的方法 offset() 方法 它的作用是获取元素在当前视窗的相对偏移其中返回的对象包含两个属性，即top和left，他只对可见元素有效 position() 方法 获取相对于最近的一个position()样式属性设置为relative或者absolute的祖父节点的相对偏移，与offset()一样，他返回的对象也包括两个属性，即top和left scrollTop() 方法和 scrollLeft() 方法 这两个方法的作用分别是获取元素的滚动条距顶端的距离和距左侧的距离 一张图总结以上的位置关系(项目中很常用-必须要弄清楚) width() 方法 取得第一个匹配元素当前计算的实际宽度值（px） height() 方法 取得匹配元素当前计算的实际高度值（px）。 innerWidth() 方法 获取第一个匹配元素内部区域宽度（包括补白、不包括边框）（content + padding） innerHeight() 方法 获取第一个匹配元素内部区域高度（包括补白、不包括边框）（content + padding） outerWidth() 方法 获取第一个匹配元素外部宽度（默认包括补白和边框）（content + padding + border），参数为true的时候，求出宽度带有margin outerHeight() 方法 获取第一个匹配元素外部高度（默认包括补白和边框）（content + padding + border），参数为true的时候，求出宽度带有margin 其他方法 each() 方法 遍历数组元素 each(function(index,ele){}) index：代表索引值，ele：代表元素本身 wrap() 方法 把选中的元素用其他元素的结构化标记包裹起来 如：$(&#39;li&#39;).wrap($(&#39;&lt;div&gt;&#39;))，把每一个li用div包裹起来 wrap(function(index,ele){}) wrapInner() 方法 在选中的元素里面用其他元素的结构化标记包裹起来 如：$(&#39;li&#39;).wrap($(&#39;&lt;p&gt;&#39;))，用div把li里面包裹起来 wrapInner(function(index,ele){}) wrapAll() 方法 将所有选中的元素用单个元素包裹起来 容易破坏页面结构 unwrap() 方法 unwrap() 方法删除被选元素的父元素 end() 方法 回到最近的一个”破坏性”操作之前。即，将匹配的元素列表变为前一次的状态。 他之前会在prevObject上面存储上一次操作的内容，end()就是调用了prevObject里面的内容，所以说调取end()就相当于调取了prevObject add() 方法 将元素添加到选好的元素的集合中 把&lt;p&gt;和&lt;span&gt;元素添加到已存在的元素组合中&lt;h1&gt; 可以集中操作 $(&#39;li&#39;).eq(0).add($(&#39;li&#39;).eq(4)).css({width:100}) slice(a,b) 方法 选取一个匹配的子集 选取a到b之间的内容，包括a,不包括b（算头不算尾） 第六节 jQuery中的事件 事件对象的属性 event.type：获取事件的类型 event.target:获取到触发事件的元素 event.preventDefault方法 阻止默认事件行为 event.stopPropagation()阻止事件的冒泡 keyCode：只针对于keypress事件，获取键盘键数字 按下回车，13 event.pageX / event.pageY 获取到光标相对于页面文档的x坐标和y坐标 如果没有jQuery，在IE浏览器中用event.x / event.y;在Firefox浏览器中用event.pageX / event.pageY。如果页面上有滚动条还要加上滚动条的宽度和高度 event.clientX：光标对于浏览器窗口的水平坐标 event.clientY：光标对于浏览器窗口的垂直坐标 event.screenX：光标对于电脑屏幕的水平坐标 电脑屏幕 event.screenY：光标对于电脑屏幕的水平坐标 event.which 该方法的作用是在鼠标单击事件中获取到鼠标的左、中、右键，和在键盘事件中的按键 1代表左键 2代表中键 3代表右键 事件冒泡 什么是冒泡 在页面上可以有多个事件，也可以多个元素影响同一个元素 从里到外 嵌套关系 相同事件 其中的某一父类没有相同事件时,继续向上查找 停止事件冒泡 停止事件冒泡可以阻止事件中其他对象的事件处理函数被执行 在jQuery中提供了stopPropagation()方法 阻止默认行为 网页中元素有自己的默认行为，例如：单击超链接后会跳转、单击提交后表单会提交，有时需要阻止元素的默认行为 在jQuery中提供了preventDefault()方法来阻止元素的默认行为 事件捕获 事件捕获和冒泡是相反的过程，事件捕获是从最顶端往下开始触发 并非所有的浏览器都支持事件捕获，并且这个缺陷无法通过JavaScript来修复。jQuery不支持事件捕获，如需要用事件捕获，要用原生的JavaScript 绑定自定义事件 trigger()：方法触发被选元素的自定义指定事件类型 例如：1234$('#demo').on('eat',function(event,a)&#123; console.log(a);&#125;)$('#demo').tigger('eat',[100]); 会事件冒泡 on();事件绑定方法 on(events,[selector],[data],fn); bind();绑定，旧版本的 为匹配元素绑定处理方法 需要给一个元素添加多个事件 ，事件执行一样时候 one()：只执行一次 绑定特定事件类型方法： 分类 页面载入方法 说明 页面载入 ready(fn) 当DOM载入就绪可以绑定一个要执行的函数 分类 事件绑定（解除绑定）方法 说明 事件绑定 on(type,[selector],[data],fn) 在选择元素上绑定一个或者多个事件处理函数，[data]是参数，[selector]是事件源对象 事件绑定 off() 移除on绑定的事件 事件绑定 one() 只触发绑定事件一次 事件绑定 bind(type,[data],fn) 为每个匹配元素的特定事件绑定一个事件处理函数 事件绑定 unblind() 解除绑定 事件绑定 delegate(selector,eventType,handler) 为所有选择匹配元素附加一个或多个事件处理函数 事件绑定 undelegate() 移除绑定 分类 事件动态方法 说明 事件动态 live(type,fn) 对动态生成的元素进行事件绑定 事件动态 die(type,fn) 移除live()绑定的事件 分类 鼠标交互方法 说明 交互事件 click() 当鼠标指针点击元素时，触发click方法 鼠标事件 mousedown(fn) 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedow方法 鼠标事件 mouseenter(fn) 鼠标指针移动到元素上时触发mouseenter方法 鼠标事件 mouseleave(fn) 当鼠标指针离开元素时，会发生mouseleave方法 鼠标事件 mousemove(fn) 当鼠标指针在指定的元素中移动时，就会发生mousemove方法 鼠标事件 mouseout(fn) 当鼠标指针从元素上移开时，发生mouseout方法 鼠标事件 mouseover(fn) 当鼠标指针位于元素上方时，会发生mouseover方法 鼠标事件 mouseup(fn) 当在元素上放松鼠标按钮时，会发生mouseup方法 鼠标事件 blur(fn) 当元素失去焦点时触发blur方法 鼠标事件 focus() 当元素获得焦点时，触发focus方法 鼠标事件 hover() 鼠标移入移出触发hover方法 鼠标事件 toggle(fn1,fn2,[fn3],[fn4]) 每单击后依次调用函数 鼠标事件 change() 当元素的值发生改变时，会发生change方法 鼠标事件 submit() 当提交表单时，会发生submit方法 分类 键盘交互方法 说明 键盘事件 keydown() 当键盘或按钮被按下时，发生keydown事件。 键盘事件 keypress() 当键盘按键被按下并释放一个键时发生keypress事件 键盘事件 keyup() 当按钮被松开时，发生keyup事件。它发生在当前获得焦点的元素上 分类 窗口操作方法 说明 窗口操作 resize(fn) 绑定一个处理函数 窗口操作 scroll(fn) 绑定一个处理函数 第七节 jQuery动画 JavaScript语言本身不支持动画设计，必须通过改变CSS来实现动画效果 显隐动画 show():显示 hide():隐藏 原理：hide()通过改变元素的高度宽度和不透明度，直到这三个属性值到0 show()从上到下增加元素的高度，从左到右增加元素宽度，从0到1增加透明度，直至内容完全可见 参数： show(speed,callback) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） callback: 动画完成时执行的方法 显示和隐藏式一对密不可分的动画形式 显隐切换 toggle():切换元素的可见状态 原理：匹配元素的宽度、高度以及不透明度，同时进行动画，隐藏动画后将display设置为none 参数： toggle(speed) toggle(speed,callback) toggle(boolean) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） easing： 使用哪个缓冲函数来过渡的字符串(linear/swing) callback： 动画完成时执行的方法 boolean:true为显示 false为隐藏 滑动 显隐滑动效果 slideDown():滑动显示 slideUp():滑动隐藏 参数: slideDown(speed,callback) slideUp(speed,callback) 显隐切换滑动 slideToggle():显隐滑动切换 参数: slideToggle(speed,callback) 如果是显示的，那么滑动隐藏 如果是隐藏的，那么滑动显示 渐变：通过改变不透明度 淡入淡出 fadeIn() 淡入 fadeOut() 淡出 参数： fadeIn(speed,callback) fadeOut(speed,callback) 设置淡出透明效果 fadeTo()⁭：以渐进的方式调整到指定透明度 参数： fadeTo(speed,opacity,callback) 渐变切换:结合fadeIn和fadeOut fadeToggle() 参数: fadeOut(speed,callback) 如果是显示的，那么淡入 如果是隐藏的，那么淡出 自定义动画：animate() 注意：在使用animate方法之前，为了影响该元素的top left bottom right样式属性，必须先把元素的position样式设置为relative或者absolute animate() 方法有四个参数 animate({变化参数},’时间’,’运动速率’,’回调函数’) 变化参数 比如：width,height 回调函数 执行完动画返回的结果，也可以进行下一次动画 运动速率 linear代表匀速（直线）运动 swing代表慢快慢的运动 jQuery当中就提供了这两种速率，如果想要更多效果，可以引入jQuery插件:jquery.sasing.js 停止元素的动画 很多时候需要停止匹配正在进行的动画，需要使用stop() stop()语法结构：stop([clearQueue],[gotoEnd]); 都是可选参数，为布尔值 第一个参数，是否停止后续所有运动，false，不停止，true，停止 第二个参数：是否立即到达当前目标点，false：不到达，true：到达 如果直接使用stop()方法，会立即停止当前正在进行的动画 判断元素是否处于动画状态 如果不处于动画状态，则为元素添加新的动画，否则不添加if(!$(element).is(&quot;:animated&quot;)){ //判断元素是否处于动画状态} 这个方法在animate动画中经常被用到，需要注意 延迟动画：delay() 在动画执行过程中，如果你想对动画进行延迟操作，那么使用delay() 用animate模拟show(): show: 表示由透明到不透明 toggle: 切换 hide:表示由显示到隐藏 里面可以用各种样式，也可以设置事件，linear代表匀速（直线）运动，swing代表慢快慢的运动 动画方法总结 方法名 说明 hide()和show() 同时修改多个样式属性即高度和宽度和不透明度 fadeIn()和fadeOut() 只改变不透明度 slideUp()和slideDown() 只改变高度 fadeTo() 只改变不透明度 toggle() 用来代替show()和hide()方法，所以会同时修改多个属性即高度、宽度和不透明度 slideToggle() 用来代替slideUp和slideDown()方法，所以只能改变高度 fadeToggle() 用来代替fadeIn()和fadeOut方法，只能改变不透明度 animate() 属于自定义动画，以上各种动画方法都是调用了animate方法。此外，用animate方法还能自定义其他的样式属性，例如：left marginLeft ``scrollTop等 第八节 jQuery工具方法 实例方法是定义在原型上面 定义在jQuery函数上面的方法就叫做工具方法，如：jQuery.type()，$.type() type() 判断数据类型 原生js里面的判断数据类型 typeof arr; arr instanceof Array arr.constructor == &#39;Array&#39; Object.prototype.toString.call(arr); trim() 消除两边的空格（字符串中间的空格消除不掉） proxy() 改变this指向 参数1：要改变this指向的函数或变量 参数2：this要指向的函数或变量 如：12345678910111213141516171819202122232425 function show(a,b) &#123;console.log(this); console.log(a + '' + b); &#125; var obj = &#123; name: 'aimee' &#125; $.proxy(show,obj)(1,2); // 把show的this指向obj // 在最后还可以传参，也可以这样传参 // $.proxy(show,obj,1,2); // $.proxy(show,obj,1)(2); // 柯里化的思想 function show(nianji,xuehao) &#123; console.log(nianji); console.log(xuehao); &#125; var obj = &#123; name: 'aimee' &#125; var fn = $.proxy(show,obj,2014); fn(201401010101); fn(201402020202); // 不用再次传参,直接传需要的，不用传好几个参数了 noConflict() 防止冲突，如var jq = $.noConflict(removeAll) 让渡变量$的jQuery控制权 该方法释放 jQuery对$变量的控制。 该方法也可用于为jQuery变量规定新的自定义名称 parseJSON() 解析一个JSON字符串，如var obj = $.parseJSON(&#39;{&quot;name&quot;:&quot;John&quot;}&#39;) 用于将符合标准格式的的JSON字符串转为与之对应的JavaScript对象 makeArry() 把类数组转换成数组 extend() 定义在了jQuery函数上面 在jQuery源码当中，有很多的工具方法都是基于extend方法来实现的 扩展提供了新的jQuery工具方法，用来拓展一个新的工具或实例方法 这两个函数是一样的，只不过一个是在jQuery方法上面，一个是在prototype上面 $.extend() $.fn.extend() fn就是prototype,$.fn就是相当于$.prototype 这个extend()定义在了prototype上面 1234567891011用来拓展一个新的工具或实例方法，就是自己在`jQuery`方法上创建一个方法,$.extend(&#123; leftTrim: function (str) &#123; var reg = /^\\s+/g; return str.replace(reg,''); &#125;&#125;)console.log($.leftTrim(' dg'));// 调用这个 leftTree，就和调用其他的 jQuery 方法一样// 作用是消除左侧空格 123456789101112131415161718192021还可以合并对象，`fn.extend`同时适用var obj1 = &#123; parson1: &#123; name: 'dg', age: 55 &#125;, number: 1&#125;var obj2 = &#123; parson2: &#123; name: 'cg', age: 30 &#125;, number: 2&#125;var aa = $.extend(true,obj1,obj2)// 把obj2和合并到了obj1// true是深拷贝，取掉true就是浅拷贝// 后面相同的会覆盖到前面的 Callbacks() 回调函数，返回回调函数对象 管理回调队列 可以混合搭配，同时使用 fire() 执行函数（可执行多次） add() 调取函数（可传参多个） once() 参数，只执行一次fire函数 unique 参数，在add调用函数里，相同的函数只执行一遍 memory 参数，记忆，fire()后面的函数依旧会被执行 stopOnFalse 参数，上个回调函数返回false之后中断后面的回调函数 123456789101112131415161718192021function fn1 () &#123; console.log('fn1');&#125;function fn2 () &#123; console.log('fn2'); return false;&#125;function fn3 () &#123; console.log('fn3');&#125;var cb = $.Callbacks('memory once stopFalse unique') // memory：fire后面的函数依旧会被执行// once：fire函数只会执行一次// stopOnFalse：fn2返回了false，fn3不会被执行，和memory相抵触，没有作用// unique：在一个add调用函数里面，只执行一遍函数cb.add(fn1,fn1); // 调用函数fn1,fn1cb.add(fn2); // 调用函数fn2cb.fire(); // 执行函数队列cb.fire(); // 执行函数队列cb.add(fn3); // 调用函数fn3 Deferred() 延迟回调对象，相当于有状态的Callbacks() 添加函数 done 对象被受理时，调用添加的处理程序 fail 对象被拒绝时，调用添加的处理程序 progress 调用正在进行中的对象上进行的回调函数 触发函数 resolve 成功的状态 reject 失败的状态 notity 进行中的状态 promise 不能触发函数1234567891011121314151617181920212223function demo() &#123; var dtd = c$.Deferred(); // 让一个变量代替Deferred，解决重复使用 setInterval(function () &#123;dtd.notify()&#125;,500)// notity()，进行中的状态 setInterval(function () &#123;dtd.reject()&#125;,1000)// reject()，失败的状态 setInterval(function () &#123;dtd.resolve()&#125;,2000)// resolve()，成功的状态 return dtd.promise(); // 返回dtd函数&#125;var cb = demo(); // 闭包，接受dtd函数//cb.resolve(); 这个不可以在外面执行了，因为dtd返回的是只读的Deferred对象cb.done(function () &#123; // done，对象成功的时候调用 console.log('OK')&#125;).fail(function () &#123; // fail，对象失败的时候调用 console.log('error')&#125;).progress(function () &#123; // progress，正在进行时调用 console.log('doing')&#125;)// 成功和失败的状态不会改变，如果失败就不会执行成功了，但是进行中可以改变状态 when() 里面传的参数是Deferred对象 执行完之后会return出来一个Deferred对象 当when里面传的几个Deferred对象，同时都为成功的状态时，才能触发done里面的内容，但凡有一个失败的，就会执行fail里面的内容123456789101112131415161718192021222324function aa() &#123; var dtd = $.Deferred();// 让回调函数有转台 dtd.resolve(); // 成功的状态 return dtd.promise(); // &#125;function bb() &#123; var dtd = $.Deferred(); // 让回调函数有转台 dtd.resolve();// 成功的状态 return dtd.promise();&#125;var cb = aa();var cb2 = bb();$.when(cb,cb2).done(function () &#123; console.log('OK')&#125;).fail(function () &#123; console.log('error')&#125;).progress(function () &#123; console.log('doing')&#125;) 第九节 jQuery与Ajax Ajax简介 : Asynchronous Javascript And XML （异步的JavaScript和XML） 它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体 Ajax优势与不足 Ajax优势 优秀的用户体验 这是Ajax下最大的有点，能在不刷新整个页面前提下更新数据 提高web程序的性能 与传统模式相比，Ajax模式在性能上最大的区别在于传输数据的方式，在传统模式中，数据的提交时通过表单来实现的。Ajax模式只是通过XMLHttpRequest对象向服务器提交希望提交的数据，即按需发送 减轻服务器和带宽的负担 Ajax的工作原理相当于在用户和服务器之间加了一个中间层，似用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器负担的工作转移到客户端，便于客户端资源来处理，减轻服务器和带宽的负担 Ajax的不足 浏览器对XMLHttpRequest对象的支持度不足 破坏浏览器前进、后退按钮的正常功能 对搜索引擎的支持的不足 开发和调试工具的缺乏 创建一个Ajax请求 serialize() 方法 串联表单对象，序列表表格内容为字符串，用于 Ajax 请求。 serializeArray() 方法 把串联表单对象的形式用数组表示出来 Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成 创建ajax对象 var xhr = new XMLHttpRequest(); 准备发送请求 get / post get 传递的数据放在URL后面 中文编码 encodeURI( &#39;&#39; ); 缓存 在数据后面加上随机数或者日期对象或者…… post 传递的数据放在send()里面，并且一定要规定数据格式 没有缓存问题 form表单中: action: method: (默认是get) get: 会在url里面以 name=value , 两个数据之间用 &amp; 连接 post: enctype: &quot;application/x-www-form-urlencoded&quot; url 是否异步 同步(false)：阻塞 异步(true)：非阻塞 正式发送请求 ajax请求处理过程 123456xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4) &#123; alert( xhr.responseText ); &#125;&#125;; onreadystatechange ：当处理过程发生变化的时候执行下面的函数 readyState ：ajax处理过程 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 responseText ：请求服务器返回的数据存在该属性里面 status : http状态码 案例：ajax封装案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//ajax请求后台数据var btn = document.getElementsByTagName(\"input\")[0];btn.onclick = function()&#123; ajax(&#123;//json格式 type:\"post\", url:\"post.php\", data:\"username=poetries&amp;pwd=123456\", asyn:true, success:function(data)&#123; document.write(data); &#125; &#125;);&#125;//封装ajaxfunction ajax(aJson)&#123; var ajx = null; var type = aJson.type || \"get\"; var asyn = aJson.asyn || true; var url = aJson.url; // url 接收 传输位置 var success = aJson.success;// success 接收 传输完成后的回调函数 var data = aJson.data || '';// data 接收需要附带传输的数据 if(window.XMLHttpRequest)&#123;//兼容处理 ajx = new XMLHttpRequest();//一般浏览器 &#125;else &#123; ajx = new ActiveXObject(\"Microsoft.XMLHTTP\");//IE6+ &#125; if (type == \"get\" &amp;&amp; data) &#123; url +=\"/?\"+data+\"&amp;\"+Math.random(); &#125; //初始化ajax请求 ajx.open( type , url , asyn ); //规定传输数据的格式 ajx.setRequestHeader('content-type','application/x-www-form-urlencoded'); //发送ajax请求（包括post数据的传输） type == \"get\" ?ajx.send():ajx.send(aJson.data); //处理请求 ajx.onreadystatechange = function(aJson)&#123; if(ajx.readState == 4)&#123; if (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码 &#123; //请求成功处理数据 success &amp;&amp; success(ajx.responseText); &#125;else&#123; alert(\"请求出错\"+ajx.status); &#125; &#125; &#125;; jQuery中的Ajax [补充部分–来自锋利的jQuery] jquery对Ajax操作进行了封装，在jquery中的$.ajax()方法属于最底层的方法，第2层是load()、$.get()、$.post();第3层是$.getScript()、$.getJSON()，第2层使用频率很高 load()方法 load()方法是jquery中最简单和常用的ajax方法，能载入远程HTML代码并插入DOM中 结构为：load(url,[data],[callback]) 使用url参数指定选择符可以加载页面内的某些元素 load方法中url语法：url selector 注意：url和选择器之间有一个空格 传递方式 load()方法的传递方式根据参数data来自动指定，如果没有参数传递，则采用GET方式传递，反之，采用POST 回调参数 必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、XMLHttpRequest对象 只要请求完成，回调函数就会被触发 12345$(\"#testTest\").load(\"test.html\",function(responseText,textStatus,XMLHttpRequest)&#123; //respnoseText 请求返回的内容 //textStatus 请求状态 ：sucess、error、notmodified、timeout //XMLHttpRequest &#125;) load方法参数 参数名称 类型 说明 url String 请求HTML页面的URL地址 data(可选) Object 发送至服务器的key / value数据 callback(可选) Function 请求完成时的回调函数，无论是请求成功还是失败 $.get()和$.post()方法 load()方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用$.get()和$.post()或$.ajax()方法 注意：$.get()和$.post()方法是jquery中的全局函数 $.get()方法 $.get()方法使用GET方式来进行异步请求 结构为：$.get(url,[data],callback,type) 如果服务器返回的内容格式是xml文档，需要在服务器端设置Content-Type类型 代码如下：header(&quot;Content-Type:text/xml:charset=utf-8&quot;) //php $.get()方法参数解析 参数 类型 说明 url String 请求HTML页的地址 data(可选) Object 发送至服务器的key/ value 数据会作为QueryString附加到请求URL中 callback(可选) Function 载入成功的回调函数（只有当Response的返回状态是success才调用该方法） type(可选) String 服务器返回内容的格式，包括xml、html、script、json、text和_default $.post()方法 它与$.get()方法的结构和使用方式相同，有如下区别 GET请求会将参数跟张乃URL后进行传递，而POST请求则是作为Http消息的实体内容发送给web服务器，在ajax请求中，这种区别对用户不可见 GET方式对传输数据有大小限制（通常不能大于2KB），而使用POST方式传递的数据量要比GET方式大得多（理论不受限制） GET方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，GET方式会带来严重的安全问题，而POST相对来说可以避免这些问题 GET和POST方式传递的数据在服务端的获取也不相同。在PHP中，GET方式用$_GET[]获取；POST方式用$_POST[]获取;两种方式都可用$_REQUEST[]来获取 总结 使用load()、$.get()和$.post()方法完成了一些常规的Ajax程序，如果还需要复杂的Ajax程序，就需要用到$.ajax()方式 $.ajax()方法 $.ajax()方法是jquery最底层的Ajax实现，它的结构为$.ajax(options) 该方法只有一个参数，但在这个对象里包含了$.ajax()方式所需要的请求设置以及回调函等信息，参数以key / value存在，所有参数都是可选的 $.ajax()方式常用参数解析 参数 类型 说明 url String (默认为当前页地址)发送请求的地址 type String 请求方式（POST或GET）默认为GET timeout Number 设置请求超时时间（毫秒） dataType String 预期服务器返回的类型。可用的类型如下 xml:返回XML文档，可用jquery处理html:返回纯文本的HTML信息，包含的script标签也会在插入DOM时执行script：返回纯文本的javascript代码。不会自动缓存结果，除非设置cache参数。注意：在远程请求时，所有的POST请求都将转为GET请求json:返回JSON数据jsonp:JSONP格式，使用jsonp形式调用函数时，例如：myurl?call back=?,jquery将自动替换后一个？为正确的函数名，以执行回调函数text:返回纯文本字符串 beforeSend Function 发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次Ajax请求。XMLHttpRequest对象是唯一的参数 function(XMLHttpRequest){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this;//调用本次Ajax请求时传递的options参数} complete Function 请求完成后的回调函数（请求成功或失败时都调用） 参数：XMLHttpRequest对象和一个描述成功请求类型的字符串function(XMLHttpRequest,textStatus){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this;//调用本次Ajax请求时传递的options参数} success Function 请求成功后调用的回调函数，有两个参数(1)由服务器返回，并根据dataTyppe参数进行处理后的数据(2)描述状态的字符串function(data,textStatus){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//data可能是xmlDoc、``jsonObj、html、text等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this;//调用本次Ajax请求时传递的options参数} error Function 请求失败时被调用的函数 global Boolean 默认为true。表示是否触发全局Ajax事件，设置为false将不会触发。AjaxStart或AjaxStop可用于控制各种Ajax事件 第十节 插件 什么是插件 插件(Plugin)也称为jQuery的扩展。以jQuery核心代码为基础编写的符合一定规范的应用程序。通过js文件的方式引用。 插件分为哪几类 UI类、表单及验证类、输入类、特效类、Ajax类、滑动类、图形图像类、导航类、综合工具类、动画类等等 引入插件的步骤 引入jquery.js文件，而且在所以插件之前引入 引入插件 引入插件相关文件，比如皮肤、中文包 如何自定义插件： 插件形式分为3类： 封装对象方法插件 封装全局函数插件 选择器插件(类似于.find()) 自定义插件的规范（解决各种插件的冲突和错误，增加成功率） 命名：jquery.插件名.js 所有的新方法附加在jquery.fn对象上面，所有新功能附加在jquery上 所有的方法或插件必须用分号结尾，避免出问题 插件必须返回jQuery对象，便于链式连缀 避免插件内部使用$，如果要使用，请传递jQuery($并不是总等于jQuery，另外其他js框架也可能使用$) 插件中的this应该指向jQuery对象 使用this.each()迭代元素 自定义插件案例 为了方便用户创建插件，jQuery提供了 jQuery.extend() 和 jQuery.fn.extend() jQuery.extend()：创建工具函数或者是选择器 jQuery.fn.extend()：创建jQuery对象命令 （fn相当于prototype的别名） jQuery官方提供的插件开发模板 1234567891011121314;(function($)&#123; $.fn.plugin=function(options)&#123; var defaults = &#123; //各种参数 各种属性 &#125; var options = $.extend(defaults,options); this.each(function()&#123; //实现功能的代码 &#125;); return this; &#125;&#125;)(jQuery); 自定义jQuery函数： 1234567(function($)&#123; $.extend(&#123; test: function()&#123; alert(\"hello plugin\"); &#125; &#125;) &#125;)(jQuery); 自定义jQuery命令： 形式1： 1234567(function($)&#123; $.fn.extend(&#123; say : function()&#123; alert(\"hello plugin\"); &#125; &#125;)&#125;)(jQuery); 形式2： 123456(function($)&#123; $.fn.say = function()&#123; alert(\"hello plugin\"); &#125;; &#125;)(jQuery); 附录一 jQuery各个版本新增的一些常用的方法 jQuery1.3新增常用的方法 方法 说明 .closest() 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 die() 从元素中删除先前用live()方法绑定的所有的事件 live() 附加一个事件处理器到符合目前选择器的所有元素匹配 jQuery1.4新增常用的方法 方法 说明 .first() 获取集合中第一个元素 last() 获取集合中最后一个元素 has(selector) 保留包含特定后代的元素，去掉那些不含有指定后代的元素 detach() 从DOM中去掉所有匹配的元素。detach()和remov()一样，除了detach()保存了所有jquery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用 delegate() 为所有选择器匹配的元素附加一个处理一个或多个事件 undelegate() 为所有选择器匹配的元素删除一个处理一个或多个事件 jQuery1.6新增常用的方法 方法 说明 prop(proptyName) 获取在匹配元素集合中的第一个元素的属性值 removeProp(proptyName,value) 为匹配的元素删除设置的属性 :focus 选择当前获取焦点的元素 附录二 jQuery性能优化 性能优化 使用最新版的jQuery类库 使用合适的选择器 $(#id) 使用id来定位DOM元素是最佳的方式，为了提高性能，建议从最近的ID元素开始往下搜索 $(&quot;p&quot;) , $(&quot;div&quot;) , $(&quot;input&quot;) 标签选择器性能也不错，它是性能优化的第二选择。因为jQuery将直接调用本地方法document.getElementsByTagName()来定位DOM元素 $(&quot;.class&quot;) 建议有选择性的使用 $(&quot;[attribute=value]&quot;) 对这个利用属性定位DOM元素，本地JavaScript并没有直接实现。这种方式性能并不是很理想。建议避免使用。 $(&quot;:hidden&quot;) 和上面利用属性定位DOM方式类似，建议尽量不要使用 注意的地方 尽量使用ID选择器 尽量给选择器指定上下文 缓存对象 如果你需要在其他函数中使用jQuery对象，你可以把他们缓存在全局环境中 数组方式使用jQuery对象 使用jQuery选择器获取的结果是一个jQuery对象。在性能方面，建议使用for或while循环来处理，而不是$.each() 事件代理 每一个JavaScript事件（如：click、mouseover）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时这点很有用。比如，我们要为一个表单绑定这样的行为：点击td后，把背景颜色设置为红色 $(&quot;#myTable td&quot;).click(function(){$(this).css(&quot;background&quot;,&quot;red&quot;);}); 假设有100个td元素，在使用以上的方式时，绑定了100个事件，将带来性能影响 代替这种多元素的事件监听方法是，你只需向他们的父节点绑定一次事件，然后通过event.target获取到点击的当前元素 $(&quot;#myTable td&quot;).click(function({$(e.target).css(&quot;background&quot;,&quot;red&quot;)}); e.target捕捉到触发的目标 在jQuery1.7中提供了一个新的方法on()，来帮助你将整个事件监听封装到一个便利的方法中 $(&quot;#myTable td&quot;).on(&quot;click&quot;,&#39;td&#39;,function(){$(this).css(&quot;background&quot;,&quot;red&quot;);}); 将你的代码转化成jQuery插件 它能够使你的代码有更好的重用性，并且能够有效的帮助你组织代码 使用join()方法来拼接字符串 也许你之前使用+来拼接字符串，现在可以改了。它确实有助于性能优化，尤其是长字符串处理的时候 合理使用HTML5和Data属性 HTML5的data属性可以帮助我们插入数据，特别是后端的数据交换。jQuery的Data()方法有效利用HTML5的属性 例如：&lt;div id=&quot;dl&quot; data-role=&quot;page&quot; data-list-value=&quot;43&quot; data-options=&#39;{&quot;name:&quot;&quot;John&quot;}&#39;&gt; 为了读取数据，你需要使用如下代码 $(&quot;#dl&#39;).data(&quot;role&#39;;//page) $(&quot;#dl&#39;).data(&quot;lastValue&#39;;//43) $(&quot;#dl&#39;).data(&quot;options&#39;;//john) 尽量使用原生的JavaScript方法 压缩JavaScript代码 一方面使用Gzip；另一方面去除JavaScript文件里面的注释、空白 附录三 常用的jQuery代码片段 禁用页面的右键菜单 12345$(document).ready(functuion()&#123; $(document).bind(\"contextmenu\",function(e)&#123; return false; &#125;); &#125;); 新窗口打开页面 1234567891011$(document).ready(function()&#123; //例子1：href=\"http://\"的链接将会在新窗口打开链接 $('a[href=^=\"http://\"]').attr(\"target\",\"_blank\"); //例子2：rel=\"external\"的超链接将会在新窗口打开链接 $(\"a[rel$='external']\").click(function()&#123; this.target = \"_blank\"; &#125;);&#125;);//use&lt;a href=\"http://baidu.com\" rel=\"external\"&gt;open&lt;/a&gt; 判断浏览器类型 123456789101112131415161718192021222324252627282930313233$(document).reday(function()&#123; //Firefox2 and above if( $.browser.mozilla &amp;&amp; $.browser.version&gt;=\"1.8\")&#123; //do something &#125; // Safari if($.browser.safari)&#123; //do something &#125; // Chrome if($.browser.chrome)&#123; //do something &#125; // Opera if($.browser.opera)&#123; //do something &#125;&#125;) // IE6 and blow if($.browser.msie &amp;&amp; $.browser.version&lt;=6)&#123; //do something &#125; // anything above IE6 if($.browser.msie &amp;&amp; $.browser.version &gt; 6)&#123; //do something &#125; 输入框文字获取和失去焦点 123456789101112131415161718$(document).ready(function()&#123; $(\"input.text1\").val(\"Enter you search text here\"); textFill($('input.text1'));&#125;);function textFill(input)&#123;//input focus text function var originvalue = input.val(); input.focus(funtion()&#123; if($.trim(input.val())== originvalue)&#123; input.val(' '); &#125; &#125;).blur(function()&#123; if($.trim(input.val()) == ' ')&#123; input.val(originalvalue); &#125; &#125;)&#125; 获取鼠标位置 123456$(document).ready(function()&#123; $(document).mousemove(function(e)&#123; $(\"#XY\").html(\"X:\" + e.pageX+ \"| Y\" + e.pageY); &#125;);&#125;); 判断元素是否存在 12345$(document).ready(function()&#123; if($(\"#id\").length)&#123; // do some thing &#125;&#125;) 点击div也可以跳转 1234567$(\"div\").click(function()&#123; window.location = $(this).find(\"a\").attr(\"href\");&#125;)//use&lt;div&gt;&lt;a href=\"index.html\"&gt;home&lt;/a&gt;&lt;/div&gt; 设置div在屏幕中央 1234567891011$(document).ready(function()&#123; jQuery.fn.center = function()&#123; this.css(\"position\",\"absolute\"); this.css(\"top\",($(window).height() - this.lenght()) / 2 +$(window).scrollTop() + \"px\"); this.css(\"left\",($(window).height() - this.lenght()) / 2 +$(window).scrollLeft() + \"px\"); return this; &#125;//use $(\"#XY\").center();&#125;); 关闭所有动画效果 123$(document).ready(function()&#123; jQuery.fx.off = true;&#125;); 检测鼠标的右键和左键 12345$(document).ready(function()&#123; $(\"#xy\").mousedown(function(e)&#123; alert(e.which);//1 = 鼠标左键 2= 鼠标中间 3 = 鼠标右键 &#125;);&#125;); 回车提交表单 1234567$(document).ready(function()&#123; $(\"input\").keyup(function(e)&#123; if(e.which == \"13\")&#123; alert(\"回车提交\"); &#125; &#125;)&#125;); 设置全局的Ajax参数 12345678$(\"#load\").ajaxStart(function()&#123; showLoading();//显示loading disableButtons() //禁用按钮&#125;) $(\"#load\").ajaxComplete(function()&#123; hideLoading();//隐藏loading enableButtons();//启用按钮&#125;) 获取选中的下拉框 12$(\"#someElement\").find('option:selected');$(\"#someElement option:selected\"); 切换复选框 12345var tog = false;$(\"button\").click(function()&#123; $(\"input[type=checkbox]').attr(\"checked\",!tog); tog = !tog;&#125;); 个性化链接 12345$(document).ready(function()&#123; $(\"a[href$='pdf']\").addClass(\"pdf\"); $(\"a[href$='zip']\").addClass(\"zip\"); $(\"a[href$='psd']\").addClass(\"psd\");&#125;); 在一段时间后自动隐藏或关闭元素 123456setTimeOut(function()&#123; $(\"div\").fadeIn(400); &#125;,3000);//而在1.4之后的版本可以用delay()来实现$(\"div\").slideUp(300).delay(3000).fadeIn(400); 使用事件代理绑定元素 123456789101112131415161718 //为table里面的td元素绑定click事件，不管td是一直存在还是动态创建的 //jQuery 1.4.2之前使用这种方式 $(\"table\").each(function()&#123; $(\"td\",this).live(\"click\",function()&#123; $(this).toggleClass(\"hover\"); &#125;);&#125;);//jquery 1.4.2使用的方式$(\"table\").delegate(\"td\",\"click\",function()&#123; $(this).toggleClass(\"hover\");&#125;);//jQuery1.7.1使用的方式$(\"table\").on(\"click\",\"td\",function()&#123; $(this).toggleClass(\"hover\"); &#125;) 预加载图片 123456789101112(function($) &#123; var cache = []; // Arguments are image paths relative to the current page. $.preLoadImages = function() &#123; var args_len = arguments.length; for (var i = args_len; i--;) &#123; var cacheImage = document.createElement('img'); cacheImage.src = arguments[i]; cache.push(cacheImage); &#125; &#125;jQuery.preLoadImages(\"image1.gif\", \"/path/to/image2.png\"); 让页面中的每个元素都适合在移动设备上展示 1234567891011var scr = document.createElement('script');scr.setAttribute('src', 'https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js');document.body.appendChild(scr);scr.onload = function()&#123; $('div').attr('class', '').attr('id', '').css(&#123; 'margin' : 0, 'padding' : 0, 'width': '100%', 'clear':'both' &#125;);&#125;; 图像等比例缩放 1234567891011121314151617181920212223242526$(window).bind(\"load\", function() &#123; // IMAGE RESIZE $('#product_cat_list img').each(function() &#123; var maxWidth = 120; var maxHeight = 120; var ratio = 0; var width = $(this).width(); var height = $(this).height(); if(width &gt; maxWidth)&#123; ratio = maxWidth / width; $(this).css(\"width\", maxWidth); $(this).css(\"height\", height * ratio); height = height * ratio; &#125; var width = $(this).width(); var height = $(this).height(); if(height &gt; maxHeight)&#123; ratio = maxHeight / height; $(this).css(\"height\", maxHeight); $(this).css(\"width\", width * ratio); width = width * ratio; &#125; &#125;); //$(\"#contentpage img\").show(); // IMAGE RESIZE&#125;); 返回页面顶部 12345678// Back To Top$(document).ready(function()&#123; $('.top').click(function() &#123; $(document).scrollTo(0,500); &#125;);&#125;); //Create a link defined with the class .top&lt;a href=\"#\" class=\"top\"&gt;Back To Top&lt;/a&gt; 使用jQuery打造手风琴式的折叠效果 1234567891011121314151617181920212223var accordion = &#123; init: function()&#123; var $container = $('#accordion'); $container.find('li:not(:first) .details').hide(); $container.find('li:first').addClass('active'); $container.on('click','li a',function(e)&#123; e.preventDefault(); var $this = $(this).parents('li'); if($this.hasClass('active'))&#123; if($('.details').is(':visible')) &#123; $this.find('.details').slideUp(); &#125; else &#123; $this.find('.details').slideDown(); &#125; &#125; else &#123; $container.find('li.active .details').slideUp(); $container.find('li').removeClass('active'); $this.addClass('active'); $this.find('.details').slideDown(); &#125; &#125;); &#125;&#125;; 使用jQuery和Ajax自动填充选择框 12345678910111213$(function()&#123;$(\"select#ctlJob\").change(function()&#123;$.getJSON(\"/select.php\",&#123;id: $(this).val(), ajax: 'true'&#125;, function(j)&#123;var options = '';for (var i = 0; i &lt; j.length; i++) &#123;options += '' + j[i].optionDisplay + '';&#125;$(\"select#ctlPerson\").html(options);&#125;)&#125;)&#125;) 自动替换丢失的图片 12345678// Safe Snippet$(\"img\").error(function () &#123; $(this).unbind(\"error\").attr(\"src\", \"missing_image.gif\");&#125;);// Persistent Snipper$(\"img\").error(function () &#123; $(this).attr(\"src\", \"missing_image.gif\");&#125;); 预防对表单进行多次提交 123456789101112131415$(document).ready(function() &#123; $('form').submit(function() &#123; if(typeof jQuery.data(this, \"disabledOnSubmit\") == 'undefined') &#123; jQuery.data(this, \"disabledOnSubmit\", &#123; submited: true &#125;); $('input[type=submit], input[type=button]', this).each(function() &#123; $(this).attr(\"disabled\", \"disabled\"); &#125;); return true; &#125; else &#123; return false; &#125; &#125;);&#125;); 动态添加表单元素 12345//change event on password1 field to prompt new input$('#password1').change(function() &#123; //dynamically create new input and insert after password1 $(\"#password1\").append(\"\");&#125;); 在窗口滚动时自动加载内容 123456789101112131415161718var loading = false;$(window).scroll(function()&#123; if((($(window).scrollTop()+$(window).height())+250)&gt;=$(document).height())&#123; if(loading == false)&#123; loading = true; $('#loadingbar').css(\"display\",\"block\"); $.get(\"load.php?start=\"+$('#loaded_max').val(), function(loaded)&#123; $('body').append(loaded); $('#loaded_max').val(parseInt($('#loaded_max').val())+50); $('#loadingbar').css(\"display\",\"none\"); loading = false; &#125;); &#125; &#125;&#125;);$(document).ready(function() &#123; $('#loaded_max').val(50);&#125;); 导航菜单背景切换效果 1234567891011121314&lt;ul id='nav'&gt; &lt;li&gt;导航一&lt;/li&gt; &lt;li&gt;导航二&lt;/li&gt; &lt;li&gt;导航三&lt;/li&gt;&lt;/ul&gt;//注意：代码需要修饰完善$('#nav').click(function(e) &#123; // 要知道siblings的使用 $(e.target).addClass('tclass').siblings('.tclass').removeClass('tclass');; &#125;); 解决jQuery, prototype共存，$全局变量冲突问题 12345&lt;script src=\"prototype.js\"&gt;&lt;/script&gt;&lt;script src=\"http://blogbeta.blueidea.com/jquery.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; jQuery.noConflict();&lt;/script&gt; 注意：一定要先引入prototype.js 再引入jquery.js，先后顺序不可错 jQuery 判断元素上是否绑定了事件 12345//jQuery event封装支持判断元素上是否绑定了事件，此方法只适用于jQuery绑定的事件var $events = $(\"#foo\").data(\"events\");if( $events &amp;&amp; $events[\"click\"] )&#123; //your code&#125; 如何正确地使用toggleClass 12345//切换（toggle）类允许你根据某个类的//是否存在来添加或是删除该类。//这种情况下有些开发者使用：a.hasClass('blueButton') ? a.removeClass('blueButton') : a.addClass('blueButton');//toggleClass允许你使用下面的语句来很容易地做到这一点a.toggleClass('blueButton'); 如何设置IE特有的功能 123if ($.browser.msie) &#123; // Internet Explorer就是个虐待狂&#125; 如何验证某个元素是否为空 12345678// 方法一if (! $('#keks').html()) &#123; //什么都没有找到;&#125;// 方法二if ($('#keks').is(\":empty\")) &#123; //什么都没有找到;&#125; 访问IFrame里的元素 123var iFrameDOM = $(\"iframe#someID\").contents();//然后，就可以通过find方法来遍历获取iFrame中的元素了iFrameDOM.find(\".message\").slideUp(); 管理搜索框的值 现在各大网站都有搜索框，而搜索框通常都有默认值，当输入框获取焦点时，默认值消失。而一旦输入框失去焦点，而输入框里又没有输入新的值，输入框里的值又会恢复成默认值，如果往输入框里输入了新值，则输入框的值为新输入的值。这种特效用JQuery很容易实现 1234567$(\"#searchbox\") .focus(function()&#123; $(this).val('')&#125;) .blur(function()&#123; var $this = $(this); // '请搜索...'为搜索框默认值 ($this.val() === '')? $this.val('请搜索...') : null; &#125;); 部分页面加载更新 为了提高web性能，有更新时我们通常不会加载整个页面，而只是仅仅更新部分页面内容，如图片的延迟加载等。页面部分刷新的特效在JQuery中也很容易实现 1234setInterval(function() &#123; //每隔5秒钟刷新页面内容 //获取的内容将增加到 id为content的元素后 $(\"#content\").load(url); &#125;, 5000); 采配置JQuery与其它库的兼容性 如果在项目中使用JQuery，$ 是最常用的变量名，但JQuery并不是唯一一个使用$作为变量名的库，为了避免命名冲突，你可以按照下面方式来组织你的代码 12345678//方法一： 为JQuery重新命名为 $jvar $j = jQuery.noConflict();$j('#id').... //方法二： 推荐使用的方式(function($)&#123; $(document).ready(function()&#123; //这儿，你可以正常的使用JQuery语法 &#125;);&#125;)(jQuery); 测试密码的强度 在某些网站注册时常常会要求设置密码，网站也会根据输入密码的字符特点给出相应的提示，如密码过短、强度差、强度中等、强度强等。这又是怎么实现的呢？看下面代码： 1&lt;input type=\"password\" name=\"pass\" id=\"pass\" /&gt; &lt;span id=\"passstrength\"&gt;&lt;/span&gt; 1234567891011121314151617181920212223242526//下面的正则表达式建议各位收藏哦，项目上有可能会用得着$('#pass').keyup(function(e) &#123; //密码为八位及以上并且字母数字特殊字符三项都包括 var strongRegex = new RegExp(\"^(?=.&#123;8,&#125;)(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*\\\\W).*$\", \"g\"); //密码为七位及以上并且字母、数字、特殊字符三项中有两项，强度是中等 var mediumRegex = new RegExp(\"^(?=.&#123;7,&#125;)(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9]))).*$\", \"g\"); var enoughRegex = new RegExp(\"(?=.&#123;6,&#125;).*\", \"g\"); if (false == enoughRegex.test($(this).val())) &#123; $('#passstrength').html('More Characters'); &#125; else if (strongRegex.test($(this).val())) &#123; $('#passstrength').className = 'ok'; $('#passstrength').html('Strong!'); &#125; else if (mediumRegex.test($(this).val())) &#123; $('#passstrength').className = 'alert'; $('#passstrength').html('Medium!'); &#125; else &#123; $('#passstrength').className = 'error'; $('#passstrength').html('Weak!'); &#125; return true;&#125;); 附录四 常见CND加速服务 Bootstrap中文网开源项目免费 CDN 服务 百度静态资源公共库 360网站卫士常用前端公共库CDN服务–已停止服务 开放静态文件 CDN 微软CDN服务 阿里云 百度开放云平台 jQuery CDN jQuery cdn加速 新浪CDN 附录五 jQuery的一些资源 速查手册 jQuery API 中文文档–css88 jQuery-overapi 在线桌面版API 更多详情—一份实用的API参考手册集合 jQuery插件 基础常用 滚动固定在某个位置 jQuery图片滚动插件全能版 jQuery Wookmark Load 瀑布流布局 jQuery Jcrop 图像裁剪 jQuery kxbdMarquee 无缝滚动 jQuery lightBox 灯箱效果 Lazy Load Plugin for jQuery 更多插件-动效库整理 插件动效库 常用组件 扩展阅读 jQuery源码分析系列 参考 锋利的jQuery","categories":[{"name":"jqeury","slug":"jqeury","permalink":"http://yoursite.com/categories/jqeury/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"jqeury","slug":"jqeury","permalink":"http://yoursite.com/tags/jqeury/"}]},{"title":"html5のcss3","slug":"html5のcss3","date":"2020-03-07T02:41:12.000Z","updated":"2020-04-06T11:09:02.135Z","comments":true,"path":"2020/03/07/html5のcss3/","link":"","permalink":"http://yoursite.com/2020/03/07/html5%E3%81%AEcss3/","excerpt":"(╯-_-)╯~╩╩","text":"(╯-_-)╯~╩╩ 第一课 HTML5结构 HTML5 是新一代的 HTML DTD声明改变 &lt;!DOCTYPE html&gt; 新的结构标签 常用的一些新的结构标签 补充说明 small 这个元素表示边栏评论，如附属细则 cite这个元素可用于显示作品标题（图书、电影、诗歌等） adress这个元素显示article或整个文档的合同信息，且位于footer这个元素之中 time显示人和机器可读的日期和时间，而且机器可读的时间戳是属性datetime的值第二个可选的是pubtime用于表示出版日期值 删除的HTML标签 纯表现的元素： basefont big center font s strike tt u 对可用性产生负面影响的元素： frame frameset noframes 产生混淆的元素： acronym applet isindex dir 重新定义的HTML标签 &lt;b&gt; 代表内联文本，通常是粗体，没有传递表示重要的意思 &lt;i&gt; 代表内联文本，通常是斜体，没有传递表示重要的意思 &lt;dd&gt; 可以同details与figure一同使用，定义包含文本，ialog也可用 &lt;dt&gt; 可以同details与figure一同使用，汇总细节，dialog也可用 &lt;hr&gt;表示主题结束，而不是水平线，虽然显示相同 &lt;menu&gt; 重新定义用户界面的菜单，配合commond或者menuitem使用 &lt;small&gt; 表示小字体，例如打印注释或者法律条款 &lt;strong&gt; 表示重要性而不是强调符号 崭新新的页面布局 第二课 HTML5智能表单 HTML4.01 form表单复习 input表单type属性值 type=&quot;text&quot; 单行文本输入框 type=&quot;password&quot; 密码（maxlength=&quot;&quot;） type=&quot;radio&quot; 单项选择（checked=&quot;checked&quot;） type=&quot;checkbox&quot; 多项选择 type=&quot;button&quot; 按钮 type=&quot;submit&quot; 提交 type=&quot;file&quot; 上传文件 type=&quot;reset&quot; 重置 HTML5智能表单 input表单type属性值： type = &quot;email&quot; 限制用户输入必须为Email类型 type=&quot;url&quot; 限制用户输入必须为URL类型 type=&quot;date&quot; 限制用户输入必须为日期类型 type=&quot;datetime&quot; 显示完整日期 含时区 type=&quot;datetime-local&quot; 显示完整日期 不含时区 type=&quot;time&quot; 限制用户输入必须为时间类型 type=&quot;month&quot; 限制用户输入必须为月类型 type=&quot;week&quot; 限制用户输入必须为周类型 type=&quot;number&quot; 限制用户输入必须为数字类型 type=&quot;range&quot; 生成一个滑动条 type=&quot;search&quot; 具有搜索意义的表单results=&quot;n&quot;属性 type=&quot;color&quot; 生成一个颜色选择表单 type=&quot;tel&quot; 显示电话号码 Input 类型 - Date Pickers（日期选择器） **HTML5 拥有多个可供选取日期和时间的新输入类型： date 选取日、月、年 month 选取月、年 week 选取周和年 time 选取时间（小时和分钟） 以下两个没有作用 datetime 选取时间、日、月、年（UTC 时间） datetime-local 选取时间、日、月、年（本地时间） HTML5新增表单属性 required: required内容不能为空 placeholder: 表单提示信息 autofocus:自动聚焦 pattern: 正则表达式 输入的内容必须匹配到指定正则范围 autocomplete:是否保存用户输入值 默认为on，关闭提示选择off formaction: 在submit里定义提交地址 datalist: 输入框选择列表配合list使用 list值为datalist的id值 output: 计算或脚本输出 表单验证 validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都返回true,一种验证失败返回false oText.addEventListener(&quot;invalid&quot;,fn1,false) ev.preventDefault(): 阻止默认事件 valueMissing: 当输入值为空的时候，返回true typeMismatch: 控件值与预期不吻合，返回true patternMismatch: 输入值不满足pattern正则，返回true cusomError setCustomValidity() 第三课 css3选择器 CSS3发展史简介 HTML的诞生 20世纪90年代初 1996年底， CSS第一版诞生 1998年5月 CSS2正式发布 2004年 CSS2.1发布 CSS3的发布 2002 2003 2004 2005 2007 2009 2010 模块化开发 CSS1 中定义了网页的基本属性： 字体、颜色、基本选择器等 CSS2中在CSS1的基础上添加了高级功能 浮动和定位、高级选择器等(子选择器、相邻选择器、通用选择器) CSS3遵循的是模块化开发。发布时间并不是一个时间点，而是一个时间段 CSS选择器复习 通用选择器：* 选择到所有的元素 选择子元素：&gt; 选择到元素的直接后代 相邻兄弟选择器：+选择到紧随目标元素后的第一个元素 普通兄弟选择器：~选择到紧随其后的所有兄弟元素 伪元素选择器： ::first-line 匹配文本块的首行 ::first-letter 选择文本块的首字母 伪类选择器： :before,:after在元素内容前面、后面添加内容(相当于行内元素) CSS3结构选择器 Css3 属性选择器 CSS3伪类选择器 UI伪类选择器： :enabled选择启用状态元素 :disabled 选择禁用状态元素 :checked选择被选中的input元素（单选按钮或复选框） :default 选择默认元素 :valid、invalid 根据输入验证选择有效或无效的input元素 :in-range、out-of-range选择指定范围之内或者之外受限的元素 :required、optional根据是否允许:required属性选择input元素 动态伪类选择器： :link选择链接元素 :visited 选择用户以访问的元素 :hover 鼠标悬停其上的元素 :active鼠标点击时触发的事件 :focus 当前获取焦点的元素 其他伪类选择器： :not(&lt;选择器&gt;)对括号内选择器的选择取反 :lang(&lt;目标语言&gt;) 基于lang全局属性的元素 :target url片段标识符指向的元素 :empty选择内容为空的元素 :selection鼠标光标选择元素内容 第四课 CSS3新增文本属性 CSS文本属性复习 white-space：对象内空格的处理方式 nowrap 控制文本不换行 pre 空白会被浏览器保留 pre-line 合并空白 保留换行符 pre-wrap 保留空白 正常换行 direction：文本流的方向 ltr 文本从左向右 rtl 文本从右往左 unicode-bidi：用于同一个页面里存在从不同方向读进的文本显示。与direction属性一起使用 CSS3新增文本属性 color:rgba(); text-overflow:是否使用一个省略标记（…）标示对象内文本的溢出 text-align:文本的对齐方式 text-transform:文字的大小写 text-decoration:文本的装饰线，复合属性 text-shadow:文本阴影 text-fill-color:文字填充颜色 text-stroke:复合属性。设置文字的描边 tab-size:制表符的长度 word-wrap:当前行超过指定容器的边界时是否断开转行 word-break:规定自动换行的处理方法 text-overflow:是否使用一个省略标记（...）标示对象内文本的溢出 clip： 默认值 无省略号 ellipsis：当对象内文本溢出时显示省略标记（...）。 注意：该属性需配合over-flow:hidden属性(超出处理)还有 white-space:nowrap(禁止换行)配合使用，否则无法看到效果 text-align:文本的对齐方式 css1 left:默认值 左对齐 right:右对齐 center:居中 justify： 内容两端对齐。 css3 start:开始边界对齐 end:结束边界对齐 text-transform:文字的大小写 css1 none： 默认值 无转换 capitalize： 将每个单词的第一个字母转换成大写 uppercase： 转换成大写 lowercase： 转换成小写 css3 full-width： 将左右字符设为全角形式。不支持 full-size-kana：将所有小假名字符转换为普通假名。不支持 例如：土耳其语 text-decoration:文本的装饰线，复合属性(只火狐支持) text-decoration-line： 指定文本装饰的种类。相当于CSS1时的text-decoration属性 text-decoration-style ： `指定文本装饰的样式。 text-decoration-color： `指定文本装饰的颜色。 blink： 指定文字的装饰是闪烁。 opera和firefox text-decoration : #F00 double overline CSS3实例 text-shadow:文本阴影 取值：x y blur color,…… x 横向偏移 y 纵向偏移 blur 模糊距离(灰度) color 阴影颜色 text-fill-color:文字填充颜色 text-stroke:复合属性。设置文字的描边 text-stroke-width:文字的描边厚度 text-stroke-color:文字的描边颜色 tab-size:制表符的长度 默认值为8(一个tab键的空格字节长度)，在 pre标签之内才会有显示 word-wrap:当前行超过指定容器的边界时是否断开转行 normal： 默认值 允许内容顶开或溢出指定的容器边界。 break-word： 内容将在边界内换行。如果需要，单词内部允许断行 第五课 CSS3盒模型 CSS盒模型复习 CSS3弹性盒模型 以下6个属性设置在容器上 flex-direction flex-wrap flex-flow justify-content align-items align-content 属性详解 flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content属性定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch; 以下6个属性设置在项目上 order flex-grow flex-shrink flex-basis flex align-self 属性详解 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 拓展阅读 flex布局语法篇 flex布局实例篇 第六课 css3新增背景属性 CSS背景属性复习 background: background-color:背景颜色 background-image:背景图片 background-repeat:背景重复 background-position:背景定位 background-attachment:背景固定(scroll/fixed) CSS3新增背景属性 background-size 背景尺寸 background-size:x y 水平 垂直方向的尺寸，像素/百分比/auto/… background-size:100% 100% background-size:cover 比例放大 background-size:contain 包含（图片不溢出） 多背景 background-image:url(1.jpg),url(2.jpg); background-origin 背景区域定位 border-box： 从border区域开始显示背景。 padding-box： 从padding区域开始显示背景。 content-box： 从content内容区域开始显示背 background-clip 背景绘制区域 border-box： 从border区域向外裁剪背景。 padding-box： 从padding区域向外裁剪背景。 content-box： 从content区域向外裁剪背景。 text:背景填充文本 no-clip： 从border区域向外裁剪背景 颜色渐变 线性渐变：linear-gradient(起点/角度，颜色 位置，…,) 起点：left/top/right/bottom/left top......默认top 角度：逆时针方向 0-360度 颜色 位置：red 50%, blue 100%(红色从50%渐变到100%为蓝色) repeating-linear-gradient 线性渐变重复平铺 IE低版本渐变(滤镜)： filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#ffffff&#39;,endColorstr=&#39;#ff0000&#39;,GradientType=&#39;1&#39;); 径向渐变：radial-gradient(起点(圆心位置), 形状/半径/大小，颜色1，颜色2) 起点：left/top/right/bottom或具体值/百分比 形状：ellipse(椭圆)、circle(正圆) 大小：具体数值或百分比，也可以是关键字（closest-side(最近端), closest-corner最近角), farthest-side(最远端), farthest-corner(最远角), contain(包含) ,cover(覆盖)）; 第七课 css3新增颜色属性 CSS颜色属性复习 color name 颜色英文名称命名 HEX方式 十六进制方式 rgb方式 三原色配色方式 CSS3新增颜色属性 rgba() 名称 颜色 颜色 取值 r red 红色 0-255 g green 绿色 0-255 b blue 蓝色 0-255 a alpha 透明 0-1 HSL模式 HSLA模式 H： Hue(色调)。 0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L： Lightness(亮度)。取值为：0.0% - 100.0% A: alpha 透明度 0~1之间 语法:HSLA(H,S,L,A) HSL色轮 透明颜色：transparent 实例：border实现三角箭头、风车等 透明度： opacity 取值：0-1之间 注：低版本的IE浏览器不兼容,需用IE浏览器的滤镜实现相同效果，filter:alpha(opacity=50) 对于低版本的火狐浏览器需添加内核前缀，-moz-opacity 第八课 CSS3边框系列 圆角-阴影 边框圆角 在CSS2中添加圆角矩形需要技巧。我们必须为每个圆角使用不同的图片 在 CSS3中，创建圆角是非常容易的 在CSS3中，border-radius属性用于创建圆角 border-radius边框圆角写法 border-radius: 2em 1em 4em / 0.5em 3em; 等价于1234border-top-left-radius: 2em 0.5em;border-top-right-radius: 1em 3em;border-bottom-right-radius: 4em 0.5em;border-bottom-left-radius: 1em 3em; box-shadow方框添加阴影 语法：box-shadow:x-shadow y-shadow blur spread color inset; box-shadow的API x-shadow 必需。水平阴影的位置。允许负值。 y-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS颜色值 inset 可选。将外部阴影 (outset) 改为内部阴影 实例：box-shadow:10px 10px 5px 5px #888888; 边框系列-图片 border-image语法 属性 版本 简介 border-image CSS3 设置或检索对象的边框使用图像来填充 border-image-source CSS3 设置或检索对象的边框是否用图像定义样式或图像来源路径 border-image-slice CSS3 设置或检索对象的边框背景图的分割方式 border-image-width CSS3 设置或检索对象的边框厚度 border-image-outset CSS3 设置或检索对象的边框背景图的扩展 border-image-repeat CSS3 设置或检索对象的边框图像的平铺方式 border-image-slice 设置或检索对象的边框背景图的分割方式 border-image-repeat 用于指定边框背景图的重复方式 取值： stretch： 指定用拉伸方式来填充边框背景图。 *默认的 repeat： 指定用平铺方式来填充边框背景图。当图片碰到边界时，如果超过则被截断。 round： 指定用平铺方式来填充边框背景图。图片会根据边框的尺寸动态调整图片的大小 直至正好可以铺满整个边框。写本文档时仅Firefox能看到该效果 第九课 CSS3运动体系 过渡 过渡：给改变添加过程 什么是过渡 过渡效果由哪几部分组成 过渡可以干些什么 transition 过渡属性 transition: property duration timing-function delay; transition-property:过渡属性的名称 none 没有过渡属性 all 所有属性都过渡(默认值) property 具体属性名称(property1,property2…) transition-duration:过渡属性花费的时间 time 秒或毫秒 transition-timing-function:过渡效果速度曲线 time 秒或毫秒 transition-delay:过渡效果延迟时间 transition-timing-function:过渡效果速度曲线 linear:规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease:规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in:规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out :规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out :规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n):在 cubic-bezier 函数中定义自己的值。可能的值是 0至 1 之间的数值。 过渡完成事件 Webkit内核： 1obj.addEventListener('webkitTransitionEnd',function()&#123;&#125;) 标准: 1obj.addEventListener('transitionend',function()&#123;&#125;) 动画 什么是CSS3 动画？ 通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript 动画接口 属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定动画何时开始。 animation-iteration-count 规定动画被播放的次数。 animation-direction 规定动画是否在下一周期逆向地播放。 animation-play-state 规定动画是否正在运行或暂停。 animation-fill-mode 规定对象动画时间之外的状态。 animation-timing-function速度曲线 值 描述 linear 动画从头到尾的速度是相同的。 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 在谷歌浏览器里面需要加上-webkit-IE6,7,8,9不支持css3运动 拓展阅读 CSS3动画简介 CSS3盒模型阴影 box-shadow:inset x y blur spread color inset：投影方式 inset：内投影 outset：外投影 默认(不能设置) x、y：阴影偏移 blur：模糊半径（灰度） spread：扩展阴影半径 先扩展原有形状，再开始画阴影 color CSS3盒模型倒影 box-reflect 倒影 方向 above|below|left|right; 距离 渐变（可选） CSS3其他盒模型 box-sizing 盒模型解析模式 content-box 标准盒模型(和css2一样的计算) width/height=border+padding+content border-box 怪异盒模型width/height与设置的值一样 ，content减小 扩展阅读 学会使用css3的box-sizing布局 第十课 transform 2D转换 Css3平面转换方法 translate() 移动 rotate() 旋转 scale() 缩放 skew() 翻转 matrix() 矩阵 transform: rotate() 旋转函数 (deg) deg 度数 skew(X,Y) 倾斜函数 (deg) skewX() skewY() scale(X,Y) 缩放函数 (正数、负数和小数) scaleX() scaleY() translate(X,Y) 位移函数(px) translateX() translateY() rotate() 旋转方法 用于旋转元素角度 例：rotate(30deg) 把元素顺时针旋转 30 度 translate()位置方法 用于移动元素位置 例：translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。 其实有些类似于我们的相对定位 scale()尺寸方法 方法用于改变元素尺寸 例：scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍 skew() 翻转方法 通过 skew()方法，元素翻转给定的角度 例：transform: skew(30deg,20deg); 把元素围绕 X轴把元素翻转30 度，围绕 Y 轴翻转 20度 第十一课 transform 3D转换 Css3立体转换 transform-style（preserve-3d） 建立3D空间（指定元素的子元素展示的场景是在3D场景还是平面(投影)场景） Perspective 视角（指定观察者与z=0平面的距离，从而让元素及子元素看起来有3D透视位置效果值：集体的带单位数值） Perspective- origin 视角基点 值：取值类似于变换基准 transform-origin：坐标轴基点（变换基准） 值：具体的坐标值/百分比/(left/right/center/top/bottom)默认 center center transform 新增函数 rotateX() rotateY() rotateZ() translateZ() scaleZ() 第十二课 视频音频 视频音频格式的简单介绍 常见的视频格式 视频的组成部分：画面、音频、编码格式 视频编码：H.264、Theora、VP8(google开源) 常见的音频格式 视频编码：ACC、MP3、Vorbis HTML5支持的格式 HTML5能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。 支持的视频格式： Ogg=带有Theora视频编码+Vorbis音频编码的Ogg文件 MEPG4=带有H.264视频编码+AAC音频编码的MPEG4文件 WebM=带有VP8视频编码+Vorbis音频编码的WebM格式 Video的使用 单独用法 &lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 带提示用法 123&lt; video src=\"文件地址\" controls=\"controls\"&gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; 兼容用法 12345&lt; video controls=\"controls\" width=\"300\"&gt; &lt;source src=\"move.ogg\" type=\"video/ogg\" &gt; &lt;source src=\"move.mp4\" type=\"video/mp4\" &gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; Video的常见属性 属性 值 描述 Autoplay Autoplay 视频就绪自动播放 controls controls 向用户显示播放控件 Width Pixels(像素) 设置播放器宽度 Height Pixels(像素) 设置播放器高度 Loop Loop 播放完是否继续播放该视频，循环播放 Preload load{auto,meta,none} 规定是否预加载视频。 Src url 视频url地址 Poster Imgurl 加载等待的画面图片 Autobuffer Autobuffer 设置为浏览器缓冲方式，不设置autoply才有效 Video的API方法 方法 属性 事件 play() currentSrc play pause() currentTime pause load() videoWidth progress canPlayType() videoHeight error 第十三课 canvas 标签 &lt;canvas&gt; 不支持canvas 的浏览器可以看到的内容 默认宽度300px，默认高度150px 注意：canvas宽高需要设置在标签中 否则绘制的东西可能出错 &lt;canvas&gt; 绘制环境 getContext(&quot;2d&quot;);目前支持2d的场景 123&lt;canvas width=\"\" height=\"\" id=\"\"&gt; 您的浏览器不支持canvas，请更换浏览器！&lt;/canvas&gt; 绘制矩形 rect(L,T,W,H):创建一个矩形 fillRect(L,T,W,H):绘制填充的矩形 clearRect(x,y,w,h) 清除矩形选区 strokeRect(L,T,W,H)绘制空心矩形(无填充) 默认一像素黑色边框 设置绘图样式 fillStyle:填充颜色(绘制canvas是有顺序的) lineWidth:触笔宽度(线宽) strokeStyle:触笔颜色 绘制路径 beginPath() :开始路径 closePath():结束路径 moveTo(x,y):将触笔移动到x,y点 lineTo(x,y):绘制到x,y点 stroke(): 触笔方法 画线 默认为黑色 fill():填充方法 rect(x,y,w,h):矩形路径 save():保存路径 restore():恢复路径 绘制曲线 arcTo(x1,y1,x2,y2,r) x1,y1 坐标一 x2,y2坐标二 r圆弧半斤 quadraticCurveTo(dx,dy,x1,y1) 贝塞尔曲线:dx,dy控制点 x1,y1结束坐标 bezierCurveTo(dx1,dy1,dx2,dy2,x1,y1) 贝塞尔曲线:dx1,dy1 控制点一 dx2,dy2控制点二 x1,y1结束坐标 绘制圆形 arc(x,y,半径,起始弧度,结束弧度,旋转方向) x，y起始位置 弧度与角度：弧度=角度值*Math.PI/180 旋转方向：顺时针（默认：false），逆时针（true） 绘制文本 strokeText(文本,x,y); 绘制空心文本 fillText(文本,x,y); 绘制实心文本 font = &quot;font-size font-family&quot;注:尺寸 字体缺一不可 textAlign = &quot;&quot;;文本左右对齐方式 start center end left right textBaseline文本上下对齐方式 alphabetic默认。文本基线是普通的字母基线。 top 文本基线是 em 方框的顶端。。 hanging 文本基线是悬挂基线。 middle 文本基线是em 方框的正中。 ideographic 文本基线是表意基线。 bottom 文本基线是 em 方框的底端。 measureText(文本).width; 文本实际宽度(只有宽度值) 图形边界样式 lineJoin: 边界连接点样式 miter(默认值),round(圆角),bevel(斜角) lineCap: 端点样式 butt(默认值),round(圆角),square(高度多出线宽一半) 绘制图片 图片预加载，获取图片文件 onload中调用 drawImage(img,x,y,w,h);绘制图片(图片,坐标x,坐标y,宽度,高度) 设置背景 createPattern(img,平铺方式) 平铺方式:repeat,repeat-x,repeat-y,no-repeat canvas变换 translate(x,y) 坐标基准点偏移 : 从起始点为基准，移动到当前位置 rotate(弧度): 旋转 弧度公式 = 角度*PI/180 scale(wb,hb)缩放比例(缩放canvas绘制的图片) 颜色渐变 线性渐变:createLinearGradient(x1,y1,x2,y2) x1,y1起始坐标点 x2,y2结束坐标点 径向渐变:createRadialGradient(x1,y1,r1,x2,y2,r2) x1,y1,r1内圆坐标及半径 x2,y2,r2外圆坐标及半径 addColorStop(位置,颜色) 位置:渐变点 0-1之间 可多个 阴影 shadowOffsetX,shadowOffsetY x轴、y轴偏移 shadowBlur 阴影模糊度 shadowColor 阴影颜色 默认颜色:rgba(0,0,0,0) 像素 createImageData(sx,sy) 创建新的、空白的 ImageData 对象 getImageData(x1,y1,sx,sy) 返回ImageData对象，该对象为画布上指定的矩形复制像素数据putImageData(img,x2,y2) 把图像数据（从指定的 ImageData 对象）放回画布上 合成 globalAlpha 设置或返回绘图的当前alpha或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 source-over默认。在目标图像上显示源图像。 source-atop在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 source-out在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 destination-over在源图像上方显示目标图像。 destination-atop在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 destination-in在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 destination-out在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 lighter显示源图像 + 目标图像。 copy显示源图像。忽略目标图像。 xor使用异或操作对源图像与目标图像进行组合。 扩展阅读 canvas学习之API整理笔记（一） HTML5 API大盘点 第十四课 SVG绘图 svg是什么 矢量图 与canvas的区别 svg的引入方式 方式一： 12345&lt;?xml version=\"1.1\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;/svg&gt; 方式二： 图片、背景、框架 方式三: html页面中添加svg circle:圆形 圆心坐标 cx,cy 半径 r fill stroke stroke-width stlye样式 fill = &quot;none/transparent&quot; ellipse:椭圆 cx属性定义的椭圆中心的x坐标 cy属性定义的椭圆中心的y坐标 rx属性定义的水平半径 ry属性定义的垂直半径 rect : 矩形 width height 宽高 坐标 x,y 圆角 rx,ry line:线条 x1,y1,x2,y2 stroke-opacity 透明 fill-opacity polyline:折线 points:点坐标（x1 y1 x2 y2...）或(x1,y1,x2,y2....) polygon:多边形 折线闭合 fill-rule:evenodd/nonzero; path: 路劲 d属性 M(起始坐标),L(结束坐标),H(水平线),V(垂直线),A(圆弧),Z(闭合路劲) C,S,Q,T 贝塞尔曲线 大写为绝对坐标(具体的坐标位置) 小写为相对坐标(相对起始坐标点的具体长度) A命令 x半径 y半径 角度 弧长(0 小弧 1大弧) 方向(0逆时针 1顺时针) 终点(x y) C命令：三次贝塞尔曲线 (x1,y1,x2,y2,x,y) x1,y1控制点一 x2,y2控制点二 x,y结束点 S命令：平滑贝塞尔曲线(自动对称一个控制点) (x2,y2,x,y) x2,y2控制点 x,y结束点 Q命令：二次贝塞尔曲线 (x1,y1,x,y) x1,y1控制点 x,y结束点 T命令：一次贝塞尔曲线 (x,y)结束点 g标签:组合元素 设置元素公共属性 共用属性 transform = &quot;translate(0,0)&quot; text标签 x, y, text-anchor(对齐start end middle) font-size image 标签 x, y, width height xlink:href(图片地址) 第十五课 地理信息与本地存储 地理位置 经度 : 南北极的连接线 纬度 : 东西连接的线 位置信息从何而来 IP地址 GPS全球定位系统 Wi-Fi无线网络 基站 avigator.geolocation 单次定位请求 ：getCurrentPosition(请求成功,请求失败,数据收集方式) 请求成功函数 经度 : coords.longitude 纬度 : coords.latitude 准确度 : coords.accuracy 海拔 : coords.altitude 海拔准确度 : coords.altitudeAcuracy 行进方向 : coords.heading 地面速度 : coords.speed 请求的时间: new Date(position.timestamp) 请求失败函数 失败编号 ：code 0 : 不包括其他错误编号中的错误 1 : 用户拒绝浏览器获取位置信息 2 : 尝试获取用户信息，但失败了 3 : 设置了timeout值，获取位置超时了 数据收集 : json的形式 enableHighAcuracy : 更精确的查找，默认false timeout : 获取位置允许最长时间，默认infinity maximumAge : 位置可以缓存的最大时间，默认0 多次定位请求* : watchPosition 移动设备有用，位置改变才会触发 配置参数：frequency 更新的频率 关闭更新请求 : clearWatch examp01 getCurrentPosition 12&lt;button id=\"btn\"&gt;请求位置信息&lt;/button&gt;&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567891011121314151617181920var btn = document.getElementById(\"btn\");var box = document.getElementById(\"box\"); btn.onclick = function()&#123; navigator.geolocation.getCurrentPosition(function(position)&#123; box.innerHTML +=\"经度：\"+position.coords.longitude + \"&lt;br&gt;\"; box.innerHTML +=\"纬度：\"+position.coords.latitude + \"&lt;br&gt;\"; box.innerHTML +=\"海拔：\"+position.coords.accuracy + \"&lt;br&gt;\"; box.innerHTML +=\"海拔的准确度：\"+position.coords.altitudeAccuracy + \"&lt;br&gt;\"; box.innerHTML +=\"地面速度\"+position.coords.speed + \"&lt;br&gt;\"; box.innerHTML +=\"行进方向\"+position.coords.heading + \"&lt;br&gt;\"; box.innerHTML +=\"请求时间\"+new Date(position.timestamp) + \"&lt;br&gt;\"; &#125;,function(err)&#123; alert(err.code); &#125;,&#123; enableHighAccuracy:false,//精确请求 timeout:5000,//设置超时 maximumAge:1000//缓存时间 &#125;); &#125; 在线演示 *examp02 * 1234567891011121314151617181920var btn = document.getElementById(\"btn\");var box = document.getElementById(\"box\"); btn.onclick = function()&#123; navigator.geolocation.watchPosition(function(position)&#123; box.innerHTML +=\"经度：\"+position.coords.longitude + \"&lt;br&gt;\"; box.innerHTML +=\"纬度：\"+position.coords.latitude + \"&lt;br&gt;\"; box.innerHTML +=\"海拔：\"+position.coords.accuracy + \"&lt;br&gt;\"; box.innerHTML +=\"海拔的准确度：\"+position.coords.altitudeAccuracy + \"&lt;br&gt;\"; box.innerHTML +=\"地面速度\"+position.coords.speed + \"&lt;br&gt;\"; box.innerHTML +=\"行进方向\"+position.coords.heading + \"&lt;br&gt;\"; box.innerHTML +=\"请求时间\"+new Date(position.timestamp) + \"&lt;br&gt;\"; &#125;,function(err)&#123; alert(err.code); &#125;,&#123; enableHighAccuracy:false,//精确请求 timeout:5000,//设置超时 maximumAge:1000//缓存时间 &#125;); &#125; 在线演示 example03 高德地图应用 123456#container &#123; width:600px; height: 300px; margin:40px auto; border:1px solid red;&#125; 1234&lt;div id=\"container\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\" src=\"http://webapi.amap.com/maps?v=1.3&amp;key=278b7b8b4728ba302b7e566fc2a97b36\"&gt;&lt;/script&gt; 1var map = new AMap.Map('container'); 在线演示 examp04 搜索城市 1234567891011121314151617181920212223242526272829303132#container &#123;width:500px; height:500px; margin:100px auto;&#125; .menu&#123; width:100px; box-shadow: 0 0 5px #000; margin:auto; background:#fff;&#125;.menu ul li&#123; list-style:none; line-height:30px; text-align:center; cursor:pointer;&#125;#box&#123; width:400px; height:40px; position:absolute; top:150px; left:50%; margin-left:-200px; background:#fff; box-shadow:0 0 10px #000;&#125;input&#123; height:38px; width:300px; border:none; outline:none;&#125;#btn&#123; width:80px;&#125; 12345678&lt;div id=\"container\"&gt;&lt;/div&gt; &lt;div id=\"box\"&gt; &lt;input type=\"text\" id=\"city\" placeholder=\"请输入城市...\"&gt; &lt;input type=\"button\" value=\"搜索\" id=\"btn\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"http://webapi.amap.com/maps?v=1.3&amp;key=278b7b8b4728ba302b7e566fc2a97b36\"&gt;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var btn = document.getElementById(\"btn\");var city = document.getElementById(\"city\");var map = new AMap.Map('container');var toolBar,mouseTool,contextMenu;//在地图中添加操作toolBar插件、mouseTool插件map.plugin([\"AMap.ToolBar\",\"AMap.MouseTool\"],function()&#123; toolBar = new AMap.ToolBar(); map.addControl(toolBar); mouseTool = new AMap.MouseTool(map);&#125;);var menuContext = document.createElement(\"div\");menuContext.innerHTML = \"&lt;div class=menu&gt;&lt;ul&gt;&lt;li onclick='zoomMenu(0)'&gt;缩小&lt;/li&gt;&lt;li onclick='zoomMenu(1)'&gt;放大&lt;/li&gt;&lt;li onclick='distanceMeasureMenu()'&gt;距离量测&lt;/li&gt;&lt;li onclick = 'addMarkerMenu()'&gt;添加标记&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;\";//创建一个自定义的右键菜单contextMenu = new AMap.ContextMenu(&#123;isCustom:true,content:menuContext&#125;);//给地图绑鼠标右键功能弹出右键菜单AMap.event.addListener(map,\"rightclick\",function(e)&#123; contextMenu.open(map,e.lnglat);//e.lnglat鼠标点击的经纬度 contextMenuPosition = e.lnglat;&#125;)//右键菜单缩放地图function zoomMenu(n)&#123; if(n === 0)&#123;map.zoomOut();&#125; if(n === 1)&#123;map.zoomIn();&#125; contextMenu.close();&#125;contextMenu.close();//测量距离功能function distanceMeasureMenu()&#123; mouseTool.rule(); contextMenu.close();&#125;//添加标注功能function addMarkerMenu()&#123; mouseTool.close(); var marker = new AMap.Marker(&#123; map: map, position: contextMenuPosition, //基点位置 offset: &#123;x:-5,y:-10&#125; //相对于基点位置 &#125;); contextMenu.close();&#125;//搜索城市btn.onclick = function()&#123; var val = city.value; map.setCity(val);&#125; 在线演示 本地存储 Storage sessionStorage session临时回话，从页面打开到页面关闭的时间段 窗口的临时存储，页面关闭，本地存储消失 localStorage 永久存储（可以手动删除数据） Storage的特点 存储量限制 ( 5M ) 客户端完成，不会请求服务器处理 sessionStorage数据是不共享、 localStorage共享 Storage API setItem(): 设置数据，(key,value)类型，类型都是字符串 可以用获取属性的形式操作 getItem(): 获取数据，通过key来获取到相应的value removeItem(): 删除数据，通过key来删除相应的value clear(): 删除全部存储的值 存储事件: 当数据有修改或删除的情况下，就会触发storage事件 在对数据进行改变的窗口对象上是不会触发的` Key : 修改或删除的key值，如果调用clear(),key为null newValue : 新设置的值，如果调用removeStorage(),key为null oldValue : 调用改变前的value值 storageArea : 当前的storage对象 url : 触发该脚本变化的文档的url 注：session同窗口才可以,例子：iframe操作 第十六课 HTML5新增JS方法 新增选择器 document.querySelector() 选择单个元素 document.querySelectorAll() 选择所有的 document.getElementsByClassName() 通过类名选择 延迟加载JS JS的加载会影响后面的内容加载 很多浏览器都采用了并行加载JS，但还是会影响其他内容 Html5的defer和async defer=“defer ”: 延迟加载，会按顺序执行，在onload执行前被触发 async =“async”: 异步加载，加载完就触发，有顺序问题 浏览器兼容性：Labjs库 123456789101112131415161718192021222324252627282930/*** 动态加载script文件 （推荐方法） 只需请求一次 可加载多个JavaScript文件，减少请求次数以及页面的加载阻塞*/function loadScript(url,callback)&#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; if(script.readyState)&#123;//IE script.onreadystatechange = function()&#123; if(script.readyState == \"loaded\" || script.readyState == \"complete\")&#123; onreadystatechange = null; callback(); &#125; &#125; &#125;else &#123; script.onload = function()&#123; callback(); &#125; &#125; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125;loadScript(\"js/defer.js\",function()&#123; console.log(\"加载成功\"); // 加载成功回调&#125;);loadScript(\"js/async.js\",function()&#123; console.log(\"加载成功\"); // 加载成功回调&#125;); 获取class列表属性 classList length : class的长度 add() : 添加class方法 remove() : 删除class方法 toggle() : 切换class方法 contains() : 判断类名是否存在返回bool值 JSON的新方法 parse() : 把字符串转成json 字符串中的属性要严格的加上引号 stringify() : 把json转化成字符串 会自动的把双引号加上 与eval的区别 eval()：对任何的字符串进行解析变成js parse()：字符串中的属性要严格的加上引号 其他浏览器兼容 去下载json2.js 历史管理 onhashchange ：改变hash值来管理 history ： 服务器下运行 pushState : 三个参数 ：数据 标题(都没实现) 地址(可选) onpopstate事件 : 读取数据 event.state 第十七课 HTML5拖拽事件 图片自带拖拽功能 其他元素可设置draggable属性 draggable ：true 拖拽元素(被拖拽元素对象)事件 : ondragstart : 拖拽前触发 ondrag :拖拽前、拖拽结束之间，连续触发 ondragend :拖拽结束触发 目标元素(拖拽元素被拖到的对象)事件 : ondragenter :进入目标元素触发 ondragover:进入目标、离开目标之间，连续触发 ondragleave :离开目标元素触发 ondrop :在目标元素上释放鼠标触发 需要在ondragover事件里面阻止默认事件 拖拽兼容问题 火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 dataTransfer对象 setData() : 设置数据 key和value(必须是字符串) getData() : 获取数据，根据key值，获取对应的value effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) setDragImage ：三个参数（指定的元素，坐标X，坐标Y） files： 获取外部拖拽的文件，返回一个filesList列表 filesList下有个type属性，返回文件的类型 读取文件信息 FileReader(读取文件信息) readAsDataURL 参数为要读取的文件对象 onload当读取文件成功完成的时候触发此事件 this. result 获取读取的文件数据 examp01 拖拽案例 12&lt;div id=\"drap\" draggable=\"true\"&gt;&lt;/div&gt;&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567891011#drap &#123; width: 100px; height: 100px; background: red;&#125;#box &#123; width: 500px; height: 500px; border: 2px solid blue; margin: 50px auto;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//被拖拽元素事件drap.ondragstart = function(ev)&#123; // 拖拽前 var ev = ev || window.event; //火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 ev.dataTransfer.setData(\"key\",\"poetries\"); //effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) ev.dataTransfer.effectAllowed = \"copy\"; //设置被拖拽的小元素 setDragImage ：三个参数（指定的元素，坐标X，坐标Y） ev.dataTransfer.setDragImage(pic,25,25); this.style.background = \"green\";&#125;drap.ondrag = function()&#123; // 拖拽过程中 this.innerText = \"被拖拽中...\";&#125;drap.ondragend = function()&#123; // 拖拽结束 this.style.background = \"red\"; this.innerHTML = \"\";&#125;//目标元素事件box.ondragenter = function()&#123; //进入目标元素触发 this.innerHTML = \"可将文件拖放到这里!\";&#125;box.ondragover = function(ev)&#123; //进入目标、离开目标之间，连续触发 var ev = ev || window.event; ev.preventDefault(); this.style.background = \"pink\";&#125;box.ondragleave = function()&#123; //离开目标元素触发 this.innerHTML = \"\"; this.style.background = \"none\";&#125;box.ondrop = function(ev)&#123;//在目标元素上释放鼠标触发 //alert(\"拖放结束\") this.innerHTML = ev.dataTransfer.getData(\"key\");&#125; 在线演示 example02 拖拽相册 123&lt;h1&gt;请拖拽图片到红框中&lt;/h1&gt;&lt;div id=\"box\"&gt;&lt;span&gt;可以将文件拖放到这里！！&lt;/span&gt;&lt;/div&gt;&lt;div id=\"dustbin\"&gt;垃圾回收站&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132#box&#123; position:relative; width:500px; height:500px; border:2px solid red; margin:100px auto 0px; &#125;#box span&#123; position:absolute; left:0; top:0; right:0; bottom:0; height:50px; width:192px; margin:auto; display:none;&#125;img&#123; width:100px;height:100px;&#125;#dustbin&#123; width:200px; height:100px; background:#000; color:#fff; font-size:40px; text-align:center; line-height:100px; margin:auto;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var box = document.getElementById(\"box\");var dusTbin = document.getElementById(\"dustbin\");var span = box.getElementsByTagName(\"span\")[0];//目标元素事件var img = '';box.ondragenter = function()&#123;//进入目标元素触发 span.style.display = \"block\";&#125;box.ondragover = function(ev)&#123;//在目标元素上连续触发 var ev = ev||window.event; ev.preventDefault();//阻止默认事件 span.style.display = \"block\";&#125;box.ondragleave = function()&#123;//离开目标元素 span.style.display = \"none\";&#125;box.ondrop = function(ev)&#123;//在目标元素上面释放鼠标触发 //alert(\"拖拽结束！！\"); var ev = ev||window.event; ev.preventDefault();//阻止默认事件 span.style.display = \"none\"; var file = ev.dataTransfer.files; //alert(file[0].type); for (var i=0; i&lt;file.length ;i++ ) &#123; if (file[i].type.indexOf(\"image\")!=-1) &#123; var read = new FileReader();//新建一个读取文件对象 read.readAsDataURL(file[i]);//读取文件 read.onload = function()&#123;//读取文件成功之后调用什么函数 var img = document.createElement(\"img\"); //alert(this.result); img.src = this.result; box.appendChild(img); //获取img节点 实现删除功能 var oImg = document.getElementsByTagName(\"img\"); if (oImg) &#123; for (var j=0;j&lt;oImg.length ;j++ ) &#123; oImg[j].ondragstart = function(ev)&#123; ev.dataTransfer.setData(\"data\",ev.target.innerHTML); img = ev.target; &#125; oImg[j].ondragend = function(ev)&#123; ev.dataTransfer.clearData(\"data\");//清楚数据 img = null; &#125; &#125; &#125; //实现删除功能(移除img节点) dusTbin.ondragover = function(ev)&#123; ev.preventDefault(); &#125; dusTbin.ondrop = function()&#123; if (img) &#123; img.parentNode.removeChild(img); &#125; &#125; &#125; &#125;else&#123; alert(\"请上传图片！\"); &#125; &#125; &#125; 在线演示 example03 拖拽排序 123456789101112&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;ul id=\"box\"&gt; &lt;li style=\"background:#f3f\" draggable=\"true\"&gt;1&lt;/li&gt; &lt;li style=\"background:#ff6\" draggable=\"true\"&gt;2&lt;/li&gt; &lt;li style=\"background:#c60\" draggable=\"true\"&gt;3&lt;/li&gt; &lt;li style=\"background:#903\" draggable=\"true\"&gt;4&lt;/li&gt; &lt;li style=\"background:#0f6\" draggable=\"true\"&gt;5&lt;/li&gt; &lt;li style=\"background:#636\" draggable=\"true\"&gt;6&lt;/li&gt; &lt;li style=\"background:#36f\" draggable=\"true\"&gt;7&lt;/li&gt; &lt;li style=\"background:#033\" draggable=\"true\"&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415.wrap&#123; width:500px; height:500px; margin:50px auto;&#125;ul li&#123; list-style:none; width:500px; height:50px; color:#fff; text-align:center; line-height:50px; font-size:40px; font-weight:bold;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344var oUl = document.getElementById(\"box\");var oLi = oUl.getElementsByTagName(\"li\");var curr = 0;function sort()&#123; for (var i = 0;i &lt; oLi.length;i++) &#123; oLi[i].index = i; oLi[i].ondragstart = function(ev)&#123; var ev = ev || window.event; ev.dataTransfer.setData(\"data\",this.innerHTML); //this.innerHTML = \"被拖拽中...\"; curr = this.index; &#125; oLi[i].ondragenter = function()&#123; for(var i = 0;i &lt; oLi.length;i++)&#123; oLi[i].style.border = \"none\"; &#125; if(curr != this.index)&#123; this.style.border = \"2px solid #000\"; &#125; &#125; oLi[i].ondragover = function(e)&#123; var e = e || window.event; e.preventDefault(); &#125; oLi[i].ondrop = function(ev)&#123; //鼠标释放的时候 //oUl.insertBefore(oLi[curr],this);//insertBefore(新节点，目标节点) inserAfter(oLi[curr],this); this.style.border = \"none\"; //oLi[curr].innerHTML = ev.DataTransfer.getData(\"data\"); sort(); &#125; &#125;&#125;sort();function inserAfter(newItem,targerItem)&#123; var parentItem = targerItem.parentNode; if(parentItem.lastChild == targerItem)&#123; parentItem.appendChild(newItem); &#125;else &#123; parentItem.insertBefore(newItem,targerItem.nextSibling); &#125;&#125; 在线演示 第十八课 跨文档操作 跨文档请求 同域跨文档 iframe内页： 父页面操作子页面：contentWindow 子页面操作父页面：window.top(找到最顶级的父页面)/parent(第一父页面) 新窗口页： 父页面操作子页面：window.open 子页面操作父页面：window.opener 不同域跨文档 postMessage（“发送的数据”,”接收的域”） message事件监听 ev.origin发送数据来源的域 ev.data 发送的数据 通过判断发送的数据来执行相应的需求 ajax跨域 XMLHttpRequest 新增功能 跨域请求：修改服务端头信息 IE兼容：XDomaiRequest 进度事件： upload.onprogress(ev) 上传进度(实现文件上传进度条) ev.total 发送文件的总量 ev.loaded 已发送的量 FormData 构建提交二进制数据 拓展阅读 HTML5 API 大盘点 附录一 css3响应式布局 媒体类型 *all 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 *print 手持设备 projection 打印预览 *screen 彩屏设备 speech ‘听觉’类似的媒体类型 tty不适用像素的设备 tv 电视 关键字 and not not关键字是用来排除某种制定的媒体类型 only only用来定某种特定的媒体类型 媒体特性 (max-width:600px) (max-device-width: 480px) 设备输出宽度 (orientation:portrait) 竖屏 (orientation:landscape) 横屏 (-webkit-min-device-pixel-ratio: 2) 像素比 devicePixelRatio 设备像素比 window.devicePixelRatio = 物理像素 / dips 样式引入 1&lt;link rel=\"stylesheet\" href=\"css/index.css\" media=\"print\" /&gt; 12@import url(\"css/demo.css\") screen;@media screen&#123; &#125; 12&lt;link rel=”stylesheet” media=”all and (orientation:portrait)” href=”portrait.css”&gt; 12&lt;link rel=”stylesheet” media=”all and (orientation:landscape)”href=”landscape.css”&gt; 1@media screen and (min-width:360px) and (max-width:500px) &#123;&#125; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexA.css\" media=\"screen and (min-width: 800px)\"&gt; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexB.css\" media=\"screen and (min-width: 600px) and (max-width: 800px)\"&gt; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexC.css\" media=\"screen and (max-width: 600px)\"&gt; 附录二 HTML5速查表 可以查阅支持H5+CSS3的属性 HTML5 标签含义之元素周期表 HTML5标签速查表 展示 flexbox 属性的作用–推荐 Flexbox 视觉指南–更好更容易地理解 Flexbox 某个属性的作用","categories":[{"name":"html5のcss3","slug":"html5のcss3","permalink":"http://yoursite.com/categories/html5%E3%81%AEcss3/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"hexo的搭建","slug":"hexo","date":"2020-03-06T14:12:59.000Z","updated":"2020-04-06T02:56:57.223Z","comments":true,"path":"2020/03/06/hexo/","link":"","permalink":"http://yoursite.com/2020/03/06/hexo/","excerpt":"关于hexohexo是一个快速、简洁且高效的博客框架,Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统","text":"关于hexohexo是一个快速、简洁且高效的博客框架,Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统 Hexo同时也是GitHub上的开源项目,如果想要更加全面的了解Hexo可以到其官网了解更多的细节。 准备工作 下载Git 下载node.js并安装,默认会安装npm(教程) 查看版本 node -v nmp -v; （注:配置好node.js的环境变量） 下载安装hexo 方法(基于npm/cnpm包的Git命令安装) 输入:nmp install -g hexo（可能会等待很久） 使用安装cnpm淘宝镜像输入npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后输入cnpm install -g hexo-cli 稍等片刻就安装好了 hexo -v 查看版本号 本地搭建hexo静态博客 新建一个文件夹（如blog\\自己定义） 点击文件夹,右击运行Git Bash here,输入hexo init(生成模块)1234567生成完成后，指定文件夹目录下有：node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题** _config.yml: 博客的配置文件** 生成完之后 输入 hexo server 运行程序,就可以访问本地localhost:4000可以看到博客已经搭建完成(如果报错的话,大概就是端口号被占用输入hexo s -p 5000 更改端口号) 主题安装cd 主题目录下 下载主题(以next主题为例)(注:可以去 输入 git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开站点下的_config.yml配置文件 1234# Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: next(更改为自己下载的主题名字) next主题的使用 安装好主题后主题文件夹里面会有一个主题配置_config配置文件 进入_config后找到Schemes里面会有4不同类型的主题样式(依个人爱好自行选择) 关于hexo-next主题下的一些个性化配置，请参考:(Next主题配置)[] 补注hexo g hexo s （本地查看)localhost:4000 hexo g(生成文件)hexo d 推到远端github中hexo clean 清除缓存","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"}],"author":{"nick":"Anew","link":"https://www.github.com/quieta"}},{"title":"next主题配置以及如何部署到github上","slug":"next","date":"2020-03-06T14:12:59.000Z","updated":"2020-04-06T03:52:50.653Z","comments":true,"path":"2020/03/06/next/","link":"","permalink":"http://yoursite.com/2020/03/06/next/","excerpt":"next主题配置","text":"next主题配置 通过修改next主题下的_config.yml的scheme字段，配置不同的风格。 12345# Schemesscheme: Muse# scheme: Mist# scheme: Pisces# scheme: Gemini 菜单设置通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。 1234567menu: home: &#x2F; categories: &#x2F;categories about: &#x2F;about archives: &#x2F;archives tags: &#x2F;tags #commonweal: &#x2F;404.html 其中，home代表主页，categories代表分类页，about代表关于页面，archives代表归档页，commonweal代表404页面（page not found时候显示的页面）。 页面汉化next主题下的language文件夹下的文件进行修改，若当前语言是简体中文，直接修改language/zh-Hans.yml里的对应字段即可。 头像设置在主题下的source/images/下放置头像文件avatar.png即可。 侧栏设置侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等 12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left &#x2F;&#x2F;靠左放置 #position: right &#x2F;&#x2F;靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post &#x2F;&#x2F;默认行为，在文章页面（拥有目录列表）时显示 display: always &#x2F;&#x2F;在所有页面中都显示 #display: hide &#x2F;&#x2F;在所有页面中都隐藏（可以手动展开） #display: remove &#x2F;&#x2F;完全移除 offset: 12 &#x2F;&#x2F;文章间距（只对Pisces | Gemini两种风格有效） b2t: false &#x2F;&#x2F;返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true &#x2F;&#x2F;返回顶部按钮的百分比 设置RSS1、先安装 hexo-generator-feed 插件 npm install hexo-generator-feed --save2、打开 站点配置文件 找到Extensions在下面添加 123456789# RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &#39; &#39; 3、打开 主题配置文件 找到rss,设置为 rss: /atom.xml 添加分类模块の添加标签模块即其他模块1、新建一个分类页面 hexo new page categories2、你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置title: 分类3、打开 主题配置文件 找到menu，将categorcies取消注释4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的类中举个栗子： 12title: 分类文章标题categories: 分类名 1、新建一个标签页面 hexo new page tags2、你会发现你的source文件夹下有了tags/index.md，打开index.md文件将title设置为title: 标签3、打开 主题配置文件 找到menu，将tags取消注释4、把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中举个栗子： 12345title: 标签文章标题tags: - 标签1- 标签2... 其他模块也类似添加关于模块1、新建一个关于页面hexo new page about2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，以随便编辑。3、打开 主题配置文件 找到menu，将about取消注释 添加搜索功能1、安装 hexo-generator-searchdb 插件npm install hexo-generator-searchdb --save2、打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 添加阅读全文按钮因为在你的博客主页的文章会有很多内容，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加&lt;!--more--&gt; 修改作者头像并旋转打开\\themes\\next\\source\\css_common\\components\\sidebar\\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; &#x2F;* 头像圆形 *&#x2F; border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; &#x2F;* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*&#x2F; &#x2F;* 鼠标经过头像旋转360度 *&#x2F; -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; &#x2F;* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*&#x2F; &#x2F;* 鼠标经过头像旋转360度 *&#x2F; -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;&#x2F;* Z 轴旋转动画 *&#x2F;@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 如何自己给博客添加样式打开blog/themes/hexo-theme-next/source/css/_custom/custom.styl可自行修改样式 如果样式应用不上就在样式后面添加 !important即可 将博客与Github关联在github上创建仓库 首先注册一个github账号，注册时填写的username要谨慎 创建一个储存库，名称规则为: 1username.github.io 设置Git的user name和email 12git config --global user.name &quot;quieta&quot;git config --global user.email &quot;&#x3D;434299971@qq.com&quot; 为github 设置ssh keys 检查极其上是否已经存在id_rsa.pub文件 1ls -al ~&#x2F;.ssh 不存在的话使其生成 ssh-keygen -t rsa -C &quot;434299971@163.com一路回车即可。 生成完后会提示路径 找到路径对应位置打开复制id_rsa.pub文件内容，在github的settings中，点选SSH keys，添加一个key，将内容粘贴进去。 测试是否添加成功，在刚刚的机器上输入 1ssh -T git@github.com 配置Deployment 编辑hexo/config.yml文件如下： 1234deploy: type: git repository:https:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;yourname.github.io.git branch: master 安装依赖 1npm install hexo-deployer-git –save 其中repository的地址就是你刚刚创建的仓库的https地址。(注:每个属性值前面记得加空格，不然会报错的) 部署 12hexo g 生成hexo d 部署到github 部署成功后，可通过 http://quieta.github.io 进行访问，其中将quieta替换为你自己的username即可不过访问速度可能会很慢 解决github访问很慢访问很慢的原因:访问很慢的原因: dns解析的问题,即github的CDN域名遭到了DNS污染，导致无法连接使用 github 的加速分发服务器，才使得国内访问速度很慢。解决办法1.修改本地host文件,进行绕过cdn直接解析 查询github的ip地址 ip查询打开之后 查询github.com以及github.global.ssl.fastly.net2.将这两个host添加到本地host文件格式如下 12查询到的ip github.com 查询到的ip github.global.ssl.fastly.net 然后进入 C:\\Windows\\System32\\drivers\\etc\\host 注意使用管理员打开,否则无法保存3.保存之后最好刷新一下本地的dns缓存win + r -&gt;cmd-&gt;ipconfig /flushdns 然后再次尝试访问github,发现这次的打开速度快了很多 ok,问题解决!","categories":[{"name":"next","slug":"next","permalink":"http://yoursite.com/categories/next/"}],"tags":[{"name":"懒","slug":"懒","permalink":"http://yoursite.com/tags/%E6%87%92/"}]},{"title":"htmlのcss笔记","slug":"htmlのcss","date":"2020-02-24T13:56:54.170Z","updated":"2020-04-06T11:08:21.952Z","comments":true,"path":"2020/02/24/htmlのcss/","link":"","permalink":"http://yoursite.com/2020/02/24/html%E3%81%AEcss/","excerpt":"(￣▽￣)”","text":"(￣▽￣)” 第一部分htmlhtml概述 认识HTML： html不是一种编程语言，是一种标志语言 标记语言是由一套标识标签组成的 html使用标签来描述网页 html结构： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"css/main.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 逻辑代码 --&gt; &lt;!-- 逻辑代码底部 --&gt; &lt;script src=\"lib/jquery/jquery-2.1.1.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;head&gt;中添加信息 12345678910&lt;meta name=\"author\" content=\"smile@kang.cool\"&gt;------作者&lt;meta name=\"description\" content=\"hello\"&gt;------网页描述&lt;meta name=\"keywords\" content=\"a,b,c\"&gt;------关键字,“，”分隔&lt;meta http-equiv=\"expires\" content=\"Wed, 26 Feb 1997 08：21：57 GMT\"&gt;------设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt;------禁止浏览器从本地机的缓存中调阅页面内容&lt;meta http-equiv=\"Window-target\" content=\"_top\"&gt;------用来防止别人在框架里调用你的页面&lt;meta http-equiv=\"Refresh\" content=\"5;URL=http://kahn1990.com/\"&gt;------跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=\"robots\" content=\"none\"&gt;------content的参数有all,none,index,noindex,follow,nofollow，默认是all&lt;link rel=\"Shortcut Icon\" href=\"favicon.ico\"&gt;------收藏图标&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache, must-revalidate\"&gt;------网页不会被缓存 不成对出现的标签&lt;br&gt; &lt;hr&gt; &lt;meta&gt; &lt;img&gt; &lt;input..&gt; &lt;option..&gt; &lt;link&gt; 特殊符号： &amp;nbsp; —-&gt;空格 &amp;gt; —&gt;大于号 &amp;lt；—&lt;小于号 &amp;quot；—&gt;引号 &amp;copy;–&gt;版权号 第一章 html基本标签 &lt;html&gt; &lt;head&gt; &lt;body&gt;标签 &lt;h1&gt;&lt;/h1—-&lt;h6&gt;&lt;/h6&gt;仅仅用于标题文本，不要为了产生粗体文本使用它们 &lt;p&gt;标签 段落标签 &lt;strong&gt;&lt;b&gt;标签 都会让文字产生加粗效果 &lt;strong&gt;用于强调文本，强度更深，表示重要文本—&gt;用于SEO优化 &lt;b&gt;只是视觉加粗效果—&gt;单纯为了产生加粗 &lt;em&gt; &lt;i&gt;标签 em用于强调文本 i只是视觉斜体效果 &lt;strong&gt;比&lt;em&gt;强调更强 span标签 对被用来组合文档中的行内元素 注意：span没有固定的格式表现，当对它应用样式时，才会产生视觉上的变化 &lt;pre&gt;标签 文字的格式按源码的排版来显示，我们称之为预处理格式 &lt;a&gt;标签—&gt;他有一个必不可少的属性 href target属性： _self(在原来页面打开) _blank（新窗口打开） _top（打开时忽略所有的框架） _parent（在父窗口中打开） 创建锚点和锚链接 锚点也是一种超链接，是页面内进行跳转的超链接- 第一步：创建锚点 `&lt;a name=&quot;锚点名称&quot;&gt;&lt;/a&gt;` - 第二步：使用创建好的锚点名称 `&lt;a href=&quot;#锚点名称&quot;&gt;内容&lt;/a&gt;` marquee标签 可以创建一个内容滚动效果1&lt;marquee direction=\"down\" loop=\"4\" onmouseover=this.stop() onmouseout=this.start()&gt;&lt;/marquee&gt; direction 表示滚动方向，取值有（left,right,up,down,默认left） loop表示滚动循环的次数，默认为无限循环 1onmouseover=this.stop() onmouseover=this.start() scrollamout=\"1\"(滚动速度) 表示当鼠标移上区域的时候停止滚动，鼠标移开继续滚动 第二章 img图片标签与路径 图片标签与路径： 常见图片格式 jpg png gif Gif （只支持全透明） Jpeg /jpg Png 半/全透明都支持 图片标签写法 ： &lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt; 图片四要素： src=&quot;&quot; 图片路径 alt=&quot;&quot; 图片含义 width=&quot;&quot; 图片宽度 和图片大小保持一致 height=&quot;&quot; 图片高度 和图片大小保持一致 title=&quot;&quot; 路径知识： 相对路径、绝对路径： 相对路径：(Relative Path) 相对于该文件的路径； 绝对路径：(Absolute Path) 从磁盘出发的路径； &lt;img src=&quot;&quot; …… align=&quot;&quot; /&gt; align属性–设置图片与后面文字的位置关系值–top、bottom、middle、absmiddle、left、right 在静态页面中： /开头表示根目录； ./表示当前目录；（斜画线前面一个点） ../上级目录；（斜画线前面两个点） 直接用文件名不带/也表示同一目录 这些都是相对于当前文件的位置来说的，如果用绝对路径的话就是写全了。 第三章 三种列表的讲解 三种列表的知识讲解： &lt;ul&gt;无序列表 无序列表是一个没有顺序项目的列表，此列表项默认粗体圆点进行标识 12345&lt;ul&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 有序列表 - 有序列表也是一列项目，只是列表项目使用的是数字进行标记。 有序列表始于 `` 标签。每个列表项始于 ` `标签。 12345&lt;ol&gt; &lt;li&gt;内容一&lt;&#x2F;li&gt; &lt;li&gt;内容二&lt;&#x2F;li&gt; &lt;li&gt;内容三&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 列表符号 无序列表-列表符号: type=&quot;circle&quot; 空心圆 type=“disc” 实心圆 默认值 type=&quot;square&quot; 方块符 有序列表-列表符号 type=&quot;A&quot; A B C D type=&quot;a&quot; a b c d type=&quot;1&quot; 1 2 3 4 默认值type=”I” I II III type=”i” i ii iii 列表嵌套 无序列表-嵌套 123456789&lt;ul&gt; &lt;li&gt;柚子 &lt;ul&gt; &lt;li&gt;沙田柚&lt;&#x2F;li&gt; &lt;li&gt;蜜柚&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;荔枝&lt;&#x2F;li&gt; &lt;li&gt;苹果&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 有序列表-嵌套 123456789&lt;ol&gt; &lt;li&gt;茶 &lt;ul&gt; &lt;li&gt;红茶&lt;&#x2F;li&gt; &lt;li&gt;绿茶&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;果汁&lt;&#x2F;li&gt; &lt;li&gt;牛奶&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 定义列表 定义列表不仅仅是一列项目，而是项目及其注释的组合。定义列表以 &lt;dl&gt; 标签开始。每个定义列表项以 &lt;dt&gt;开始。每个自定义列表项的定义以 &lt;dd&gt; 开始。 123456&lt;dl&gt; &lt;dt&gt;pc网页制作&lt;&#x2F;dt&gt; &lt;dd&gt;学习DIV+CSS JS JQ 项目实战&lt;&#x2F;dd&gt; &lt;dt&gt;手机网页制作&lt;&#x2F;dt&gt; &lt;dd&gt;手机网页制作实战&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt; dd是对dt的解释 &lt; dl&gt;&lt; /dl&gt;用来创建一个普通的列表, &lt; dt&gt;&lt; /dt&gt;用来创建列表中的上层项目， &lt; dd&gt;&lt; /dd&gt;用来创建列表中最下层项目， &lt; dt&gt;&lt; /dt&gt;和&lt; dd&gt;&lt; /dd&gt;都必须放在&lt; dl&gt;&lt; /dl&gt;标志对之间。 12345678910&lt;dl&gt; &lt;dt&gt;中国城市&lt;&#x2F;dt&gt; &lt;dd&gt;北京 &lt;&#x2F;dd&gt; &lt;dd&gt;上海 &lt;&#x2F;dd&gt; &lt;dd&gt;广州 &lt;&#x2F;dd&gt; &lt;dt&gt;美国城市&lt;&#x2F;dt&gt; &lt;dd&gt;华盛顿 &lt;&#x2F;dd&gt; &lt;dd&gt;芝加哥 &lt;&#x2F;dd&gt; &lt;dd&gt;纽约 &lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt; dl是definition list的缩写 dt是definition title的缩写 dd是definition description的缩写 list-style属性具有三个属性分量： list-style-position ：设置列表项图标的位置，位于文本内或者文本外 list-style-type： 设置列表项图标的类型 list-style-image：使用图像设置列表项图标 第四章 表单元素(上) 表单标签: &lt;form&gt;表单标签 &lt;form&gt;表单是一个包含表单元素的区域，包括起来的都是表单的内容123&lt;form&gt; &lt;input type&#x3D;&quot;text&quot;&#x2F;&gt;&lt;&#x2F;form&gt; HTML标签 - Action和确认按钮： 当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 1234&lt;form action&#x3D;&quot;html.do&quot; method&#x3D;&quot;get&quot;&gt; username: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;user&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提 交&quot; &#x2F;&gt;&lt;&#x2F;form&gt; HTML标签 - 隐藏域隐藏标签： 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 123&lt;form&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;hid&quot; value&#x3D;&quot;value&quot;&gt;&lt;&#x2F;form&gt; &lt;input&gt;标签的掌握 常用type类型： &lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; /&gt; type=&quot;text&quot; 单行文本输入框 type=&quot;password&quot; 密码（maxlength=&quot;&quot;） type=&quot;radio&quot; 单项选择（checked=&quot;checked&quot;） type=&quot;checkbox&quot; 多项选择 type=&quot;button&quot; 按钮 type=&quot;submit&quot; 提交 type=&quot;image&quot;图片提交 type=&quot;file&quot; 上传文件 type=&quot;reset&quot;重置 type=&quot;hidden&quot; 隐藏 关于表单中的设置默认值： 123&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;&quot; value&#x3D;&quot;今天心情不错&quot; &#x2F;&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;&quot; value&#x3D;&quot;&quot; checked&#x3D;&quot;checked&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;&quot; value&#x3D;&quot;&quot; checked&#x3D;&quot;checked&quot;&gt; 1234&lt;select name&#x3D;&quot;&quot; &gt; &lt;option value&#x3D;&quot;&quot;&gt;&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;&quot; selected&#x3D;&quot;selected&quot;&gt;&lt;&#x2F;option&gt;&lt;select&gt; textarea没有默认值 &lt;label&gt;标签的使用 &lt;label&gt;&lt;/label&gt; label 元素不会向用户呈现任何特殊效果。 不过，它为鼠标用户改进了可用性。 如果您在 label 元素内点击文本，就会触发此控件。 就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 &lt;label&gt; 标签的for 属性应当与相关元素的 id属性相同。 例子：（重要—注册表单–用户体验–必做） 123&lt;p&gt;单向选择&lt;&#x2F;p&gt;&lt;label for&#x3D;&quot;male&quot;&gt;男：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; id&#x3D;&quot;male&quot;&#x2F;&gt;&lt;label for&#x3D;&quot;nv&quot;&gt;女：&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot;checked&#x3D;&quot;check&quot;&#x2F;&gt; 第五章 表单和表格(下) 表单和表格标签： &lt;textarea&gt;文本域标签 &lt;textarea&gt;标签： &lt;textarea&gt;&lt;/textarea&gt;是文本域标签，可以在其中插入一段文字内容，它有两个常用属性rows和cols 注意： rows表示这个文本域有多少行 cols表示这个文本域有多少列 除了这两个属性它还有readonly（只读，文本域的内容无法改变，相当于协议）和title（鼠标放上提示） &lt;select&gt;标签的掌握 注：当提交表单时，浏览器会提交选定的项目，或者收集用逗号分隔的多个选项，将其合成一个单独的参数列表，并且在将 &lt;select&gt; 表单数据提交给服务器时包括 name属性123456&lt;form&gt; &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot;&gt; &lt;option value&#x3D;&quot;1&quot;&gt;1月&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;2&quot;&gt;2月&lt;&#x2F;option&gt; &lt;&#x2F;select&gt;&lt;&#x2F;form&gt; 常用到的属性：disabled=“disabled” name=&quot;sel&quot; size=&quot;2&quot; &lt;table&gt;表格标签 &lt;table&gt;表格标签：&lt;table&gt;是表格标签，可以用它定义一个表格。 123456&lt;table border&#x3D;&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;&#x2F;td&gt; &lt;td&gt;性别&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 注意：&lt;table&gt;的border属性不能少 &lt;tr&gt; &lt;td&gt;标签的使用 &lt;tr&gt;行标签： &lt;tr&gt;可以定义表格中的一行，一个&lt;tr&gt;&lt;/tr&gt;表示一行。 1234567891011&lt;table border&#x3D;&quot;1&quot;&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;&#x2F;td&gt; &lt;td&gt;性别&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;&#x2F;td&gt; &lt;td&gt;性别&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; &lt;td&gt;单元格标签: &lt;td&gt;可以定义表格中的一个单元格，&lt;td&gt;&lt;/td&gt;表示一个单元格。1234567&lt;table border&#x3D;&quot;1&quot;&gt;&lt;tr&gt;&lt;td &gt;姓名&lt;&#x2F;td&gt;&lt;td&gt;性别&lt;&#x2F;td&gt;&lt;td&gt;爱好&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; border-collapse 属性设置是否将表格边框折叠为单一边框： border-collapse:collapse; colspan左右合并 rowspan上下合并 第一部分总结： 非可视化标签：head meta style scrpit... 可视化标签：img div span a ul li… 只有可视化标签，才能用css改变它 单标签：meta link base img input br hr 双标签：html head body div a p span ..ul li ol dl …. 常用可视化标签 ** div** 一般用它来布局 a 超链接标签 href*属性：设置跳转的网页地址 target属性：设置跳转的目标 结论：凡事页面可以点击跳转或者表单提交的文字，都用a标签 img src*属性用来设置图片的url数据 alt提供给搜索引擎搜索的 width height 结论 ：显示图片 ul li 列表 结论：只要将来设计页面中有固定样式的列表，就用ul和li table caption tr td (th) 慢慢已经被淘汰了 被ul li代替 如果是合并竖排的就是合并行（rowspan） 如果是合并横排的就是合并列（colspan） HTML部分导图总结 HTML5标签集合 第二部分 CSS 第八章 css基础知识 css基础知识： css样式表的定义 css：（Cascading Style Sheets）层叠样式表； 分类及位置：内部样式-head区域style标签里面 外部样式-link调用 内联样式-标签元素里面 css内的注释：/*注释内容*/ css样式表的语法 CSS规则由两个主要的部分构成：要添加样式的盒子名或者标签名、和要添加的样式。 盒子名或者标签名{属性:值;} CSS中几种颜色的表示方法 用颜色名表示 有17个预先确定的颜色，它们是 aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, orange, purple, red, silver, teal, white, and yellow 用十六进制的颜色值表示(红、绿、蓝) #FF0000或者#F00 用rgb(r,g,b)函数表示 如：rgb(255,255,0) 用hsl(Hue,Saturation,Lightness)函数表示（色调、饱和度、亮度) 如：hsl(120,100%,100%),色调0代表红色，120代表绿色，240代表蓝色 *用rgba(r,g,b,a)函数表示 * 其中a表示的是改颜色的透明度，取值范围是0~1，其中0代表完全透明 用hsla(Hue,Saturation,Lightness,alpha)函数表示 色调、饱和度、亮度、透明度 例子 123456789 &lt;div style=\"position:absolute;top:0px\"&gt; &lt;div style=\"background-color:gray;\"&gt;background-color:gray&lt;/div&gt; &lt;div style=\"background-color:#F00;\"&gt;background-color:#F00&lt;/div&gt; &lt;div style=\"background-color:#ffff00;\"&gt;background-color:#ffff00&lt;/div&gt; &lt;div style=\"background-color:rgb(255,0,255);\"&gt;background-color:rgb(255,0,255)&lt;/div&gt; &lt;div style=\"background-color:hsl(120,80%,50%);\"&gt;background-color:hsl(120,80%,50%)&lt;/div&gt; &lt;div style=\"background-color:rgba(255,0,255,0.5);\"&gt;background-color:rgba(255,0,255,0.5)&lt;/div&gt; &lt;div style=\"background-color:hsla(120,80%,50%,0.5);\"&gt;background-color:hsla(120,80%,50%,0.5)&lt;/div&gt;&lt;/div&gt; 内部样式表 当单个页面需要设置样式时，就应该使用内部样式表。 使用 &lt;style&gt;&lt;/style&gt;标签在文档&lt;head&gt;&lt;/head&gt;里面定义内部样式表 12345&lt;head&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot; &gt; p&#123;color:red;&#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt; 从外部引入到样式分为两种：（注意写在head标签里面） 当样式需要应用于很多页面时，就需要用到外部样式表，首先需要创建一个css文件，然后引用到我们的页面中。 Link样式表式： &lt;link rel=”stylesheet” type=”text/css” href=”my.css”(href表示路径)&gt; Html式： &lt;style type=&quot;text/css&quot;&gt;@import url(&quot;css.css&quot;);&gt;&lt;/style&gt; 内联样式表（优先级高） 写在标签里面的样式 如：&lt;p style=&quot;color:red;&quot;&gt;&lt;/p&gt; 表示给p标签里面的文字颜色设置为红色 区别：外链样式与导入样式 link标签是属于xhtml范畴，而@import则是css2.1中特有的。link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。 加载的顺序的区别，link加载的css时，是一种并行(没有尝试是否是这样)加载CSS方式，而@impor则在整个页面加载完成后才加载。 兼容性的区别，因@import``CSS2.1才特有的，所以对于不兼容CSS2.1的浏览器来说，无效。 在样式控制上(比如动态改变网页的布局时,使用javascript操作DOM)的区别，此时@import就无能为力了。 样式的优先级补充 相同权值情况下，CSS样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）： 内联样式表（标签内部） &gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中） 权值不同时，浏览器是根据权值来判断使用哪种css样式的，哪种样式权值高就使用哪种样式 层叠优先级是: 浏览器缺省&lt; 外部样式表 &lt; 内部样式表 &lt; 内联样式 其中样式表又有:类选择器 &lt; 类派生选择器&lt;ID选择器 &lt; ID派生选择器 派生选择器以前叫上下文选择器，所以完整的层叠优先级是: 浏览器缺省 &lt;外部样式表 &lt; 外部样式表类选择器 &lt; 外部样式表类派生选择器&lt; 外部样式表ID选择器 &lt; 外部样式表ID派生选择器&lt; 内部样式表 &lt; 内部样式表类选择器 &lt; 内部样式表类派生选择器 &lt; 内部样式表ID选择器 &lt; 内部样式表ID派生选择器 &lt; 内联样式…共12个优先级 另外，如果同一个元素在没有其他样式的作用影响下，其Class定义了多个并以空格分开，其优先级顺序为： 一个元素同时应用多个class，后定义的优先（即近者优先），加上!important者最优先！ 选择器权重 选择器 权重值 !important infinity（正无穷） 行间样式 1000 id选择器 100 class、属性、伪类选择器 10 标签选择器、伪元素选择器 1 通配符选择器 0 第九章 css选择器(上) css选择器： class类选择器可以重复利用 id选择器唯一 标签选择器 什么是选择器：css选择器就是要改变样式的对象 选择器{属性:值;属性:值;} 标签选择器：页面中所有的标签都是一个选择器 p{color:red;} 通配符选择器 * 选择全部的元素 以 * 开头，如: *{color:#0f0;} ID选择器 选择id命名的元素 以 # 开头 #p1{color:#0f0;} 类选择器 class选择器，选择clas命名的元素 以.开头 .first{color:#00f;} css代码写完后上线前要经过压缩处理 本地和服务器分两个css版本（备份） 压缩后注释都清除，空间体积减少 群组选择器 选择多个元素,以逗号隔开 #main,.first,span,a,h1{color:red;} 包含选择器 选择某元素的后代元素，也称后代选择器，父类与子类间以空格隔开p span{color:red;} 属性选择器 选择包含某一属性的元素 a[title]{color:red;} 选择包含title的a标签 a[title][href]{color:red;} 选择包含title和href的a标签 &gt; + 选择器子类选择器：只选择子元素（只选择儿子）（相当于包含元素） p &gt; span{color:red;} 相邻兄弟选择器：只选择后面的相邻兄弟元素 p + span{color:red;} 第十章 css选择器(下) &lt;a&gt;伪类选择器 a:link {color:#FF0000;} /* 超链接未访问时的状态 */ （只用于a标签） a:visited {color:#00FF00;} /* 超链接访问过后的状态 */ （只用于a标签） a:hover {color:#FF00FF;}/* 鼠标悬停状态 */（可和其他标签结合一起用） a:active {color:#0000FF;} /* 激活状态，鼠标按下状态 */ 注意 伪类选择器的排序很重要，a:link a:visited a:hover a:active，记作lvha 输入伪类选择器（针对表单） input:focus{color:red;} /* 键盘输入焦点 */ 位置伪类选择器（针对表单） p:first-child{color:red;} /* 第一个p */ p:last-child{color:red;} /* 最后一个p */ 伪元素选择器 :before 在元素之前添加内容。 :after 在元素之后添加内容。 css优先规则 内联样式表-&gt; ID 选择器—&gt; Class 类选择器-&gt;标签选择器 第十一章 背景属性 背景属性： 背景的添加 ： 背景颜色的添加: background:red; backgronnd-color:red; 背景图片的添加： background:url(“images/1.jpg”); backgronnd-image:url(“images/1.jpg”); 背景的平铺 什么是平铺？平铺就是图片是否重复出现 不平铺：background-repeat:no-repeat; 水平方向平铺：background-repeat:repeat-x; 垂直方向平铺：background-repeat:repeat-y; 完全平铺：默认为完全平铺 背景图片的定位 背景图片的定位就是可以设置显示背景图片的位置，通过属性background-position来实现 background-position的取值可为英文单词或者数值和百分值。 background-positon的英文单词取值 top left top center top right center left center center center right bottom left bottom center ottom right background-positon的数值取值 background-position:x y; positon的百分值取值 background-position:x% y%; 背景图片的大小 背景图片的大小可以通过属性background-size来设置background-size的取值可为数值和百分值。 background-size的数值取值 background-size:x y; background-size的数值取值 background-size:x% y%; 背景图片的滚动 背景图片是否随着内容的滚动而滚动由background-attachment设置 background-attachment:fixed; 固定，不随内容的滚动而滚动 background-attachment:scroll; 滚动，随内容的滚动而滚动 第十二章 文字文本属性 css文字文本属性： 文字属性 color:red; 文字颜色 font-size:12px; 文字大小 font-weight:“bold” 文字粗细(bold/normal) font-family:“宋体” 文字字体 font-variant:small-caps小写字母以大写字母显示 文本属性 text-align:center; 文本对齐(right/left/center) line-height:10px; 行间距(可通过它实现文本的垂直居中) text-indent:20px; 首行缩进 text-decoration:none; 文本线(none/underline/overline/line-through) letter-spacing: 字间距 第十三章 盒子模型 盒子模型 盒子模型就是一个有高度和宽度的矩形区域 所有html标签都是盒子模型 div标签自定义盒子模型 所有的标签都是盒子模型 class和id的主要差别是：class用于元素组（类似的元素，或者可以理解为某一类元素），而id用于标识单独的唯一的元素。 盒子模型的组成 盒子模型组成部分： 自身内容：width、height 宽高 内边距： padding 盒子边框： border 边框线 与其他盒子距离： margin外边距 内容+内边距+边框+外边距=面积 border 边框 常见写法 border:1px solid #f00; 单独属性： border-width: border-style: dotted 点状虚线 dashed（虚线） solid（实线） double（双实线） border-color (颜色) padding 内边距 值：像素/厘米等长度单位、百分比 padding:10px; 上下左右 padding:10px 10px; 上下 左右 padding:10px 10px 10px; 上 左右 下 padding:10px 10px 10px 10px; 上 右 下 左（设置4个点–&gt;顺时针方向） 单独属性： padding-top: padding-right: padding-bottom: padding-left: 当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据width和height减小 margin 外边距 值：与padding相同 单独属性：与padding相同 外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并 补充盒子模型内容 标准盒子模型 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型 从上图可以看到标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content部分不包含其他部分 ** IE盒子模型** 从上图可以看到 ie盒子模型的范围也包括 margin、border、padding、content 和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border和 padding IE盒子模型width = padding+border+内容 标准盒子模型 = 内容的宽度（不包含border+padding） 例： 一个盒子的 margin为 20px，border 为 1px，padding为 10px，content 的宽为 200px、高为 50px，假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为：宽 20*2+1*2+10*2+200=262px、高 20*2+1*2*10*2+50=112px，盒子的实际大小为：宽 1*2+10*2+200=222px、高 1*2+10*2+50=72px；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 20*2+200=240px、高 20*2+50=70px，盒子的实际大小为：宽 200px、高 50px 那应该选择哪中盒子模型呢？当然是“标准 w3c 盒子模型”了。怎么样才算是选择了“标准 w3c盒子模型”呢？很简单，就是在网页的顶部加上 doctype 声明。 假如不加doctype 声明，那么各个浏览器会根据自己的行为去理解网页，即 ie浏览器会采用 ie 盒子模型去解释你的盒子，而 ff会采用标准w3c 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。 反之，假如加上了 doctype 声明，那么所有浏览器都会采用标准 w3c盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。 用 jquery 做的例子来证实一下 123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是？&lt;&#x2F;title&gt;&lt;script language&#x3D;&quot;javascript&quot; src&#x3D;&quot;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script language&#x3D;&quot;javascript&quot;&gt;var sbox &#x3D; $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 上面的代码没有加上 doctype 声明，在 ie 浏览器中显示 ie盒子模型，在 ff 浏览器中显示“标准w3c 盒子模型”。 12345678910111213&lt;!doctype html public &quot;-&#x2F;&#x2F;w3c&#x2F;&#x2F;dtd xhtml 1.0 transitional&#x2F;&#x2F;en&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;tr&#x2F;xhtml1&#x2F;dtd&#x2F;xhtml1-transitional.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是标准w3c盒子模型&lt;&#x2F;title&gt;&lt;script language&#x3D;&quot;javascript&quot; src&#x3D;&quot;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script language&#x3D;&quot;javascript&quot;&gt;var sbox &#x3D; $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 代码2 与代码1 唯一的不同的就是顶部加了 doctype声明。在所有浏览器中都显示“标准 w3c盒子模型” 所以为了让网页能兼容各个浏览器，让我们用标准 w3c 盒子模型 扩展 学会使用box-sizing布局 第十四章 块元素、行元素与溢出 基本概念 块级元素：默认情况下独占一行的元素，可控制宽高、上下边距； 行内元素：默认情况下一行可以摆放多个的元素，不可控制宽高和上下边距 行块转换 display:none; 不显示 display:block; 变成块级元素 display:inline; 变成行级元素 display:inline-block; 以块级元素样式展示，以行级元素样式排列 溢出 overflow:hidden; 溢出隐藏 overflow:scroll; 内容会被修剪，浏览器会显示滚动条 overflow:auto; 如果内容被修剪，则产生滚动条 文本不换行：white-space:nowrap; 长单词换行：word-wrap:break-word; 行内元素和快级元素小结 一、块级元素：block element 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素； 块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。 DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。 二、行内元素：inline element 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN元素，IFRAME元素和元素样式的display : inline的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。 三、block（块）元素的特点: ①、总是在新行上开始； ②、高度，行高以及外边距和内边距都可控制； ③、宽度缺省是它的容器的100%，除非设定一个宽度。 ④、它可以容纳内联元素和其他块元素 四、inline元素的特点 ①、和其他元素都在一行上； ②、高，行高及外边距和内边距不可改变； ③、宽度就是它的文字或图片的宽度，不可改变 ④、内联元素只能容纳文本或者其他内联元素 对行内元素，需要注意如下: 设置宽度width 无效。 设置高度height无效，可以通过line-height来设置。 设置margin 只有左右margin有效，上下无效。 设置padding只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 五、常见的块状元素 address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是CSS layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript – 可选脚本内容（对于不支持script的浏览器显示此内容） ol – 有序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 无序列表 六、常见的内联元素 a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) bdo – bidi override big – 大字体 br – 换行 cite – 引用 code – 计算机代码(在引用源码的时候需要) dfn – 定义字段 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 kbd – 定义键盘文本 label – 表格标签 q – 短引用 s – 中划线(不推荐) samp – 定义范例计算机代码 select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 七，可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del- 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 八、行内元素与块级元素有什么不同 区别一： 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。 区别二： 块级：块级元素可以设置宽高 行内：行内元素不可以设置宽高 区别三： 块级：块级元素可以设置margin，padding 行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。 区别四： 块级：display:block; 行内：display:inline; 替换元素有如下：（和img一样的设置方法） &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt; &lt;object&gt;都是替换元素，这些元素都没有实际的内容 可以通过修改display属性来切换块级元素和行内元素 第十五章 定位 static静态定位（不对它的位置进行改变，在哪里就在那里） 默认值。没有定位，元素出现在正常的流中（忽略 top,bottom, left, right 或者 z-index 声明）。 fixed固定定位（参照物–浏览器窗口）—做 弹窗广告用到 生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot;以及 &quot;bottom&quot;属性进行规定。 relative（相对定位 ）（参照物以他本身） 生成相对定位的元素，相对于其正常位置进行定位。 absolute（绝对定位）(除了static都可以，找到参照物–&gt;与它最近的已经有定位的父元素进行定位) 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 元素的位置通过 “left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定 z-index z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。 一切皆为框 块级元素: div、h1或p元素 即：显示为一块内容称之为 “块框“ ; 行内元素: span,strong,a等元素 即：内容显示在行中称 “行内框”; 使用display属性改变成框的类型 即：display:block; 让行内元素设置为块级元素，display:none; 没有框 相对定位： 如果对一个元素进行相对定位，它将出现在它所在的位置上。 通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动 .adv_relative { position: relative; left: 30px; top: 20px; } 绝对定位： 元素的位置相对于最近的已定位祖先元素，如果元素没有已定位 的祖先元素，它的位置相对于最初的包含块。 .adv_absolute { position: absolute; left: 30px; top: 20px; } 第十六章 框架 frameset框架： &lt;frameset&gt; —- 用来定义一个框架；双标签不能和 &lt;body&gt; 一起使用 rows、cols属性 rows 定义行表示框架有多少行（取值 px/%/ * ） cols 定义列表示框架有多少列（取值px/ %/ * ） frame子框架 &lt;frame&gt; —- 表示框架中的某一个部分；单标签，要跟结束标志 src 显示的网页的路径 name 框架名 frameborder 边框线（取值 0 / 1） &lt;noframes&gt;属性 &lt;noframes&gt; 提供不支持框架的浏览器显示body的内容；双标签 12345678&lt;frameset&gt; &lt;frame src&#x3D;“” &#x2F;&gt; &lt;frame src&#x3D;“” &#x2F;&gt; &lt;frame src&#x3D;“” &#x2F;&gt; &lt;noframes&gt; &lt;body&gt;内容&lt;&#x2F;body&gt; &lt;&#x2F;noframes&gt;&lt;&#x2F;frameset&gt; &lt;iframe&gt;内联框架 iframe元素会创建包含另外一个文档的内联框架（即行内框架） 允许和 body 一起使用 width 宽（取值 px / %） height 高（取值 px / %） name 框架名 frameborder 边框线（取值 0 / 1） src 显示的网页的路径 第十七章 css高级属性 opacity透明属性 opacity 对于IE6/7/，使用filter:alpha(opacity:值;) 值为0-100 对于Webkit，Opera，Firefox，IE9+，使用opacity:值; 值为0-1 对于早期火狐，使用-moz-opacity:值; 值为0-1 所以写透明属性时，一般写法是 12345 &#123; opacity:0.5; filter:alpha(opacity：50);&#x2F;*0-100*&#x2F; -moz-opacity:0.5; &#x2F;*取值0-1*&#x2F;--&gt;针对早起版本的火狐兼容问题的解决&#125; border-radius圆角边框属性 向 div 元素添加圆角边框 border-radius:10px; box-shadow阴影属性 box-shadow属性向框添加阴影效果,后面跟4个参数。 box-shadow:0px 0px 10px #000; &lt;embed&gt;属性 是HTML5中新增的标签,媒体嵌入插件标签，可以通过&lt;embed&gt;插入音频或视频 &lt;embed src=“media/music.mp3” /&gt; 格式.mid .wav .mp3等 原文件下载地址 访问密码 342a css常见简写 第三部分 附录 附录一 CSS书写规范 为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合W3C的代码写到一个文件中,而一些IE中必须而又不能通过W3C验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入 123456&lt;!-- 放置所有浏览器样式--&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"\"&gt;&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;&lt;!--[if IE] &lt;link rel=\"stylesheet\" href=\"\"&gt;&lt;![endif]--&gt; CSS样式新建或修改尽量遵循以下原则 根据新建样式的适用范围分为三级：全站级、产品级、页面级。 尽量通过继承和层叠重用已有样式。 不要轻易改动全站级CSS。改动后，要经过全面测试。 属性显示顺序（规范写法） 显示属性 元素位置 元素属性 元素内容属性 CSS书写顺序 1234567891011121314151617181920212223242526272829 .header &#123;/* 显示属性 */ display || visibility list-style position top || right || bottom || left z-index clear float/* 自身属性 */ width max-width || min-width height max-height || min-height overflow || clip margin padding outline border background/* 文本属性 */ color font text-overflow text-align text-indent line-height white-space vertical-align cursor content &#125;; 兼容多个浏览器时，将标准属性写在底部 123-moz-border-radius: 15px; &#x2F;* Firefox *&#x2F;-webkit-border-radius: 15px; &#x2F;* Safari和Chrome *&#x2F;border-radius: 15px; &#x2F;* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *&#x2F;&#x2F;标准属性 使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式 .hd,.bd,.td{};//如这些命名 可用上级节点进行限定 .recommend-mod .hd 多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。 123button.btn,input.btn,input[type=\"button\"] &#123;…&#125;; 优化CSS选择器 #header a { color: #444; };/*CSS选择器是从右边到左边进行匹配*/ 浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下 12345避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器不要限定id选择符，如div#header（提权的除外）不要限定类选择器，如ul.recommend（提权的除外）不要使用 ul li a 这样长的选择符避免使用标签子选择符，如#header &gt; li &gt; a 使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。 尽量避免使用CSS Hack 12345678910111213property:value; /* 所有浏览器 */+property:value; /* IE7 */_property:value; /* IE6 */*property:value; /* IE6/7 */property:value\\9; /* IE6/7/8/9，即所有IE浏览器 */\\* html selector &#123; … &#125;; /* IE6 */\\*:first-child+html selector &#123; … &#125;; /* IE7 */html&gt;body selector &#123; … &#125;; /* 非IE6 */@-moz-document url-prefix() &#123; … &#125;; /* firefox */@media all and (-webkit-min-device-pixel-ratio:0) &#123; … &#125;; /* saf3+/chrome1+ */@media all and (-webkit-min-device-pixel-ratio:10000),not all and (-webkit-min-device-pixel-ratio:0) &#123; … &#125;; /* opera */@media screen and (max-device-width: 480px) &#123; … &#125;; /* iPhone/mobile webkit */ 避免使用低效的选择器 12345body &gt; * &#123;…&#125;;ul &gt; li &gt; a &#123;…&#125;;#footer &gt; h3 &#123;…&#125;;ul#top_blue_nav &#123;…&#125;;#searbar span.submit a &#123; … &#125;; /* 反面示例 */ 六个不要三个避免一个使用 12345678910不要在标签上直接写样式不要在CSS中使用expression不要在CSS中使用@import不要在CSS中使用!important不要在CSS中使用“*”选择符不要将CSS样式写为单行避免使用filter避免使用行内（inline）样式避免使用“*”设置&#123;margin: 0; padding: 0;&#125;使用after或overflow的方式清浮动 减少使用影响性能的属性 12position:absolute;float:left;&#x2F;&#x2F;如这些定位或浮动属性 减少在CSS中使用滤镜表达式和图片repeat,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px 附录二 DIV命名规范 企业DIV使用频率高的命名方法 网页内容类 标题: title 摘要: summary 箭头： arrow 商标： label 网站标志： logo 转角/圆角：corner 横幅广告： banner 子菜单： subMenu 搜索： search 搜索框： searchBox 登录： login 登录条：loginbar 工具条： toolbar 下拉： drop 标签页： tab 当前的： current 列表： list 滚动： scroll 服务： service 提示信息： msg 热点：hot 新闻： news 小技巧： tips 下载： download 栏目标题： title 热点： hot 加入：joinus 注册： regsiter 指南： guide 友情链接： friendlink 状态： status 版权： copyright 按钮： btn 合作伙伴： partner 投票： vote 左右中：left right center 注释的写法: /* Footer */ 内容区/* End Footer */ id的命名: 页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的:current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class的命名: 颜色:使用颜色的名称或者16进制代码,如 .red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } 字体大小,直接使用”font+字体大小”作为名称,如 .font12px { font-size: 12px; } .font9px {font-size: 9pt; } 对齐样式,使用对齐目标的英文名称,如 .left { float:left; } .bottom { float:bottom; } 标题栏样式,使用”类别+功能”的方式命名,如 .barnews { } .barproduct { } 注意事项:: 一律小写; 尽量用英文; 不加中杠和下划线; 尽量不缩写，除非一看就明白的单词. 推荐的 CSS 书写顺序： 显示属性 display list-style position float clear 自身属性 width height margin padding border background 文本属性 color font text-decoration text-align vertical-align white-space other text content 附录三 CSS精灵 CSS精灵原理以及应用 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。 该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。 一个简单的例子： 一张图片作出一个按钮的三个状态 一个链接用CSS做成按钮的样式，我们可以使用同一张图片，完成按钮的三个状态，a:link，a:hover，a:active &lt;a class=&quot;button&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt; 加入右侧的图片为：200px 65px的三个按钮图拼合而成的图片button.png，从上到下一次为按钮的普通、鼠标滑过、鼠标点击的状态。则可以使用CSS进行定义。 12345678910111213141516171819a &#123; display:block; width:200px; height:65px; line-height:65px; &#x2F;*定义状态*&#x2F; text-indent:-2015px; &#x2F;*隐藏文字*&#x2F; background-image:url(button.png); &#x2F;*定义背景图片*&#x2F; background-position:0 0; &#x2F;*定义链接的普通状态，此时图像显示的是顶上的部分*&#x2F;&#125;a:hover &#123; background-position:0 -66px; &#x2F;*定义链接的滑过状态，此时显示的为中间部分，向下取负值*&#x2F;&#125;a:active &#123; background-position:0 -132px; &#x2F;*定 义链接的普通状态，此时显示的是底部的部分，向下取负值*&#x2F;&#125; 更多的CSS雪碧，图片更复杂，背景定位更精确。可能会用到大量的数值 如：background:url(nav.png) -180px 24pxno-repeat; 来达到更精确的定位 优点： 减少加载网页图片时对服务器的请求次数 可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。 提高页面的加载速度 sprite技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。 减少鼠标滑过的一些bug IE6不会主动预加载鼠标滑过即a:hover中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用CSS雪碧，由于一张图片即可，所以不会出现这种现象。 不足： CSS雪碧的最大问题是内存使用 影响浏览器的缩放功能 拼图维护比较麻烦 使CSS的编写变得困难 CSS 雪碧调用的图片不能被打印 错误得使用 Sprites 影响可访问性 附录四 一些tips解决方案 页面优化实践 从下面的几个方面可以进行页面的优化： 减少请求数 图片合并 CSS文件合并 减少内联样式 避免在 CSS中使用 import 减少文件大小 选择适合的图片格式 图片压缩 CSS 值缩写（Shorthand Property) 文件压缩 页面性能 调整文件加载顺序 减少标签数量 调整选择器长度 尽量使用CSS 制作显示表现 增强代码可读性与可维护性 规范化 语义化 模块化 写DIV+CSS 的一些常识 不要使用过小的图片做背景平铺 这就是为何很多人都不用 1px 的原因，这才知晓。宽高 1px 的图片平铺出一个宽高 200px 的区域，需要 200200=40, 000 次，占用资源 无边框 推荐的写法是 border:none;，哈哈，我一直在用这个。 border:0; 只是定义边框宽度为零，但边框样式、颜色还是会被浏览器解析，占用资源 慎用 通配符 所谓通配符，就是将CSS 中的所有标签均初始化，不管用的不用的，过时的先进的，一视同仁，这样，大大的占用资源。要有选择的初始化标签。 CSS的十六进制颜色代码缩写 习惯了缩写及小写，这才知道，原来不是推荐的写法，为的是减少解析所占用的资源。但同时会增加文件体积。孰优孰劣，有待仔细考证。 样式放头上，脚本放脚下。不内嵌，只外链 坚决不用 CSS表达式 使用 引用样式表，而不是通过@import 导入。 一般来说，PNG比 GIF 要小，小得多。再者，GIF 中有多少颜色是被浪费的，很值得优化。 千万不要在 HTML中缩放图片，一者不好看，二者占资源。 正文字体最好用偶数 12px、14px、16px，效果非常好。特例，15px。 block、ul、ol等上下留出至少一倍行距，左侧至少两倍行距，右侧随意。 段落之间，至少要有一倍行距 强行指定某些元素的 line-height，正文 1.6倍于文字大小，标题1.3倍。 中文标点用全角 英文夹杂在中文中，左右空格，半角。 中文字体的粗体和斜体，远离较好 常用代码片段 雅虎工程师提供的CSS初始化示例代码【仅供参考】 可以在html头文件中直接引用，从而避免浏览器的不兼容带来的错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px;&#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption,cite, code, dfn, em, strong,th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none;&#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123; overflow-y: scroll;&#125; .clearfix:after &#123; content: \".\"; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; mobile meta标签 1&lt;meta name=”viewport” content=”width=320,target-densitydpi=dpi_value,initial-scale=1, user-scalable=no”/&gt; 表格不被撑开 123table-layout: fixed;word-break: break-all;border-collapse: collapse; 不设宽高居中 12345&lt;div id=”abc” style=”display:table;text-align:center;width:100%;height:100%;”&gt; &lt;span style=”background:#f00; display:table-cell; vertical-align:middle;”&gt; &lt;input type=”button” value=”item1″ /&gt; &lt;/span&gt;&lt;/div&gt; 透明度的兼容代码 1234filter:alpha(opacity=50); /*1-100*/-moz-opacity:0.5; /*0-1.0*/-khtml-opacity:0.5; /*0-1.0*/opacity:0.5; /*0-1.0*/ 文字溢出点点省略 123white-space:nowrap;text-overflow:ellipsis;overflow:hidden; 清除浮动的几种方法 方法一：投机取巧法 – 不推荐 直接一个放到当作最后一个子标签放到父标签那儿，此方法屡试不爽，兼容性强 方法二：overflow + zoom方法 –不推荐 .fix{overflow:hidden; zoom:1;} 此方法优点在于代码简洁，涵盖所有浏览器 方法三：after + zoom方法 -推荐–此方法可以说是综合起来最好的方法了 clearfix只应用在包含浮动子元素的父级元素上 12345678.fix&#123;zoom:1;&#125;.fix:after&#123; display:block; content:'clear'; clear:both; line-height:0; visibility:hidden;&#125; 更多代码片段详情 实用的60个CSS代码片段 一些总结 自动继承属性： color font text-align list-style… 非继承属性： background border position… 具有破坏性的元素： float display:none; position:absoblute/fixed/sticky; 具有包裹性的元素： display:inline-block/table-cell position:absolute/fixed/sticky overflow:hidden/scroll 消除图片底部间隙的方法 图片块状化-无基线对齐img{display:block;} 图片底线对齐img{vertical-align:bottom;} 行高足够小 - 基线位置上移.box{line-height:0;} 一些概念 BFC BFC全称”Block Formatting Context” 中文为“块级格式化上下文” 记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 扩展阅读 CSS中的BFC 优雅降级(graceful degradation) 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 渐进增强 progressive enhancement： 是在浏览器开启JavaScript功能后，如果浏览器版本不支持某些 JavaScript 能力，我们解决这种问题的方式 平稳退化 是在浏览器没有JavaScript功能，或没有开启JavaScript功能情况下，我们解决这种问题的方式； 方案荟萃扩展阅读 关于布局 垂直居中 css完全居中 居中之美 网页中的底部foot定位 页面高度100% textarea高度自适应 多行溢出省略 Retina屏1px线 Flexbugs 其他 IF IE ENDIF条件判断之IE10 Chrome 翻译插件 网页retina优化 常用meta 树状菜单 em vs rem css vs js css解决方案（w3cplus） Textures生成纹理 CSSgram Csscss（检查重复声明等） 附录五 部分工具资源 学会使用Emmet插件快速编码 Emmet常用快捷键 Sublime专题 Sublime常用插件总结 Front-End -Develop -Tools ToolsBox-自己整理的一份工具列表 附录六 编码规范 编码规范 前端规范 web develop standard Web 前端开发规范文档 前端开发规范手册 附录七 进阶学习 DOM编程之API学习 JavaScript基础学习 附录八 其他资源 Github上前端学习资源汇总 WEB 前端开发学习笔记 前端开发工具箱 148个资源让你成为CSS专家 学习CSS布局-经典必看 附录九 常见问题 前端指路 写给前端面试者（w3cplus） 如何成为一名卓越的前端工程师（勾三股四博客） 什么是全栈工程师 如何跟上前端开发的最新前沿 浏览器的工作原理 移动前端开发和 Web 前端开发的区别 大型网站CSS编写与维护 CSS核心技术关键字 性能/规范/实践 如何阅读W3c规范(王晓轩) 如何阅读W3c规范(高博) 雅虎web性能优化军规 权威前端性能指南 高性能css 一些问答社区 quora stackoverflow 知乎 前端乱炖问答区 segmentfault问答区 附录十 职业规划和前景 职业方向规划定位： web前端开发工程师 web网站架构师 自己创业 转岗管理或其他 web前端开发的前景展望： 未来IT行业企业需求最多的人才 结合最新的html5抢占移动端的市场 自己创业做老板 随着互联网的普及web开发成为企业的宠儿和核心 web职业发展目标： 第一、梳理知识架构 负责内容的HTML 负责外观的css（层叠样式表） 负责行为的js ps切图 第二、分解目标（起步阶段、提升阶段、成型阶段） 起步阶段： 基本知识的掌握 常用工具的掌握 沟通技巧的掌握（围绕客户的需求） 良好的开发习惯（加注释、对齐方式） 提升阶段： 熟悉掌握HTML基本标签和属性 熟练掌握css的基本语法和使用 浏览器兼容和w3c标准的掌握 结合html+css+js开始系统项目的开发 成型阶段： 精通DIV+CCS布局 精通css样式表控制html标签 熟悉运用js制作动态网站的效果 能独立开发完成网站","categories":[{"name":"htmlのcss","slug":"htmlのcss","permalink":"http://yoursite.com/categories/html%E3%81%AEcss/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"},{"name":"jqeury","slug":"jqeury","permalink":"http://yoursite.com/categories/jqeury/"},{"name":"html5のcss3","slug":"html5のcss3","permalink":"http://yoursite.com/categories/html5%E3%81%AEcss3/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/categories/next/"},{"name":"htmlのcss","slug":"htmlのcss","permalink":"http://yoursite.com/categories/html%E3%81%AEcss/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"jqeury","slug":"jqeury","permalink":"http://yoursite.com/tags/jqeury/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"懒","slug":"懒","permalink":"http://yoursite.com/tags/%E6%87%92/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]}